<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ILNumerics.Core</name>
    </assembly>
    <members>
        <member name="T:ILNumerics.Array`1">
             <summary>
             The main n-dimensional, rectilinear array to be used in algorithms. 
             </summary>
             <typeparam name="T">Inner type. This will mostly be one of the predefined numeric <see cref="T:System.ValueType"/> 
             types or one of the complex ILNumerics floating point types: <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</typeparam>
             <remarks>This class serves as the main rectilinear array, holding arbitrary elements (usually numeric types or <see cref="T:ILNumerics.BaseArray"/>) 
             in arbitrary dimensions.
             <para>Arrays of this type may use any type as generic element. However, common mathematical functions and operators 
             are defined for a limited number of value type elements only. All binary operations (+,-,*,/,<![CDATA[<,>,<=]]>,etc.) are 
             defined for two arrays with the same <i>numeric type</i>, would it be from the <c>System</c> namespace (<see cref="T:System.Double"/>, 
             <see cref="T:System.Int32"/>, ...) or <see cref="T:ILNumerics.complex"/>/ <see cref="T:ILNumerics.fcomplex"/>. Most algebraic functions require floating point 
             types. See the <c>ILNumerics.ILMath</c> class for a list of all computational functions.</para>
             <para>Arrays are capable of creating flexible <a href="http://ilnumerics.net/$Subarray0.html" target="ILMain">subarrays</a> 
             and are mutable at runtime. Read about all details of ILNumerics arrays in the 
             <a href="http://ilnumerics.net/$Arrays.html" target="ILMain">ILNumerics Array documentation</a>.</para>
             <para>Arrays of this type are dense arrays. Cloning arrays is done as lazy 
             copy on write, i.e.: clones of existing arrays do only use new memory when attempting to alter one of them. Arrays integrate into the memory 
             management of ILNumerics. Read about the most <a href="http://ilnumerics.net/$GeneralRules.html" target="ILMain">important 
             simple rules</a> for using arrays in custom computational functions.</para>
             <para>Arrays come with overloaded mathematical operators, allowing for a convenient syntax. A 
             sophisticated memory management in the back will make sure, that as little memory is used as absolutely needed, even in 
             non-trivial expressions, like: a + c * 2 / abs(sin(c) * -b / log(a)). Here all arrays are of the same or broadcastable size. Evaluating 
             this expression does only need the memory of twice the size of one array. Memory gets collected and reused 
             for every subexpression evaluation. Further optimization options exist, as described in 
             <a href="http://ilnumerics.net/$PerfMemoryOpt.html" target="ILMain">Optimizing Algorithm Performance</a>.</para>
             </remarks>
             <example><para>A simple example demonstrating the uses of Array&lt;double&gt; in a very simple application:</para>
             <code>using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            using ILNumerics; 
            using static ILNumerics.ILMath;
            using static ILNumerics.Globals;
            
            namespace ConsoleApplication1 {
                class Program {
                    static void Main(string[] args) {
                        using (Scope.Enter()) {
                            Array&lt;double> A = rand(10,20);
                            Array&lt;double> B = A * 30 + 100; 
                            Logical C = any(multiply(B,B.T)); 
                            Console.Out.Write(-B); 
                            Console.ReadKey(); 
                        }
                    }
                }
            }
            </code>
             </example>
             <seealso cref="T:ILNumerics.Logical"/>
             <seealso cref="T:ILNumerics.Cell"/>
             <seealso href="http://ilnumerics.net/$Arrays.html"/>
             <seealso href="http://ilnumerics.net/$GeneralRules.html"/>
             <seealso href="http://ilnumerics.net/$Subarray0.html"/>
        </member>
        <member name="M:ILNumerics.Array`1.#ctor">
            <summary>
            Use creation functions from ILNumerics.ILMath to create local arrays! Don't use new Array{T}()!
            </summary>
        </member>
        <member name="M:ILNumerics.Array`1.op_Implicit(`0)~ILNumerics.Array{`0}">
            <summary>
            Wraps single value into scalar array.
            </summary>
            <param name="a">System type.</param>
            <returns>New scalar array of type <see cref="T:ILNumerics.InArray`1"/>. 
            The only element has a value of <paramref name="a"/>.
            </returns>
            <remarks><para>The array returned will have a single element. However, the 
            number of dimensions depends on the current setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.
            By default (value: 2) the array returned will be of size [1 x 1].</para></remarks>
        </member>
        <member name="M:ILNumerics.Array`1.op_Implicit(System.Array)~ILNumerics.Array{`0}">
            <summary>
            Implicitly convert n-dimensional System.Array to ILNumerics array.
            </summary>
            <param name="A">System.Array of arbitrary size</param>
            <returns>If A is null: empty array. Otherwise a new ILNumerics array of the same size as A.</returns>
            <exception cref="T:System.InvalidCastException">If the type of the elements in A cannot get converted to <typeparamref name="T"/>.</exception>
            <exception cref="T:System.InvalidOperationException">If the type of the elements in A is not supported.</exception>
            <remarks><para>Elements of A will be copied to elements of the output array (shallow copy). The following element types are 
            supported for <paramref name="A"/> and <typeparamref name="T"/>: double, float, int, uint, long, ulong, short, ushort, sbyte, byte.</para> 
            <para>Alternatively, <paramref name="A"/> may consists out of scalar Arrays (or RetArray, InArray, OutArray) of one of the above element types.</para>
            <para>The resulting Array will reflect all dimensions of A. Due to the fact that .NET System.Arrays are stored in row major order and 
            ILNumerics stores array in column major (for compatibility with e.g. Matlab and Fortran) the resulting Array will have its dimensions reverted!
            For matrices this corresponds to a matrix transpose.</para>
            <para>System.Convert is used for the conversion of elements in A to destination elements. This includes widening and narrowing conversions. When, for example, 
            array elements of type double are provided and <typeparamref name="T"/> is Int32 the conversion will <b>round</b> the 
            source elements. See the examples below.</para></remarks>
            <example>
            <code lang="VB" title="VB Code Example">
            '' Elements of System.Value types:
            Dim A1 As Array(Of Double) = { 1, 2, 3 }  ' provide int elements
            Dim A2 As Array(Of Double) = { 1.0, 2.9, 3.4, 5.12 }  ' provide double elements
            Dim A As Double = 5
            Dim B As Double = 6
            Dim C As Double = 7
            
            Dim A3 As Array(Of Double) = { A, B, C } ' provide double variables
            
            Dim A4 As Array(Of Double) = { ILMath.cos(A), ILMath.tan(B) * C, C, 3 } ' provide mixed element types, including scalar Array  
            </code>
            <code lang="C#" title="C# Code Example">
            <![CDATA[
            Array<double> A1 = new[] { 1, ILMath.cos(2.0), 3, 4 };
            double B = -1, C = 10;
            Array<double> A2 = new[] { ILMath.cos(A1[1]), ILMath.tan(B) * C, C, 3 };
            // create from multidimensional System.Array 
            Array<int> A3 = new[,] { { 11, 12, 13 }, { 21, 22, 23 } };
            // narrowing conversion: from double to int (note the rounding rules!)
            Array<int> A4 = new[,] { { 11.9, 12.1, 13 }, { 21.5, 22.5, 23 } };
            //<Int32> [3,2]
            //    12         22 
            //    12         22 
            //    13         23 ]]>
            </code></example>
        </member>
        <member name="M:ILNumerics.Array`1.op_Implicit(ILNumerics.RetArray{`0})~ILNumerics.Array{`0}">
            <summary>
            "Persistence cast" make a steady array out of a temp array
            </summary>
            <param name="A">Temporary array</param>
            <returns>Steady Array, will survive multiple usages</returns>
            <remarks><para>This casting conversion changes temporary 
            arrays from temporary (volatile) state to local Arrays with persistent state. The inner storage is kept and used for 
            the new array. The new array can then be used (referenced, accessed, modified) during the rest of the function scope. 
            In contrast to that, <see cref="T:ILNumerics.RetArray`1"/> is disposed off immediately after first use.</para> 
            <para>New memoy is only used for the new array storage and data elements are only copied from <paramref name="A"/> when 
            the returned array is altered later on. </para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Array`1.op_Implicit(ILNumerics.InArray{`0})~ILNumerics.Array{`0}">
            <summary>
            Convert input array (immutable) to local array (mutable).
            </summary>
            <param name="A">Input array</param>
            <returns>Local mutable array with lifespan corresponding to the current scope.</returns>
            <remarks>The new array is detached from the source array <paramref name="A"/>. The new array can 
            get used multiple times in the function scope and get altered without modifying the source array <paramref name="A"/>.</remarks>
        </member>
        <member name="M:ILNumerics.Array`1.op_Implicit(ILNumerics.OutArray{`0})~ILNumerics.Array{`0}">
            <summary>
            Convert output array to a new local array (mutable).
            </summary>
            <param name="A">Array of OutArray type.</param>
            <returns>Local mutable array, detached from the source array <paramref name="A"/>, with lifespan corresponding to the current scope.</returns>
            <remarks>The new array is detached from this array. The new array can 
            get used multiple times in the function scope and get altered without altering the source array.</remarks>
        </member>
        <member name="M:ILNumerics.Array`1.Release">
            <summary>
            Indicate that this array is no longer be used. 
            </summary>
            <remarks>This decreases the reference counter of the array to the underlying storage and may release this storage eventually.
            <para>This function is marked as internal on purpose. Users should rely on <see cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/> blocks
            to manage the lifetime of arrays and do not attempt to release arrays manually. See the only exception for 
            <see cref="T:ILNumerics.RetArray`1"/>: <see cref="!:Dispose()"/>.</para></remarks>
        </member>
        <member name="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})">
             <summary>
             [Expert API - UNSAFE!] Acquire a writable pointer to the memory storing the first element of this array. 
             </summary>
             <returns>Pointer to the first element of this array.</returns>
             <remarks>This function returns a pointer to the first element stored in this array. Any 
             base offset configured for the array is taken into account. The pointer points to the 
             memory used by this array directly - not to a copy of this memory!
             <para>For empty arrays (<see cref="P:ILNumerics.BaseArray.IsEmpty"/> is <c>true</c>) the value of the pointer returned is undefined.</para>
             <para>This pointer is valid only as long as this array is not modified or released! Do not 
             attempt to use this pointer after the array has been released, ran out of scope, was reassigned or is modified!</para>
             <para>The order of elements in this array is determined by the size descriptor <see cref="T:ILNumerics.Size"/>. 
             Use the strides, dimension lengths and the size of the <typeparamref name="T"/> elements 
             <see cref="F:ILNumerics.Core.Arrays.ConcreteArray`6.SizeOfT"/>
             in order to compute the byte offset to individual elements relative to this pointer.</para>
             <para>The memory region addressed by the pointer returned exists on the <b>unmanaged</b> heap. 
             Hence, it does not need to be pinned and will not be moved by the GC. However, this memory 
             is subject of deterministic disposal, pooling and frequent reuse by other arrays. Do not use 
             the pointer returned after this array left the current function scope, was modified, reassigned or released!</para>
             <para>Since ILNumerics' memory management does transparently perform 'lazy copies on write' 
             calling this function may cause the underlying memory to be copied - transparently as well. Therefore, 
             do not call this function unless you really want to change the memory addressed. For reading 
             purposes it is cheaper to acquire a pointer via: 
             <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>.
             Latter option is available not only for <see cref="T:ILNumerics.Array`1"/> (as <see cref="!:GetHostPointerForWrite()"/>), 
             but on any non-volatile array.</para>
             <para>This functions works for element types <typeparamref name="T"/> of <see cref="T:System.ValueType"/> (structs in C#) 
             only. The bahavior for reference types ('class' elements) is undefined.</para>
             </remarks>
             <example><code><![CDATA[
             using (Scope.Enter()) {    
                    // create a local array: 
                    Array<double> A = new double[,] {
                        { 1, 2, 3 },
                        { 4, 5, 6 }
                    };
                    // or use any other way of creating the array: 
                    // Array<double> A = ILMath.zeros<double>(100,200); 
                    // or from another array: 
                    // Array<double> A = otherArray.C;  
            
                    // get a pointer to the first element
                    unsafe
                    {
                        double* pA = (double*)A.GetHostPointerForWrite();
                        // the pointer can be used for reading AND writing
                        pA[0] = -99;
                
                        // A
                        // [2 x 3] <double>
                        // -99   2   3
                        //   4   5   6
                
                        // Watch the storage order 'A.S.StorageOrder'! To find specific elements: 
                        double el12 = pA[A.S.GetSeqIndex(1, 2)];
                        // el12: 6
                        Assert.IsTrue(el12 == 6);
                        Assert.IsTrue(A.GetValue(0) == -99);
                    }
                    // work with A commonly...
             }
             // don't use the pointer outside this scope block!
             ]]></code></example>
             <exception cref="T:System.InvalidOperationException"> if called on a return type array or if the elements are not of a <see cref="T:System.ValueType"/>.</exception>
             <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetArrayForRead(ILNumerics.StorageOrders)"/>
             <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
             <seealso cref="P:ILNumerics.Size.BaseOffset"/>
        </member>
        <member name="T:ILNumerics.BaseArray`1">
            <summary>
            General base class for any array objects like <see cref="T:ILNumerics.Array`1"/> and similar arrays types. 
            </summary>
            <typeparam name="T">Element type</typeparam>
        </member>
        <member name="M:ILNumerics.BaseArray`1.op_Implicit(System.Array)~ILNumerics.BaseArray{`0}">
            <summary>
            Implicitly convert system array <paramref name="A"/> to a RetT array.
            </summary>
            <param name="A">System array of <see cref="T:System.ValueType"/> elements.</param>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.BaseArray`1.op_Implicit(`0)~ILNumerics.BaseArray{`0}">
            <summary>
            Implicitly convert system scalar <paramref name="A"/> to a scalar array.
            </summary>
            <param name="A">Scalar value as <see cref="T:System.ValueType"/>.</param>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.BaseArray`1.op_Implicit(ILNumerics.BaseArray{`0})~ILNumerics.RetCell">
            <summary>
            Convert arbitrary ILNumerics array to a scalar (ret)cell.
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar cell storing a clone of <paramref name="A"/> as the only element.</returns>
        </member>
        <member name="M:ILNumerics.BaseArray`1.op_Implicit(ILNumerics.BaseArray{`0})~ILNumerics.Cell">
            <summary>
            Convert arbitrary ILNumerics array to a scalar cell.
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar cell storing a clone of <paramref name="A"/> as the only element.</returns>
        </member>
        <member name="M:ILNumerics.BaseArray`1.op_Implicit(ILNumerics.BaseArray{`0})~ILNumerics.InCell">
            <summary>
            Convert arbitrary ILNumerics array to a scalar (in)cell.
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar cell storing a clone of <paramref name="A"/> as the only element.</returns>
        </member>
        <member name="M:ILNumerics.BaseArray`1.ToXML(System.Xml.XmlWriter)">
            <summary>
            Writes a XML string in XML file
            </summary>
            <param name="writer"></param>
        </member>
        <member name="T:ILNumerics.BaseArray">
            <summary>
            General base class of any ILNumerics array. This class is abstract. 
            </summary>
        </member>
        <member name="P:ILNumerics.BaseArray.IsColumnVector">
            <summary>
            Test if this array instance is a column vector
            </summary>
        </member>
        <member name="P:ILNumerics.BaseArray.IsComplex">
            <summary>
            Determines if this array is of complex inner type.
            </summary>
        </member>
        <member name="P:ILNumerics.BaseArray.IsDisposed">
            <summary>
            This flag indicates that an array is not to be used anymore. 
            </summary>
            <remarks><para>Since version 5 arrays implement multiple layers of reference 
            counting and share their resources more frequently. Disposing an array would 
            not dispose its storage while other arrays, sharing the storage still exist. 
            Instead, <see cref="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.Dispose"/> 
            decreases the reference counter <see cref="P:ILNumerics.BaseArray.ReferenceCount"/> of the storage only. The 
            storage becomes disposed only when all references have been detached.</para>
            <para>Therefore, the property <see cref="P:ILNumerics.BaseArray.IsDisposed"/> is not suitable to 
            determine the state of the storage. Even after <c>Dispose()</c> was called
            the property may return <c>false</c>.</para>
            <para>In order to determin whether a storage is still alive, inspect (count) 
            the number of live references to it: only if <see cref="P:ILNumerics.BaseArray.ReferenceCount"/> is 0 the 
            array can be considered 'disposed'.</para>
            <para>The only array types in version 5 which still implement <see cref="T:System.IDisposable"/> and 
            therefore have a <see cref="M:System.IDisposable.Dispose"/> method are 
            <see cref="T:ILNumerics.RetArray`1"/>, <see cref="T:ILNumerics.RetLogical"/> and <see cref="T:ILNumerics.RetCell"/>. 
            Call its Dispose method in the (rare) situation where the value returned from a function 
            is of one of these types and not used in any way further-on.</para></remarks>
            <example><code><![CDATA[
            Array<double> A = rand(10); 
            Array<long> I = 1; 
            sort(A, Indices: I).Dispose(); // <- cleaning up manually
            ]]></code>
            <para>Here, we only access the output parameter I of the sort function. The array returned 
            from sort(A, I) as the return value is not used, thus it is not released automatically. 
            In order to free its resources immediately, one can call Dispose() on the returned array. 
            Note, that no memory leak is produced without manually calling Dispose(). The array would 
            be cleaned up by the GC instead. For best performance, however, it is recommended to call 
            Dispose() here.</para>
            </example>
            <seealso cref="T:ILNumerics.Core.Arrays.ConcreteRetArray`6"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.Dispose"/>
            <seealso cref="M:ILNumerics.BaseArray.Release"/>
        </member>
        <member name="P:ILNumerics.BaseArray.IsEmpty">
            <summary>
            Test if this instance is an empty array (number of elements stored eqals 0).
            </summary>
        </member>
        <member name="P:ILNumerics.BaseArray.IsMatrix">
            <summary>
            Test if this instance is a matrix.
            </summary>
            <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must be at most 2. This attribute is readonly.
            <para>Keep in mind that all Arrays have at least 2 dimensions. Therefore, vectors and 
            scalar arrays are considered a matrix of size [n,1] / [1,n] or [1,1].</para></remarks>
        </member>
        <member name="P:ILNumerics.BaseArray.IsNumeric">
            <summary>
            Determine if this array is of numeric inner type.
            </summary>
        </member>
        <member name="P:ILNumerics.BaseArray.IsRowVector">
            <summary>
            Test if this array instance is a row vector.
            </summary>
        </member>
        <member name="P:ILNumerics.BaseArray.IsScalar">
            <summary>
            Test if this instance is a scalar.
            </summary>
            <remarks>This attribute is readonly. It returns: Size.NumberOfElements == 1.</remarks>
        </member>
        <member name="M:ILNumerics.BaseArray.IsOfType``1">
            <summary>
            Tests if this array stores elements of type <typeparamref name="ElementType"/>. 
            </summary>
            <typeparam name="ElementType">Type to test against the actual element type of this array.</typeparam>
            <returns>True if the elements of this array are of type <typeparamref name="ElementType"/>. 
            False otherwise.</returns>
            <remarks><para>Regular dense arrays can be tested for a specific type by providing the assumed 
            element type as generic type parameter <typeparamref name="ElementType"/>.</para>
            <para>To test if an array is a logical array, provide <see cref="T:System.Boolean"/> as 
            <typeparamref name="ElementType"/>.</para>
            <para>In order to test for cell types an <typeparamref name="ElementType"/> of <see cref="T:ILNumerics.BaseArray"/>
            is to be provided.</para></remarks>
        </member>
        <member name="P:ILNumerics.BaseArray.IsVector">
            <summary>
            Test if this array is a vector.
            </summary>
            <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind that all Arrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.BaseArray.Length">
            <summary>
            Length of the longest dimension of this instance
            </summary>
            <remarks>This property is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.BaseArray.S">
            <summary>
            Size descriptor determining the number, lengths and strides of the dimensions of this array. Alias to <see cref="P:ILNumerics.BaseArray.Size"/>.
            </summary>
        </member>
        <member name="P:ILNumerics.BaseArray.Size">
            <summary>
            Size descriptor determining the number, lengths and strides of the dimensions of this array.
            </summary>
        </member>
        <member name="M:ILNumerics.BaseArray.Equals(System.Object)">
            <summary>
            Compare elements and shape of this array with another array.
            </summary>
            <param name="A">Other array</param>
            <returns>true if shape and element values of both arrays match, false otherwise</returns>
            <remarks><para>'Equals' accepts two vectors even if the orientations do not match. Therefore, a row vector 
            with the same element values than another column vector of the same lengths are considered to be equal to each other.</para></remarks>
        </member>
        <member name="M:ILNumerics.BaseArray.GetElementType">
            <summary>
            Gets the System.Type of the elements stored in this array.
            </summary>
            <returns>Sytem.Type of the generic argument of concreate subclass instances</returns>
        </member>
        <member name="M:ILNumerics.BaseArray.ShortInfo">
            <summary>
            Short textual summary of this instance, used for debug output
            </summary>
            <returns>String representation of type and size</returns>
            <remarks>The type of elements and the size of the array are displayed. If the array
            is scalar, its value is displayed next to the type.</remarks>
        </member>
        <member name="M:ILNumerics.BaseArray.ShortInfo(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Short textual summary of this instance, select individual info components.
            </summary>
            <returns>String representation of type, size, values, storage order as requested.</returns>
            <remarks>The type of elements and the size of the array are displayed. If the array
            is scalar, its value is displayed next to the type.</remarks>
        </member>
        <member name="M:ILNumerics.BaseArray.ToString(System.UInt32,System.UInt32,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Creates a textual representation of a derived array and allows to control display parameters.
            </summary>
            <param name="maxNumberElementsPerDimension">[Optional] Maximum number of elements displayed in each dimension. Default: 50. Use 0 to remove this limit.</param>
            <param name="maxNumberElements">[Optional] Overall maximum number of elements displayed. Default: 1000. Use 0 to remove this limit.</param>
            <param name="style">[Optional] Show the elements in row major or column major order. Default: <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (i.e.: currently selected ArrayStyle).</param>
            <param name="showType">[Optional] Add a header info with the element type. Default: true.</param>
            <param name="showSize">[Optional] Add a header info with the arrays size. Default: true.</param>
            <param name="columnWidth">[Optional] Controls the width of element columns (number of characters). Default: (auto, depends on type).</param>
            <returns>String with the content of this array converted according to the given parameters.</returns>
        </member>
        <member name="M:ILNumerics.BaseArray.ToStream(System.IO.Stream,System.String,ILNumerics.ArrayStreamSerializationFlags)">
            <summary>
            Write values of this instance to a stream. 
            </summary>
            <param name="outStream">Stream to write the values into.</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
            <param name="method">A constant out of <see cref="T:ILNumerics.ArrayStreamSerializationFlags"/>. Specifies the way 
            the values will be serialized.</param>
            <remarks><para>If method 'Formatted' is used, any occurences of NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style for the output.</para>
            <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as 
            the array name for writing. This array instance will be the only array in the mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream. Or use the classes in the 
            <see cref="N:ILNumerics.IO.HDF5"/> namespace to create a HDF5 format file (recommended).</para></remarks>
        </member>
        <member name="M:ILNumerics.BaseArray.Retain">
            <summary>
            Increase the internal reference counter for this array object. 
            </summary>
        </member>
        <member name="M:ILNumerics.BaseArray.Release">
            <summary>
            Decrease the internal reference counter for this array object. The array will be disposed once the reference counter reaches 0.
            </summary>
        </member>
        <member name="M:ILNumerics.BaseArray.Dispose">
            <summary>
            Disposes this array - no matter what. Derived types are free to release the memory to the OS or to the ILNumerics memory pool.
            </summary>
        </member>
        <member name="P:ILNumerics.BaseArray.ReferenceCount">
            <summary>
            Counts the number of arrays currently referencing the storage of this array. 
            </summary>
        </member>
        <member name="M:ILNumerics.BaseArray.EnterScope">
            <summary>
            Enter a scope and decide whether this array should recognize it. 
            </summary>
            <returns>true for Array and InArray, false for its counterparts (Out and Ret array).</returns>
            <remarks>THIS IS NOT USED IN VERSION 5 SCOPING. IT IS LEFT HERE FOR VERSION 6 (?) 
            WHERE WE HAVE COMPILER SUPPORT AND CAN (AGAIN) IMPLEMENT A MORE FINE GRAINED SCOPING.</remarks>
        </member>
        <member name="M:ILNumerics.BaseArray.LeaveScope">
            <summary>
            Leave a scope and decrease the corresponding scope counter for applicable array types. 
            </summary>
        </member>
        <member name="M:ILNumerics.BaseArray.op_Implicit(System.Double)~ILNumerics.BaseArray">
            <summary>
            Implicit cast from <see cref="T:System.Double"/> scalar to <see cref="T:ILNumerics.RetArray`1"/> of element type <see cref="T:System.Double"/>.
            </summary>
            <param name="a">Input scalar.</param>
            <returns>A RetArray of same element type as <paramref name="a"/> and size 1x1.</returns>
        </member>
        <member name="M:ILNumerics.BaseArray.op_Implicit(ILNumerics.complex)~ILNumerics.BaseArray">
            <summary>
            Implicit cast from scalar of typeof(A) to RetArray&lt;typeof(A)&gt;
            </summary>
            <param name="a">Input scalar</param>
            <returns>A RetArray of same type as <paramref name="a"/> ans size 1x1</returns>
        </member>
        <member name="M:ILNumerics.BaseArray.op_Implicit(ILNumerics.fcomplex)~ILNumerics.BaseArray">
            <summary>
            Implicit cast from scalar of typeof(A) to RetArray&lt;typeof(A)&gt;
            </summary>
            <param name="a">Input scalar</param>
            <returns>A RetArray of same type as <paramref name="a"/> ans size 1x1</returns>
        </member>
        <member name="M:ILNumerics.BaseArray.op_Implicit(System.String)~ILNumerics.BaseArray">
            <summary>
            Implicit cast from string to scalar RetArray&lt;string&gt;
            </summary>
            <param name="s">Input scalar</param>
            <returns>A RetArray of same type as <paramref name="s"/> and size 1x1</returns>
        </member>
        <member name="M:ILNumerics.BaseArray.op_Implicit(ILNumerics.Core.Misc.ILExpression)~ILNumerics.BaseArray">
            <summary>
            Wraps an ILNumerics expression (i.e.: simple operation with 'end' specifier) into a scalar array.
            </summary>
            <param name="s">Input expression</param>
            <returns>A RetArray of same type as <paramref name="s"/> and size 1x1 (array scalar in numpy ArrayStyle).</returns>
        </member>
        <member name="M:ILNumerics.BaseArray.ToXML(System.Xml.XmlWriter)">
            <summary>
            Writes a XML string in XML file
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:ILNumerics.BaseArray.GetItem(System.Int64)">
            <summary>
            Retrieve the value of the element addressed by the sequential index in <paramref name="i"/>.
            </summary>
            <param name="i">Sequential index (1 dim), taking the striding (<see cref="P:ILNumerics.BaseArray.Size"/>) of 
            this array into account.</param>
            <returns>Boxed copy of the element at position <paramref name="i"/> if the elements stored in this 
            array are structs. Otherwise a reference copy of the element at <paramref name="i"/> is returned.</returns>
            <remarks>This function provides a way to access element values of this untyped base array for 
            convenience reasons. It is needed in very rare cases only. Don't expect great performance 
            from using untyped functions like this! The recommended performant way is to use the strongly typed classes 
            (<see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.Cell"/>) and the corresponding typed 
            API functions only.</remarks>
            <seealso cref="T:ILNumerics.Array`1"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
        </member>
        <member name="M:ILNumerics.BaseArray.GetClonedStorage(System.Boolean)">
            <summary>
            Gets the storage object for this array. This method supports cell objects internally. 
            </summary>
            <param name="forceRelease">[Optional] Releases this base array if it is a return type array. Default: false. (Required for some places (SetValueSeq), potentially not the 'optimal' solution, though)</param>
            <returns>(untyped) detached clone of this base storage object for storing into cell elements.</returns>
        </member>
        <member name="T:ILNumerics.Cell">
            <summary>
            Cell array is a container for arrays.
            </summary>
        </member>
        <member name="M:ILNumerics.Cell.op_Implicit(ILNumerics.RetCell)~ILNumerics.Cell">
            <summary>
            "Persistence cast". Makes a local array out of a return type array. 
            </summary>
            <param name="A">Array returned from somewhere.</param>
            <returns>Local array, survives multiple usages in the current scope.</returns>
            <remarks><para>This casting conversion changes temporary 
            arrays from temporary (volatile) state to local arrays with persistent state. The inner storage is kept and used for 
            the new array. The new array can then be used (referenced, accessed, modified) during the rest of the function scope. 
            In contrast to that, <see cref="T:ILNumerics.RetArray`1"/> is disposed off immediately after first use.</para> 
            <para>Array conversions in ILNumerics do not require new memory. Elements are not copied unless multiple arrays reference 
            the same memory and one of them is about to be changed. Only then a copy of the memory is done and the change is performed 
            on the copy (lazy copy on write).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Cell.op_Implicit(ILNumerics.InCell)~ILNumerics.Cell">
            <summary>
            Convert input array (immutable) to local array (mutable).
            </summary>
            <param name="A">Input array.</param>
            <returns>Local array with lifespan corresponding to the current scope.</returns>
            <remarks>The new array is created from the source array <paramref name="A"/> and can 
            be used multiple times in the function scope and get altered without modifying the source <paramref name="A"/>.
            <para>Array conversions in ILNumerics do not require new memory. Elements are not copied unless multiple arrays reference 
            the same memory and one of them is about to be changed. Only then a copy of the memory is done and the change is performed 
            on the copy (lazy copy on write).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Cell.op_Implicit(ILNumerics.OutCell)~ILNumerics.Cell">
            <summary>
            Convert output array to a new local array (mutable).
            </summary>
            <param name="A">Array of OutArray type.</param>
            <returns>Local mutable array, detached from the source array <paramref name="A"/>, with lifespan corresponding to the current scope.</returns>
            <remarks>The new array is detached from this array. The new array can 
            get used multiple times in the function scope and get altered without altering the source array.</remarks>
        </member>
        <member name="M:ILNumerics.Cell.Dispose">
            <summary>
            Release this array after use. Cleans up on <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.Cell"/> and <see cref="T:ILNumerics.Logical"/> arrays which are not inside a <see cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/> block.
            </summary>
            <remarks><para>This method is used in rare situations where no artificial scope exists around the current function body. Examples of 
            such situations are short <see cref="T:ILNumerics.Array`1"/> snippets in anonymous- or lambda functions, entry methods, or intended manual memory management.</para>
            <para>During 'normal' use the user places an artificial scope (<see cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/>) around the function body. All <see cref="T:ILNumerics.Array`1"/>, 
            <see cref="T:ILNumerics.Cell"/>, and <see cref="T:ILNumerics.Logical"/> arrays created within the scope block are automatically tracked and released once the scope block is left.</para>
            <para>Calling this method manually on local arrays as <see cref="T:ILNumerics.Array`1"/> &amp; Co. can be profitible in situations where no such scope block exists. 
            Otherwise, the memory would be reclaimed at a later point in time by the GC. <see cref="M:ILNumerics.Cell.Dispose"/> releases the array immediately. If no other 
            arrays are sharing the same memory, it will be released to the memory pool for immediate recycling.</para>
            <para>Note: failing to call <see cref="M:ILNumerics.Cell.Dispose"/> in such situations does not create a memory leak! But the array is only reclaimed 
            by the garbage collector and its memory is only freed by the finalization thread during the next GC collection. While this 
            is considered regular use, disposing the array manually is recommended in situations where high performance execution or 
            low memory consumption is required and no 'common' memory management is possible for some reasons. </para>
            <para>Note further, that <see cref="M:ILNumerics.Cell.Dispose"/> is <b>not</b> required in 'common' array uses. I.e. when dealing with <see cref="T:ILNumerics.Array`1"/> 
            inside existing <see cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/> scope blocks or when a return value is utilized in some way (incl. assignment to <see cref="T:ILNumerics.Array`1"/>, 
            calling member functions on the return value or giving the return value to other functions as input parameter).</para></remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.Dispose"/>
        </member>
        <member name="T:ILNumerics.ExtensionMethods">
            <summary>
            This class implements extension methods on the main array classes.
            </summary>
            <summary>
            This class implements extension methods on the main array classes.
            </summary>
            <summary>
            This class implements extension methods on the main array classes.
            </summary>
            <summary>
            This class implements extension methods on the main array classes.
            </summary>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)">
            <summary>
            Create new array with the elements of this array and <paramref name="B"/>, concatenated along dimension <paramref name="dim"/>.
            </summary>
            <param name="A">This array. </param>
            <param name="B">The other array. </param>
            <param name="dim">Dimension index to align both storages along.</param>
            <returns>New array with elements of this array and elements of <paramref name="B"/>.</returns>
            <remarks><para>The size of both arrays must match. This means that all but the dimension #<paramref name="dim"/>
            must have the same lengths.</para></remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="dim"/> is not a valid dimension index.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator``1(ILNumerics.BaseArray{System.Double},System.Func{System.Double,``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="converter">Converter function transforming the element type into the required output type <typeparamref name="Tout"/>.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator``1(ILNumerics.BaseArray{System.Boolean},System.Func{System.Boolean,``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="converter">Converter function transforming the element type into the required output type <typeparamref name="Tout"/>.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator``1(ILNumerics.BaseArray{System.SByte},System.Func{System.SByte,``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="converter">Converter function transforming the element type into the required output type <typeparamref name="Tout"/>.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator``1(ILNumerics.BaseArray{System.Byte},System.Func{System.Byte,``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="converter">Converter function transforming the element type into the required output type <typeparamref name="Tout"/>.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator``1(ILNumerics.BaseArray{System.Int16},System.Func{System.Int16,``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="converter">Converter function transforming the element type into the required output type <typeparamref name="Tout"/>.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator``1(ILNumerics.BaseArray{System.UInt16},System.Func{System.UInt16,``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="converter">Converter function transforming the element type into the required output type <typeparamref name="Tout"/>.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator``1(ILNumerics.BaseArray{System.Int32},System.Func{System.Int32,``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="converter">Converter function transforming the element type into the required output type <typeparamref name="Tout"/>.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator``1(ILNumerics.BaseArray{System.UInt32},System.Func{System.UInt32,``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="converter">Converter function transforming the element type into the required output type <typeparamref name="Tout"/>.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator``1(ILNumerics.BaseArray{System.Int64},System.Func{System.Int64,``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="converter">Converter function transforming the element type into the required output type <typeparamref name="Tout"/>.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator``1(ILNumerics.BaseArray{System.UInt64},System.Func{System.UInt64,``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="converter">Converter function transforming the element type into the required output type <typeparamref name="Tout"/>.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator``1(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Func{ILNumerics.fcomplex,``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="converter">Converter function transforming the element type into the required output type <typeparamref name="Tout"/>.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator``1(ILNumerics.BaseArray{ILNumerics.complex},System.Func{ILNumerics.complex,``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="converter">Converter function transforming the element type into the required output type <typeparamref name="Tout"/>.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator``1(ILNumerics.BaseArray{System.Single},System.Func{System.Single,``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="converter">Converter function transforming the element type into the required output type <typeparamref name="Tout"/>.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.BaseArray{System.Double},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.BaseArray{System.SByte},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.BaseArray{System.Byte},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.BaseArray{System.Int16},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.BaseArray{System.UInt16},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.BaseArray{System.Int32},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.BaseArray{System.UInt32},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.BaseArray{System.UInt64},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.BaseArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.BaseArray{ILNumerics.complex},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.BaseArray{System.Single},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.BaseArray{System.Boolean},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator``1(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over generic type elements for use in foreach loops. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
            <typeparam name="T">Element type.</typeparam>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IndexIterator(ILNumerics.BaseArray{System.Double},System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean)">
            <summary>
            [Internal] Efficient iterator over the array for use in subarray evaluations. 
            </summary>
            <param name="lastDimensionIdx">Index of the last element in the dimension when the iterator is to be used in subarray operations.</param>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <param name="checkLimits">[Optional] Checks limits and throws an IOOR exception. Default: true (do perform checks).</param>
            <param name="slim">[Optional] True: do not maintain features required for extended subarray-ing. Saves the determination
            of out-of-range indices, NaN checks etc. The object returned will not provide all <see cref="T:ILNumerics.IIndexIterator"/> data! Default: false.</param>
            <returns>Efficient, self destructing iterator instance, iterating over all elements of this array.</returns>
            <remarks><paramref name="slim"/> is used to enable the iterator for scenarios where error checking is performed outside of the 
            iterator and focus is on speedy creation of the iterator. In subarray operations this is disabled and the more 'safe' variant 
            is used. When enabled (true), no OOR checks are performed and <paramref name="checkLimits"/> is ignored.</remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IndexIterator(ILNumerics.BaseArray{System.SByte},System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean)">
            <summary>
            [Internal] Efficient iterator over the array for use in subarray evaluations. 
            </summary>
            <param name="lastDimensionIdx">Index of the last element in the dimension when the iterator is to be used in subarray operations.</param>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <param name="checkLimits">[Optional] Checks limits and throws an IOOR exception. Default: true (do perform checks).</param>
            <param name="slim">[Optional] True: do not maintain features required for extended subarray-ing. Saves the determination
            of out-of-range indices, NaN checks etc. The object returned will not provide all <see cref="T:ILNumerics.IIndexIterator"/> data! Default: false.</param>
            <returns>Efficient, self destructing iterator instance, iterating over all elements of this array.</returns>
            <remarks><paramref name="slim"/> is used to enable the iterator for scenarios where error checking is performed outside of the 
            iterator and focus is on speedy creation of the iterator. In subarray operations this is disabled and the more 'safe' variant 
            is used. When enabled (true), no OOR checks are performed and <paramref name="checkLimits"/> is ignored.</remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IndexIterator(ILNumerics.BaseArray{System.Byte},System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean)">
            <summary>
            [Internal] Efficient iterator over the array for use in subarray evaluations. 
            </summary>
            <param name="lastDimensionIdx">Index of the last element in the dimension when the iterator is to be used in subarray operations.</param>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <param name="checkLimits">[Optional] Checks limits and throws an IOOR exception. Default: true (do perform checks).</param>
            <param name="slim">[Optional] True: do not maintain features required for extended subarray-ing. Saves the determination
            of out-of-range indices, NaN checks etc. The object returned will not provide all <see cref="T:ILNumerics.IIndexIterator"/> data! Default: false.</param>
            <returns>Efficient, self destructing iterator instance, iterating over all elements of this array.</returns>
            <remarks><paramref name="slim"/> is used to enable the iterator for scenarios where error checking is performed outside of the 
            iterator and focus is on speedy creation of the iterator. In subarray operations this is disabled and the more 'safe' variant 
            is used. When enabled (true), no OOR checks are performed and <paramref name="checkLimits"/> is ignored.</remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IndexIterator(ILNumerics.BaseArray{System.Int16},System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean)">
            <summary>
            [Internal] Efficient iterator over the array for use in subarray evaluations. 
            </summary>
            <param name="lastDimensionIdx">Index of the last element in the dimension when the iterator is to be used in subarray operations.</param>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <param name="checkLimits">[Optional] Checks limits and throws an IOOR exception. Default: true (do perform checks).</param>
            <param name="slim">[Optional] True: do not maintain features required for extended subarray-ing. Saves the determination
            of out-of-range indices, NaN checks etc. The object returned will not provide all <see cref="T:ILNumerics.IIndexIterator"/> data! Default: false.</param>
            <returns>Efficient, self destructing iterator instance, iterating over all elements of this array.</returns>
            <remarks><paramref name="slim"/> is used to enable the iterator for scenarios where error checking is performed outside of the 
            iterator and focus is on speedy creation of the iterator. In subarray operations this is disabled and the more 'safe' variant 
            is used. When enabled (true), no OOR checks are performed and <paramref name="checkLimits"/> is ignored.</remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IndexIterator(ILNumerics.BaseArray{System.UInt16},System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean)">
            <summary>
            [Internal] Efficient iterator over the array for use in subarray evaluations. 
            </summary>
            <param name="lastDimensionIdx">Index of the last element in the dimension when the iterator is to be used in subarray operations.</param>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <param name="checkLimits">[Optional] Checks limits and throws an IOOR exception. Default: true (do perform checks).</param>
            <param name="slim">[Optional] True: do not maintain features required for extended subarray-ing. Saves the determination
            of out-of-range indices, NaN checks etc. The object returned will not provide all <see cref="T:ILNumerics.IIndexIterator"/> data! Default: false.</param>
            <returns>Efficient, self destructing iterator instance, iterating over all elements of this array.</returns>
            <remarks><paramref name="slim"/> is used to enable the iterator for scenarios where error checking is performed outside of the 
            iterator and focus is on speedy creation of the iterator. In subarray operations this is disabled and the more 'safe' variant 
            is used. When enabled (true), no OOR checks are performed and <paramref name="checkLimits"/> is ignored.</remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IndexIterator(ILNumerics.BaseArray{System.Int32},System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean)">
            <summary>
            [Internal] Efficient iterator over the array for use in subarray evaluations. 
            </summary>
            <param name="lastDimensionIdx">Index of the last element in the dimension when the iterator is to be used in subarray operations.</param>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <param name="checkLimits">[Optional] Checks limits and throws an IOOR exception. Default: true (do perform checks).</param>
            <param name="slim">[Optional] True: do not maintain features required for extended subarray-ing. Saves the determination
            of out-of-range indices, NaN checks etc. The object returned will not provide all <see cref="T:ILNumerics.IIndexIterator"/> data! Default: false.</param>
            <returns>Efficient, self destructing iterator instance, iterating over all elements of this array.</returns>
            <remarks><paramref name="slim"/> is used to enable the iterator for scenarios where error checking is performed outside of the 
            iterator and focus is on speedy creation of the iterator. In subarray operations this is disabled and the more 'safe' variant 
            is used. When enabled (true), no OOR checks are performed and <paramref name="checkLimits"/> is ignored.</remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IndexIterator(ILNumerics.BaseArray{System.UInt32},System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean)">
            <summary>
            [Internal] Efficient iterator over the array for use in subarray evaluations. 
            </summary>
            <param name="lastDimensionIdx">Index of the last element in the dimension when the iterator is to be used in subarray operations.</param>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <param name="checkLimits">[Optional] Checks limits and throws an IOOR exception. Default: true (do perform checks).</param>
            <param name="slim">[Optional] True: do not maintain features required for extended subarray-ing. Saves the determination
            of out-of-range indices, NaN checks etc. The object returned will not provide all <see cref="T:ILNumerics.IIndexIterator"/> data! Default: false.</param>
            <returns>Efficient, self destructing iterator instance, iterating over all elements of this array.</returns>
            <remarks><paramref name="slim"/> is used to enable the iterator for scenarios where error checking is performed outside of the 
            iterator and focus is on speedy creation of the iterator. In subarray operations this is disabled and the more 'safe' variant 
            is used. When enabled (true), no OOR checks are performed and <paramref name="checkLimits"/> is ignored.</remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IndexIterator(ILNumerics.BaseArray{System.Int64},System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean)">
            <summary>
            [Internal] Efficient iterator over the array for use in subarray evaluations. 
            </summary>
            <param name="lastDimensionIdx">Index of the last element in the dimension when the iterator is to be used in subarray operations.</param>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <param name="checkLimits">[Optional] Checks limits and throws an IOOR exception. Default: true (do perform checks).</param>
            <param name="slim">[Optional] True: do not maintain features required for extended subarray-ing. Saves the determination
            of out-of-range indices, NaN checks etc. The object returned will not provide all <see cref="T:ILNumerics.IIndexIterator"/> data! Default: false.</param>
            <returns>Efficient, self destructing iterator instance, iterating over all elements of this array.</returns>
            <remarks><paramref name="slim"/> is used to enable the iterator for scenarios where error checking is performed outside of the 
            iterator and focus is on speedy creation of the iterator. In subarray operations this is disabled and the more 'safe' variant 
            is used. When enabled (true), no OOR checks are performed and <paramref name="checkLimits"/> is ignored.</remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IndexIterator(ILNumerics.BaseArray{System.UInt64},System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean)">
            <summary>
            [Internal] Efficient iterator over the array for use in subarray evaluations. 
            </summary>
            <param name="lastDimensionIdx">Index of the last element in the dimension when the iterator is to be used in subarray operations.</param>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <param name="checkLimits">[Optional] Checks limits and throws an IOOR exception. Default: true (do perform checks).</param>
            <param name="slim">[Optional] True: do not maintain features required for extended subarray-ing. Saves the determination
            of out-of-range indices, NaN checks etc. The object returned will not provide all <see cref="T:ILNumerics.IIndexIterator"/> data! Default: false.</param>
            <returns>Efficient, self destructing iterator instance, iterating over all elements of this array.</returns>
            <remarks><paramref name="slim"/> is used to enable the iterator for scenarios where error checking is performed outside of the 
            iterator and focus is on speedy creation of the iterator. In subarray operations this is disabled and the more 'safe' variant 
            is used. When enabled (true), no OOR checks are performed and <paramref name="checkLimits"/> is ignored.</remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IndexIterator(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean)">
            <summary>
            [Internal] Efficient iterator over the array for use in subarray evaluations. 
            </summary>
            <param name="lastDimensionIdx">Index of the last element in the dimension when the iterator is to be used in subarray operations.</param>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <param name="checkLimits">[Optional] Checks limits and throws an IOOR exception. Default: true (do perform checks).</param>
            <param name="slim">[Optional] True: do not maintain features required for extended subarray-ing. Saves the determination
            of out-of-range indices, NaN checks etc. The object returned will not provide all <see cref="T:ILNumerics.IIndexIterator"/> data! Default: false.</param>
            <returns>Efficient, self destructing iterator instance, iterating over all elements of this array.</returns>
            <remarks><paramref name="slim"/> is used to enable the iterator for scenarios where error checking is performed outside of the 
            iterator and focus is on speedy creation of the iterator. In subarray operations this is disabled and the more 'safe' variant 
            is used. When enabled (true), no OOR checks are performed and <paramref name="checkLimits"/> is ignored.</remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IndexIterator(ILNumerics.BaseArray{ILNumerics.complex},System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean)">
            <summary>
            [Internal] Efficient iterator over the array for use in subarray evaluations. 
            </summary>
            <param name="lastDimensionIdx">Index of the last element in the dimension when the iterator is to be used in subarray operations.</param>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <param name="checkLimits">[Optional] Checks limits and throws an IOOR exception. Default: true (do perform checks).</param>
            <param name="slim">[Optional] True: do not maintain features required for extended subarray-ing. Saves the determination
            of out-of-range indices, NaN checks etc. The object returned will not provide all <see cref="T:ILNumerics.IIndexIterator"/> data! Default: false.</param>
            <returns>Efficient, self destructing iterator instance, iterating over all elements of this array.</returns>
            <remarks><paramref name="slim"/> is used to enable the iterator for scenarios where error checking is performed outside of the 
            iterator and focus is on speedy creation of the iterator. In subarray operations this is disabled and the more 'safe' variant 
            is used. When enabled (true), no OOR checks are performed and <paramref name="checkLimits"/> is ignored.</remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IndexIterator(ILNumerics.BaseArray{System.Single},System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean)">
            <summary>
            [Internal] Efficient iterator over the array for use in subarray evaluations. 
            </summary>
            <param name="lastDimensionIdx">Index of the last element in the dimension when the iterator is to be used in subarray operations.</param>
            <param name="A">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <param name="checkLimits">[Optional] Checks limits and throws an IOOR exception. Default: true (do perform checks).</param>
            <param name="slim">[Optional] True: do not maintain features required for extended subarray-ing. Saves the determination
            of out-of-range indices, NaN checks etc. The object returned will not provide all <see cref="T:ILNumerics.IIndexIterator"/> data! Default: false.</param>
            <returns>Efficient, self destructing iterator instance, iterating over all elements of this array.</returns>
            <remarks><paramref name="slim"/> is used to enable the iterator for scenarios where error checking is performed outside of the 
            iterator and focus is on speedy creation of the iterator. In subarray operations this is disabled and the more 'safe' variant 
            is used. When enabled (true), no OOR checks are performed and <paramref name="checkLimits"/> is ignored.</remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IndexIterator``1(ILNumerics.BaseArray{``0},System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over generic (but numeric!) type elements for use in indexing. 
            </summary>
            <param name="A">The array instance.</param>
            <param name="lastDimIdx">The value of the highest index addressable by this iterator. This is used to handle negative indices.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array and converting values to long indices.</returns>
            <typeparam name="T">Element type. Expected to be numeric.</typeparam>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IndexIterator(ILNumerics.BaseArray{System.Boolean},System.Int64,System.Boolean,System.Int64)">
            <summary>
            [Internal] Efficient iterator over a logical array for use in subarray evaluations. Column-major order iteration!
            </summary>
            <param name="lastDimensionIdx">Index of the last element in the dimension when the iterator is to be used in subarray operations.</param>
            <param name="A">The array instance.</param>
            <param name="knownMaxValue">[optional] If provided this value will be cached and transfered to requests for <see cref="M:ILNumerics.IIndexIterator.GetMaximum"/> later.</param>
            <param name="checkLimits">[Optional] Checks limits and throws an IOOR exception. Default: true (do perform checks).</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.UInt32[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},System.Int64[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.SByte},ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.UInt32[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},System.Int64[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Byte},ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.UInt32[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},System.Int64[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt16},ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.UInt32[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},System.Int64[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int16},ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},System.Int64[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.UInt32[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},System.Int64[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt64},ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.UInt32[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},System.Int64[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int64},ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.UInt32[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},System.Int64[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.UInt32},ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.UInt32[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},System.Int64[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Int32},ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.  <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.UInt32[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},System.Int64[])">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Single},ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.UInt32)">
            <summary>
            Retrieves the value of the element at the position as specified by <paramref name="d0"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)">
            <summary>
            Retrieves the value of the element at the position as specified by <paramref name="d0"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.UInt32,System.UInt32)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64,System.Int64)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.UInt32[])">
            <summary>
            Retrieve the value at the element addressed by indices stored in an index array.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64[])">
            <summary>
            Retrieve the value at the element addressed by indices stored in an index array. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The array instance.</param>
            <returns>The element value at the position as specified by <paramref name="indices"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray})">
            <summary>
            Retrieves a clone of the value of a scalar (0-dim) cell array as an array. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <returns>Copy/clone of the element value. Scalar arrays are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the only element of a 0-dim scalar cell array.</para> 
            <para>The type of the array returned corresponds to the type of the element stored. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray})"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            <para>Note, that the value addressed is not wrapped into a scalar cell before returning as would be the case for indexers on cells, 
            which always return cells. Thus the return value might be a cell or an ILNumerics array of any element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="A"/> is not a 0-dimensional (numpy) scalar.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)">
            <summary>
            Retrieves a clone of the value at the position <paramref name="d0"/> as an array.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond to the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage layouts both are likely to differ.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            <para>Note, that the value addressed is not wrapped into a scalar cell before returning as would be the case for indexers on cells, 
            which always return cells. Thus the return value might be a cell or an ILNumerics array of any element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)">
            <summary>
            Retrieves a clone of the value at the position specified by <paramref name="d0"/> and <paramref name="d1"/> as an array. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/> and <paramref name="d1"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves a clone of the value at the position specified by <paramref name="d0"/> ... <paramref name="d2"/> as an array. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element as given by <paramref name="d0"/>...<paramref name="d2"/>. If while 
            searching for the element a cell is found the function steps down into the cell and continues to retrieve the value from the 
            inner cell using subsequent trailing indices left over (deep indexing).</para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions of this inner most array element.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/>...<paramref name="d2"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves a clone of the value at the position specified by <paramref name="d0"/> ... <paramref name="d3"/> as an array. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element as given by <paramref name="d0"/>...<paramref name="d3"/>. If while 
            searching for the element a cell is found the function steps down into the cell and continues to retrieve the value from the 
            inner cell using subsequent trailing indices left over (deep indexing).</para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions of this inner most array element.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/>...<paramref name="d3"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/> as an array. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index #0.</param>
            <param name="d1">Index #1.</param>
            <param name="d2">Index #2.</param>
            <param name="d3">Index #3.</param>
            <param name="d4">Index #4 into the last dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element as given by <paramref name="d0"/>...<paramref name="d4"/>. If while 
            searching for the element a cell is found the function steps down into the cell and continues to retrieve the value from the 
            inner cell using subsequent trailing indices left over (deep indexing).</para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions of this inner most array element.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/>...<paramref name="d3"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/> as an array. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index #0.</param>
            <param name="d1">Index #1.</param>
            <param name="d2">Index #2.</param>
            <param name="d3">Index #3.</param>
            <param name="d4">Index #4.</param>
            <param name="d5">Index #5 into the last dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element as given by <paramref name="d0"/>...<paramref name="d5"/>. If while 
            searching for the element a cell is found the function steps down into the cell and continues to retrieve the value from the 
            inner cell using subsequent trailing indices left over (deep indexing).</para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions of this inner most array element.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/>...<paramref name="d5"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/> as as array. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1. </param>
            <param name="d2">Index into dimension #2.</param>
            <param name="d3">Index into dimension #3. </param>
            <param name="d4">Index into dimension #4. </param>
            <param name="d5">Index into dimension #5. </param>
            <param name="d6">Index into thge last dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element as given by <paramref name="d0"/>...<paramref name="d6"/>. If while 
            searching for the element a cell is found the function steps down into the cell and continues to retrieve the value from the 
            inner cell using subsequent trailing indices left over (deep indexing).</para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions of this inner most array element.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/>...<paramref name="d5"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the value of the element addressed by the index array <paramref name="indices"/> as an array. Supports deep indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The cell instance.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="indices"/> is null or have 0 or more than 7 elements.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray})">
            <summary>
            Retrieves a clone of the value of a scalar (0-dim) cell array as an array. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <returns>Copy/clone of the element value. Scalar values are not wrapped and returned as their natural type <typeparamref name="T"/>.</returns>
            <remarks><para>This functions retrieves the value of the only element of a 0-dim scalar cell array.</para> 
            <para>The type of the array returned corresponds to the type of the element stored. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray})"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            <para>Note, that the value addressed is not wrapped into a scalar cell before returning as would be the case for indexers on cells, 
            which always return cells. Thus the return value might be a cell or an ILNumerics array of any element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="A"/> is not a 0-dimensional (numpy) scalar.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)">
            <summary>
            Retrieves a clone of the value at the position <paramref name="d0"/>. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are not wrapped and returned as their natural type <typeparamref name="T"/>.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond to the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage layouts both are likely to differ.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            <para>Note, that the value addressed is not wrapped into a scalar cell before returning as would be the case for indexers on cells, 
            which always return cells. Thus the return value might be a cell or an ILNumerics array of any element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)">
            <summary>
            Retrieves a clone of the value at the position specified by <paramref name="d0"/> and <paramref name="d1"/> as an array. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/> and <paramref name="d1"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves a clone of the value at the position specified by <paramref name="d0"/> ... <paramref name="d2"/> as an array. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element as given by <paramref name="d0"/>...<paramref name="d2"/>. If while 
            searching for the element a cell is found the function steps down into the cell and continues to retrieve the value from the 
            inner cell using subsequent trailing indices left over (deep indexing).</para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions of this inner most array element.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/>...<paramref name="d2"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves a clone of the value at the position specified by <paramref name="d0"/> ... <paramref name="d3"/> as an array. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element as given by <paramref name="d0"/>...<paramref name="d3"/>. If while 
            searching for the element a cell is found the function steps down into the cell and continues to retrieve the value from the 
            inner cell using subsequent trailing indices left over (deep indexing).</para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions of this inner most array element.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/>...<paramref name="d3"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/> as an array. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index #0.</param>
            <param name="d1">Index #1.</param>
            <param name="d2">Index #2.</param>
            <param name="d3">Index #3.</param>
            <param name="d4">Index #4 into the last dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element as given by <paramref name="d0"/>...<paramref name="d4"/>. If while 
            searching for the element a cell is found the function steps down into the cell and continues to retrieve the value from the 
            inner cell using subsequent trailing indices left over (deep indexing).</para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions of this inner most array element.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/>...<paramref name="d3"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/> as an array. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index #0.</param>
            <param name="d1">Index #1.</param>
            <param name="d2">Index #2.</param>
            <param name="d3">Index #3.</param>
            <param name="d4">Index #4.</param>
            <param name="d5">Index #5 into the last dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element as given by <paramref name="d0"/>...<paramref name="d5"/>. If while 
            searching for the element a cell is found the function steps down into the cell and continues to retrieve the value from the 
            inner cell using subsequent trailing indices left over (deep indexing).</para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions of this inner most array element.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/>...<paramref name="d5"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/> as as array. Supports deep indexing.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1. </param>
            <param name="d2">Index into dimension #2.</param>
            <param name="d3">Index into dimension #3. </param>
            <param name="d4">Index into dimension #4. </param>
            <param name="d5">Index into dimension #5. </param>
            <param name="d6">Index into thge last dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element as given by <paramref name="d0"/>...<paramref name="d6"/>. If while 
            searching for the element a cell is found the function steps down into the cell and continues to retrieve the value from the 
            inner cell using subsequent trailing indices left over (deep indexing).</para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions of this inner most array element.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/>...<paramref name="d5"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the value of the element addressed by the index array <paramref name="indices"/>. Supports deep indexing.
            </summary>
            <param name="indices">Index array addressing the element to be retrieved.</param>
            <param name="A">The cell instance.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="indices"/> is null or have 0 or more than 7 elements.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{``0},System.Int64)">
            <summary>
            Retrieves the value of the element at the position as specified by <paramref name="d0"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond with the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to differ.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieve the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/>. <see cref="T:System.Int64"/> indexing.
            </summary>
            <param name="A">The array instance.</param>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64)">
            <summary>
            Sets the value of the element addressed by <paramref name="d0"/>. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="d0">Index into dimension #0.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional index <paramref name="d0"/>.</para>
            <para><paramref name="d0"/> is considered a <b>sequential</b> index into its own and into subsequent, merged 
            dimensions (Matlab/ILNumericsV4 indexing style).</para>
            <para>The function supports automatic expansion when addressing elements outside of the 
            current dimension range. However, removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <exception cref="T:System.InvalidOperationException">if this array is currently in use by other arrays and 
            locked against modifications. This should not happen during 'regular' use and may indicate a bad design.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)">
            <summary>
            Sets the value of the element addressed by <paramref name="d0"/>...<paramref name="d1"/>. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional indices <paramref name="d0"/>...<paramref name="d1"/>.</para>
            <para><paramref name="d1"/> is considered a <b>sequential</b> index into its own and into subsequent, merged 
            dimensions (Matlab/ILNumericsV4 indexing style).</para>
            <para>The function supports automatic expansion when addressing elements outside of the 
            current dimension range. However, removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <exception cref="T:System.InvalidOperationException">if this array is currently in use by other arrays and 
            locked against modifications. This should not happen during 'regular' use and may indicate a bad design.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64,System.Int64)">
            <summary>
            Sets the value of the element addressed by <paramref name="d0"/>...<paramref name="d2"/>. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional indices <paramref name="d0"/>...<paramref name="d2"/>.</para>
            <para><paramref name="d2"/> is considered a <b>sequential</b> index into its own and into subsequent, merged 
            dimensions (Matlab/ILNumericsV4 indexing style).</para>
            <para>The function supports automatic expansion when addressing elements outside of the 
            current dimension range. However, removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <exception cref="T:System.InvalidOperationException">if this array is currently in use by other arrays and 
            locked against modifications. This should not happen during 'regular' use and may indicate a bad design.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Sets the value of the element addressed by <paramref name="d0"/>...<paramref name="d3"/>. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <param name="d3">Index into dimension #3.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional indices <paramref name="d0"/>...<paramref name="d3"/>.</para>
            <para><paramref name="d3"/> is considered a <b>sequential</b> index into its own and into subsequent, merged 
            dimensions (Matlab/ILNumericsV4 indexing style).</para>
            <para>The function supports automatic expansion when addressing elements outside of the 
            current dimension range. However, removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <exception cref="T:System.InvalidOperationException">if this array is currently in use by other arrays and 
            locked against modifications. This should not happen during 'regular' use and may indicate a bad design.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Sets the value of the element addressed by <paramref name="d0"/>...<paramref name="d4"/>. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <param name="d3">Index into dimension #3.</param>
            <param name="d4">Index into dimension #4.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional indices <paramref name="d0"/>...<paramref name="d4"/>.</para>
            <para><paramref name="d4"/> is considered a <b>sequential</b> index into its own and into subsequent, merged 
            dimensions (Matlab/ILNumericsV4 indexing style).</para>
            <para>The function supports automatic expansion when addressing elements outside of the 
            current dimension range. However, removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <exception cref="T:System.InvalidOperationException">if this array is currently in use by other arrays and 
            locked against modifications. This should not happen during 'regular' use and may indicate a bad design.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Sets the value of the element addressed by <paramref name="d0"/>...<paramref name="d5"/>. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <param name="d3">Index into dimension #3.</param>
            <param name="d4">Index into dimension #4.</param>
            <param name="d5">Index into dimension #5.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional indices <paramref name="d0"/>...<paramref name="d5"/>.</para>
            <para><paramref name="d5"/> is considered a <b>sequential</b> index into its own and into subsequent, merged 
            dimensions (Matlab/ILNumericsV4 indexing style).</para>
            <para>The function supports automatic expansion when addressing elements outside of the 
            current dimension range. However, removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <exception cref="T:System.InvalidOperationException">if this array is currently in use by other arrays and 
            locked against modifications. This should not happen during 'regular' use and may indicate a bad design.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Sets the value of the element addressed by <paramref name="d0"/>...<paramref name="d6"/>. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <param name="d3">Index into dimension #3.</param>
            <param name="d4">Index into dimension #4.</param>
            <param name="d5">Index into dimension #5.</param>
            <param name="d6">Index into dimension #6.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional indices <paramref name="d0"/>...<paramref name="d6"/>.</para>
            <para><paramref name="d6"/> is considered a <b>sequential</b> index into its own and into subsequent, merged 
            dimensions (Matlab/ILNumericsV4 indexing style).</para>
            <para>The function supports automatic expansion when addressing elements outside of the 
            current dimension range. However, removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <exception cref="T:System.InvalidOperationException">if this array is currently in use by other arrays and 
            locked against modifications. This should not happen during 'regular' use and may indicate a bad design.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue(ILNumerics.Core.Arrays.Mutable{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.BaseArray)">
            <summary>
            Sets the value of the scalar (0-dimensional) cell array <paramref name="A"/>. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable, scalar (0-dim) array.</param>
            <remarks>
            <para>This function replaces the only value of the 0-dimensional scalar array <paramref name="A"/>. It 
            supports the deep-indexing feature on cell arrays. Regular arrays can be addressed by an index value 0 for 
            virtual dimensions. In contrast to that indexing with integer values into cell arrays (deep indexing) 
            requires exactly one index for each (non-virtual) dimension of every array addressed. Therefore, a 0-index 
            overload exists for indexing into scalar (0-dim) cell arrays.</para>
            <para>The function supports automatic expansion when addressing elements outside of the 
            current dimension range. However, removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <exception cref="T:System.InvalidOperationException">if this array is currently in use by other arrays and 
            locked against modifications. This should not happen during 'regular' use and may indicate a bad design.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/cell-arrays.html">ILNumerics cell arrays tutorial online.</seealso>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation.</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue(ILNumerics.Core.Arrays.Mutable{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.BaseArray,System.Int64)">
            <summary>
            Sets the value of the element addressed by <paramref name="d0"/>. Supports deep indexing into cell elements.
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable cell array.</param>
            <param name="d0">Index into dimension #0.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional index <paramref name="d0"/>.</para>
            <para><paramref name="d0"/> is considered a <b>sequential</b> index into its own and into subsequent, merged 
            dimensions (Matlab/ILNumericsV4 indexing style).</para>
            <para>Deep indexing: the element to be replaced is located by matching the full set of given indices with 
            the existing dimensions of the cell, starting with index <paramref name="d0"/>. If the indices corresponding 
            to the number of dimensions of this cell point to an ILNumerics array subsequent indices are used as indices into that array. On the 
            other hand, if the element found is a cell, indexing is continued recursively at that cell element.</para>
            <para>The function supports automatic expansion for existing dimensions of regular (non-cell) arrays. When 
            the given indices address a non-existing element of a non-cell array the array currently stored in the cell 
            is expanded in a way that the new value can be stored at the provided location of the array.</para>
            <para>Removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/cell-arrays.html">ILNumerics cell arrays tutorial online.</seealso>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue(ILNumerics.Core.Arrays.Mutable{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.BaseArray,System.Int64,System.Int64)">
            <summary>
            Sets the value of the element addressed by <paramref name="d0"/>...<paramref name="d1"/>. Supports deep indexing into cell elements. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional indices <paramref name="d0"/> and <paramref name="d1"/>.</para>
            <para><paramref name="d1"/> is considered a <b>sequential</b> index into its own and into subsequent, merged 
            dimensions (Matlab/ILNumericsV4 indexing style).</para>
            <para>Deep indexing: the element to be replaced is located by matching the full set of given indices with 
            the existing dimensions of the cell, starting with index <paramref name="d0"/>. If the indices corresponding 
            to the number of dimensions of this cell point to an ILNumerics array subsequent indices are used as indices into that array. On the 
            other hand, if the element found is a cell, indexing is continued recursively at that cell element.</para>
            <para>The function supports automatic expansion for existing dimensions of regular (non-cell) arrays. When 
            the given indices address a non-existing element of a non-cell array the array currently stored in the cell 
            is expanded in a way that the new value can be stored at the provided location of the array.</para>
            <para>Removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/cell-arrays.html">ILNumerics cell arrays tutorial online.</seealso>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue(ILNumerics.Core.Arrays.Mutable{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.BaseArray,System.Int64,System.Int64,System.Int64)">
            <summary>
            Sets the value of the element addressed by <paramref name="d0"/>...<paramref name="d2"/>. Supports deep indexing into cell elements. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional indices <paramref name="d0"/> ... <paramref name="d2"/>.</para>
            <para><paramref name="d2"/> is considered a <b>sequential</b> index into its own and into subsequent, merged 
            dimensions (Matlab/ILNumericsV4 indexing style).</para>
            <para>Deep indexing: the element to be replaced is located by matching the full set of given indices with 
            the existing dimensions of the cell, starting with index <paramref name="d0"/>. If the indices corresponding 
            to the number of dimensions of this cell point to an ILNumerics array subsequent indices are used as indices into that array. On the 
            other hand, if the element found is a cell, indexing is continued recursively at that cell element.</para>
            <para>The function supports automatic expansion for existing dimensions of regular (non-cell) arrays. When 
            the given indices address a non-existing element of a non-cell array the array currently stored in the cell 
            is expanded in a way that the new value can be stored at the provided location of the array.</para>
            <para>Removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/cell-arrays.html">ILNumerics cell arrays tutorial online.</seealso>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue(ILNumerics.Core.Arrays.Mutable{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.BaseArray,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Sets the value of the element addressed by <paramref name="d0"/>...<paramref name="d3"/>. Supports deep indexing into cell elements. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <param name="d3">Index into dimension #3.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional indices <paramref name="d0"/> ... <paramref name="d3"/>.</para>
            <para><paramref name="d3"/> is considered a <b>sequential</b> index into its own and into subsequent, merged 
            dimensions (Matlab/ILNumericsV4 indexing style).</para>
            <para>Deep indexing: the element to be replaced is located by matching the full set of given indices with 
            the existing dimensions of the cell, starting with index <paramref name="d0"/>. If the indices corresponding 
            to the number of dimensions of this cell point to an ILNumerics array subsequent indices are used as indices into that array. On the 
            other hand, if the element found is a cell, indexing is continued recursively at that cell element.</para>
            <para>The function supports automatic expansion for existing dimensions of regular (non-cell) arrays. When 
            the given indices address a non-existing element of a non-cell array the array currently stored in the cell 
            is expanded in a way that the new value can be stored at the provided location of the array.</para>
            <para>Removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/cell-arrays.html">ILNumerics cell arrays tutorial online.</seealso>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue(ILNumerics.Core.Arrays.Mutable{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.BaseArray,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Sets the value of the element addressed by <paramref name="d0"/>...<paramref name="d4"/>. Supports deep indexing into cell elements. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <param name="d3">Index into dimension #3.</param>
            <param name="d4">Index into dimension #4.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional indices <paramref name="d0"/> ... <paramref name="d4"/>.</para>
            <para><paramref name="d4"/> is considered a <b>sequential</b> index into its own and into subsequent, merged 
            dimensions (Matlab/ILNumericsV4 indexing style).</para>
            <para>Deep indexing: the element to be replaced is located by matching the full set of given indices with 
            the existing dimensions of the cell, starting with index <paramref name="d0"/>. If the indices corresponding 
            to the number of dimensions of this cell point to an ILNumerics array subsequent indices are used as indices into that array. On the 
            other hand, if the element found is a cell, indexing is continued recursively at that cell element.</para>
            <para>The function supports automatic expansion for existing dimensions of regular (non-cell) arrays. When 
            the given indices address a non-existing element of a non-cell array the array currently stored in the cell 
            is expanded in a way that the new value can be stored at the provided location of the array.</para>
            <para>Removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/cell-arrays.html">ILNumerics cell arrays tutorial online.</seealso>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue(ILNumerics.Core.Arrays.Mutable{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.BaseArray,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Sets the value of the element addressed by <paramref name="d0"/>...<paramref name="d5"/>. Supports deep indexing into cell elements. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <param name="d3">Index into dimension #3.</param>
            <param name="d4">Index into dimension #4.</param>
            <param name="d5">Index into dimension #5.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional indices <paramref name="d0"/> ... <paramref name="d5"/>.</para>
            <para><paramref name="d5"/> is considered a <b>sequential</b> index into its own and into subsequent, merged 
            dimensions (Matlab/ILNumericsV4 indexing style).</para>
            <para>Deep indexing: the element to be replaced is located by matching the full set of given indices with 
            the existing dimensions of the cell, starting with index <paramref name="d0"/>. If the indices corresponding 
            to the number of dimensions of this cell point to an ILNumerics array subsequent indices are used as indices into that array. On the 
            other hand, if the element found is a cell, indexing is continued recursively at that cell element.</para>
            <para>The function supports automatic expansion for existing dimensions of regular (non-cell) arrays. When 
            the given indices address a non-existing element of a non-cell array the array currently stored in the cell 
            is expanded in a way that the new value can be stored at the provided location of the array.</para>
            <para>Removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/cell-arrays.html">ILNumerics cell arrays tutorial online.</seealso>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue(ILNumerics.Core.Arrays.Mutable{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.BaseArray,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Sets the value of the element addressed by <paramref name="d0"/>...<paramref name="d6"/>. Supports deep indexing into cell elements.
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <param name="d3">Index into dimension #3.</param>
            <param name="d4">Index into dimension #4.</param>
            <param name="d5">Index into dimension #5.</param>
            <param name="d6">Index into dimension #6.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional index <paramref name="d6"/>.</para>
            <para><paramref name="d6"/> is considered a <b>sequential</b> index into its own and into subsequent, merged 
            dimensions (Matlab/ILNumericsV4 indexing style).</para>
            <para>Deep indexing: the element to be replaced is located by matching the full set of given indices with 
            the existing dimensions of the cell, starting with index <paramref name="d0"/>. If the indices corresponding 
            to the number of dimensions of this cell point to an ILNumerics array subsequent indices are used as indices into that array. On the 
            other hand, if the element found is a cell, indexing is continued recursively at that cell element.</para>
            <para>The function supports automatic expansion for existing dimensions of regular (non-cell) arrays. When 
            the given indices address a non-existing element of a non-cell array the array currently stored in the cell 
            is expanded in a way that the new value can be stored at the provided location of the array.</para>
            <para>Removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/cell-arrays.html">ILNumerics cell arrays tutorial online.</seealso>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64[])">
            <summary>
            Sets the value of the element addressed by index array <paramref name="dims"/>. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="dims">Index array addressing the elements location in all referenced dimensions.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional indices <paramref name="dims"/></para>
            <para>The function supports automatic expansion when addressing elements outside of the 
            current dimension range. However, removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> arrays for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <exception cref="T:System.InvalidOperationException">if this array is currently in use by other arrays and 
            locked against modifications. This should not happen during 'regular' use and often indicate bad design.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,ILNumerics.InArray{System.Int64})">
            <summary>
            Sets the value of the element addressed by index array <paramref name="dims"/>. 
            </summary>
            <param name="value">The new value.</param>
            <param name="A">This mutable array.</param>
            <param name="dims">Index array addressing the elements location in all referenced dimensions.</param>
            <remarks>
            <para>This function replaces a single value of <paramref name="A"/> at the position as specified by 
            the dimensional indices <paramref name="dims"/></para>
            <para>The function supports automatic expansion when addressing elements outside of the 
            current dimension range. However, removal of parts of the array is not supported. Use the indexers 
            defined on <see cref="T:ILNumerics.Core.Arrays.Mutable`6"/> arrays for removal operations 
            in array style <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It is recommended to initialize your arrays with a fixed 
            size and to prevent from array size changing operations for best performance, though.</para>
            </remarks>
            <exception cref="T:System.OutOfMemoryException"> if the expanded size as determined by the given indices is 
            too large to be allocated.</exception>
            <exception cref="T:System.InvalidOperationException">if this array is currently in use by other arrays and 
            locked against modifications. This should not happen during 'regular' use and often indicate bad design.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})">
            <summary>
            Creates new array with repeated copies of the content of the source array.
            </summary>
            <param name="A">The source array.</param>
            <param name="rep">Repetition factors for each dimensions <paramref name="A"/> is to be replicated along.</param>
            <returns>New array with repeated copies of the source array along the dimensions as specified by <paramref name="rep"/>.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="rep"/> is null.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64)">
            <summary>
            Creates new array with repeated copies of the content of <paramref name="A"/>.
            </summary>
            <param name="A">The source array.</param>
            <param name="d0">Repetition factor for the first dimension of <paramref name="A"/></param>
            <returns>New array with repeated copies of the source array along the dimensions as specified by <paramref name="d0"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64)">
            <summary>
            Creates new array with repeated copies of the content of <paramref name="A"/>.
            </summary>
            <param name="A">The source array.</param>
            <param name="d0">Repetition factor for the first dimension of <paramref name="A"/>.</param>
            <param name="d1">Repetition factor for dimension #1 of <paramref name="A"/>.</param>
            <returns>New array with repeated copies of the source array along the dimensions as specified by <paramref name="d0"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates new array with repeated copies of the content of <paramref name="A"/>.
            </summary>
            <param name="A">The source array.</param>
            <param name="d0">Repetition factor for the first dimension of <paramref name="A"/>.</param>
            <param name="d1">Repetition factor for dimension #1 of <paramref name="A"/>.</param>
            <param name="d2">Repetition factor for dimension #2 of <paramref name="A"/>.</param>
            <returns>New array with repeated copies of the source array along the dimensions as specified by <paramref name="d0"/>....</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates new array with repeated copies of the content of <paramref name="A"/>.
            </summary>
            <param name="A">The source array.</param>
            <param name="d0">Repetition factor for the first dimension of <paramref name="A"/>.</param>
            <param name="d1">Repetition factor for dimension #1 of <paramref name="A"/>.</param>
            <param name="d2">Repetition factor for dimension #2 of <paramref name="A"/>.</param>
            <param name="d3">Repetition factor for dimension #3 of <paramref name="A"/>.</param>
            <returns>New array with repeated copies of the source array along the dimensions as specified by <paramref name="d0"/>....</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates new array with repeated copies of the content of <paramref name="A"/>.
            </summary>
            <param name="A">The source array.</param>
            <param name="d0">Repetition factor for the first dimension of <paramref name="A"/>.</param>
            <param name="d1">Repetition factor for dimension #1 of <paramref name="A"/>.</param>
            <param name="d2">Repetition factor for dimension #2 of <paramref name="A"/>.</param>
            <param name="d3">Repetition factor for dimension #3 of <paramref name="A"/>.</param>
            <param name="d4">Repetition factor for dimension #4 of <paramref name="A"/>.</param>
            <returns>New array with repeated copies of the source array along the dimensions as specified by <paramref name="d0"/>....</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates new array with repeated copies of the content of <paramref name="A"/>.
            </summary>
            <param name="A">The source array.</param>
            <param name="d0">Repetition factor for the first dimension of <paramref name="A"/>.</param>
            <param name="d1">Repetition factor for dimension #1 of <paramref name="A"/>.</param>
            <param name="d2">Repetition factor for dimension #2 of <paramref name="A"/>.</param>
            <param name="d3">Repetition factor for dimension #3 of <paramref name="A"/>.</param>
            <param name="d4">Repetition factor for dimension #4 of <paramref name="A"/>.</param>
            <param name="d5">Repetition factor for dimension #5 of <paramref name="A"/>.</param>
            <returns>New array with repeated copies of the source array along the dimensions as specified by <paramref name="d0"/>....</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates new array with repeated copies of the content of <paramref name="A"/>.
            </summary>
            <param name="A">The source array.</param>
            <param name="d0">Repetition factor for the first dimension of <paramref name="A"/>.</param>
            <param name="d1">Repetition factor for dimension #1 of <paramref name="A"/>.</param>
            <param name="d2">Repetition factor for dimension #2 of <paramref name="A"/>.</param>
            <param name="d3">Repetition factor for dimension #3 of <paramref name="A"/>.</param>
            <param name="d4">Repetition factor for dimension #4 of <paramref name="A"/>.</param>
            <param name="d5">Repetition factor for dimension #5 of <paramref name="A"/>.</param>
            <param name="d6">Repetition factor for dimension #6 of <paramref name="A"/>.</param>
            <returns>New array with repeated copies of the source array along the dimensions as specified by <paramref name="d0"/>....</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)">
            <summary>
            Returns the ret array for the storage of <paramref name="A"/> or null.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="A">Input array of storage type <see cref="T:ILNumerics.Core.StorageLayer.Storage`1"/>.</param>
            <returns>If <paramref name="A"/> stores elements of type <typeparamref name="T"/> the RetT of A's storage. Otherwise returns null.</returns>
            <remarks><para>This function is convenient when the element type of <paramref name="A"/> is known but the lifetime type 
            (local array, input array, return array, etc.) is not known. Instead, the common base type <see cref="T:ILNumerics.BaseArray"/> is 
            used to reference the array and this function returns its corresponding return type array.</para>
            <para>Note, that commonly, arrays in ILNumerics are not handled via <see cref="T:ILNumerics.BaseArray"/> but as concrete array types. 
            See the general function rules to learn recommended ways of working with arrays in ILNumerics.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/GeneralRules.html"/>
            <seealso cref="!:MathInternal.convert&lt;inT, outT&gt;(BaseArray&lt;inT&gt;)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetCell(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetLogical(ILNumerics.BaseArray)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.ToRetCell(ILNumerics.BaseArray)">
            <summary>
            Returns the ret cell for the storage of <paramref name="A"/> or null.
            </summary>
            <param name="A">Input cell array.</param>
            <returns>If <paramref name="A"/> stores elements of type <see cref="T:ILNumerics.BaseArray"/> the <see cref="T:ILNumerics.RetCell"/> of <paramref name="A"/>'s storage. Otherwise returns null.</returns>
            <remarks><para>This function is convenient when the element type of <paramref name="A"/> is known but the lifetime type 
            (local array, input array, return array, etc.) is not known. Instead, the common base type <see cref="T:ILNumerics.BaseArray"/> is 
            used to reference the array and this function returns its corresponding return type array.</para>
            <para>Note, that commonly, arrays in ILNumerics are not handled via <see cref="T:ILNumerics.BaseArray"/> but as concrete array types. 
            See the general function rules to learn recommended ways of working with arrays in ILNumerics.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/GeneralRules.html"/>
            <seealso cref="!:MathInternal.convert&lt;inT, outT&gt;(BaseArray&lt;inT&gt;)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetLogical(ILNumerics.BaseArray)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.ToRetLogical(ILNumerics.BaseArray)">
            <summary>
            Returns the return type logical for the storage of <paramref name="A"/> or null.
            </summary>
            <param name="A">Input logical array.</param>
            <returns>If <paramref name="A"/> stores elements of type <see cref="T:System.Boolean"/> the <see cref="T:ILNumerics.RetLogical"/> of <paramref name="A"/>'s storage. Otherwise returns null.</returns>
            <remarks><para>This function is convenient when the element type of <paramref name="A"/> is known but the lifetime type 
            (local array, input array, return array, etc.) is not known. Instead, the common base type <see cref="T:ILNumerics.BaseArray"/> is 
            used to reference the array and this function returns its corresponding return type array.</para>
            <para>Note, that commonly, arrays in ILNumerics are not handled via <see cref="T:ILNumerics.BaseArray"/> but as concrete array types. 
            See the general function rules to learn recommended ways of working with arrays in ILNumerics.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/GeneralRules.html"/>
            <seealso cref="!:MathInternal.convert&lt;inT, outT&gt;(BaseArray&lt;inT&gt;)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetCell(ILNumerics.BaseArray)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})">
            <summary>
            Gives the content of a cell element as ILNumerics array of specified type <typeparamref name="T"/>.
            </summary>
            <param name="A">The source cell.</param>
            <param name="indices">Indices into the dimensions of <paramref name="A"/> addressing the single cell storing the array.</param>
            <returns>Lazy, shallow copy of the element found at given <paramref name="indices"/>.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="indices"/> is null.</exception>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage})">
            <summary>
            Gives the content of a scalar cell as ILNumerics array of specified type <typeparamref name="T"/>.
            </summary>
            <param name="A">The source cell.</param>
            <returns>Lazy, shallow copy of the matching element found at given position or null.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)">
            <summary>
            Gives the content of a cell element as ILNumerics array of specified type <typeparamref name="T"/>.
            </summary>
            <param name="A">The source cell.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> or sequential index (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>) addressing the single cell storing the array.</param>
            <returns>Lazy, shallow copy of the matching element found at given position or null.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element as ILNumerics array of specified type <typeparamref name="T"/>.
            </summary>
            <param name="A">The source cell.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single cell storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the matching element found at given position or null.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element as ILNumerics array of specified type <typeparamref name="T"/>.
            </summary>
            <param name="A">The source cell.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single cell storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the matching element found at given position or null.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element as ILNumerics array of specified type <typeparamref name="T"/>.
            </summary>
            <param name="A">The source cell.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single cell storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <param name="d3">Index into the 4-th dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the matching element found at given position or null.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element as ILNumerics array of specified type <typeparamref name="T"/>.
            </summary>
            <param name="A">The source cell.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single cell storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <param name="d3">Index into the 4-th dimensions of <paramref name="A"/>.</param>
            <param name="d4">Index into the 5-th dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the matching element found at given position or null.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element as ILNumerics array of specified type <typeparamref name="T"/>.
            </summary>
            <param name="A">The source cell.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single cell storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <param name="d3">Index into the 4-th dimensions of <paramref name="A"/>.</param>
            <param name="d4">Index into the 5-th dimensions of <paramref name="A"/>.</param>
            <param name="d5">Index into the 6-th dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the matching element found at given position or null.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element as ILNumerics array of specified type <typeparamref name="T"/>.
            </summary>
            <param name="A">The source cell.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single cell storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <param name="d3">Index into the 4-th dimensions of <paramref name="A"/>.</param>
            <param name="d4">Index into the 5-th dimensions of <paramref name="A"/>.</param>
            <param name="d5">Index into the 6-th dimensions of <paramref name="A"/>.</param>
            <param name="d6">Index into the 6-th dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the matching element found at given position or null.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetCell(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})">
            <summary>
            Gives the content of a cell element of element type cell.
            </summary>
            <param name="A">The source cell.</param>
            <param name="indices">Indices into the dimensions of <paramref name="A"/> addressing the single cell storing the inner cell to retrieve.</param>
            <returns>Lazy, shallow copy of the element found at given <paramref name="indices"/>.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="indices"/> is null.</exception>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetCell(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage})">
            <summary>
            Gives the content of a scalar cell of element type cell.
            </summary>
            <param name="A">The source cell.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetCell(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)">
            <summary>
            Gives the content of a cell element of element type cell.
            </summary>
            <param name="A">The source cell.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> or sequential index (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>) addressing the single cell storing the array.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetCell(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element of element type cell.
            </summary>
            <param name="A">The source cell.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single cell storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetCell(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element of element type cell.
            </summary>
            <param name="A">The source cell.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single cell storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetCell(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element of element type cell.
            </summary>
            <param name="A">The source cell.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single cell storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <param name="d3">Index into the 4-th dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetCell(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element of element type cell.
            </summary>
            <param name="A">The source cell.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single cell storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <param name="d3">Index into the 4-th dimensions of <paramref name="A"/>.</param>
            <param name="d4">Index into the 5-th dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetCell(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element of element type cell.
            </summary>
            <param name="A">The source cell.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single cell storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <param name="d3">Index into the 4-th dimensions of <paramref name="A"/>.</param>
            <param name="d4">Index into the 5-th dimensions of <paramref name="A"/>.</param>
            <param name="d5">Index into the 6-th dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetCell(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element of element type cell.
            </summary>
            <param name="A">The source cell.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single cell storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <param name="d3">Index into the 4-th dimensions of <paramref name="A"/>.</param>
            <param name="d4">Index into the 5-th dimensions of <paramref name="A"/>.</param>
            <param name="d5">Index into the 6-th dimensions of <paramref name="A"/>.</param>
            <param name="d6">Index into the 6-th dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLogical(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})">
            <summary>
            Gives the content of a cell element storing a <see cref="T:ILNumerics.Logical"/> array.
            </summary>
            <param name="A">The source Logical.</param>
            <param name="indices">Indices into the dimensions of <paramref name="A"/> addressing the single Logical storing the inner Logical to retrieve.</param>
            <returns>Lazy, shallow copy of the element found at given <paramref name="indices"/>.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="indices"/> is null.</exception>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetLogical(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLogical(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage})">
            <summary>
            Gives the content of a scalar cell storing a <see cref="T:ILNumerics.Logical"/> array.
            </summary>
            <param name="A">The source Logical.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLogical(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)">
            <summary>
            Gives the content of a cell element storing a <see cref="T:ILNumerics.Logical"/> array.
            </summary>
            <param name="A">The source Logical.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> or sequential index (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>) addressing the single Logical storing the array.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLogical(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element storing a <see cref="T:ILNumerics.Logical"/> array.
            </summary>
            <param name="A">The source Logical.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single Logical storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLogical(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element storing a <see cref="T:ILNumerics.Logical"/> array.
            </summary>
            <param name="A">The source Logical.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single Logical storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLogical(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element storing a <see cref="T:ILNumerics.Logical"/> array.
            </summary>
            <param name="A">The source Logical.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single Logical storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <param name="d3">Index into the 4-th dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLogical(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element storing a <see cref="T:ILNumerics.Logical"/> array.
            </summary>
            <param name="A">The source Logical.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single Logical storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <param name="d3">Index into the 4-th dimensions of <paramref name="A"/>.</param>
            <param name="d4">Index into the 5-th dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLogical(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element storing a <see cref="T:ILNumerics.Logical"/> array.
            </summary>
            <param name="A">The source Logical.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single Logical storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <param name="d3">Index into the 4-th dimensions of <paramref name="A"/>.</param>
            <param name="d4">Index into the 5-th dimensions of <paramref name="A"/>.</param>
            <param name="d5">Index into the 6-th dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLogical(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Gives the content of a cell element storing a <see cref="T:ILNumerics.Logical"/> array.
            </summary>
            <param name="A">The source Logical.</param>
            <param name="d0">Index into the first dimensions of <paramref name="A"/> addressing the single Logical storing the array.</param>
            <param name="d1">Index into the second dimensions of <paramref name="A"/>.</param>
            <param name="d2">Index into the third dimensions of <paramref name="A"/>.</param>
            <param name="d3">Index into the 4-th dimensions of <paramref name="A"/>.</param>
            <param name="d4">Index into the 5-th dimensions of <paramref name="A"/>.</param>
            <param name="d5">Index into the 6-th dimensions of <paramref name="A"/>.</param>
            <param name="d6">Index into the 6-th dimensions of <paramref name="A"/>.</param>
            <returns>Lazy, shallow copy of the element found at given position.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="!:size(long, long, long, long, long)"/>
            <seealso cref="!:size(long)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})">
            <summary>
            Tests if a cell element is of the given element type. 
            </summary>
            <typeparam name="CellT">The array element type to probe the cell element for.</typeparam>
            <param name="A">The cell.</param>
            <param name="indices">Dimensional indices defining the position of the cell element to be probed.</param>
            <returns>true if the element found at the given position is an array of the given element type <typeparamref name="CellT"/>, false otherwise.</returns>
            <remarks><para>The method is helpful in order to inspect the contents of a cell array. If the actual types of cells in the cell array
            are unknown this function can be used to determine the type of the content of individual cells before attempting to retrieve any values.</para>
            <para>In most situations, elements of a cell are stored arrays of a distinct element type. That element type is given to 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/> as 
            typeparameter <typeparamref name="CellT"/>. That means, in order to find out, if the first cell element stores an array of int 
            <c><![CDATA[cell.IsTypeOf<int>(0)]]></c> is used.</para>
            <para>When testing for <see cref="T:ILNumerics.Logical"/> arrays <see cref="T:System.Boolean"/> is used for <typeparamref name="CellT"/>.</para>
            <para>In order to test for cell element type <typeparamref name="CellT"/> can be <see cref="T:ILNumerics.Cell"/> or <see cref="T:ILNumerics.BaseArray"/>: <c><![CDATA[cell.IsTypeOf<BaseArray>(0)]]></c>.</para>
            </remarks>
            <example>
            <para>In the following example a Cell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code><![CDATA[Cell cell1 = cell(size(3, 2), vector<BaseArray>(
                                "first element"
                                , 2.0
                                , cell(arrays: vector<BaseArray>(Math.PI, 100f))
                                , vector<short>(1, 2, 3, 4, 5, 6)
                                , vector<double>(-1.4, -1.5, -1.6 )));
            
            Console.Out.WriteLine($"cell[0,0] is element type 'string': {cell1.IsTypeOf<string>(0)}");
            Console.Out.WriteLine($"cell[0,0] is element type 'double': {cell1.IsTypeOf<double>(0)}");
            
            Console.Out.WriteLine($"cell[1,0] is element type 'double': {cell1.IsTypeOf<double>(1,0)}");
            Console.Out.WriteLine($"cell[2,0] is element type 'Cell': {cell1.IsTypeOf<Cell>(2,0)}");
            
            Console.Out.WriteLine($"cell[0,1] is element type 'short': {cell1.IsTypeOf<short>(0, 1)}");
            Console.Out.WriteLine($"cell[1,1] is element type 'Cell': {cell1.IsTypeOf<Cell>(1, 1)}");
            Console.Out.WriteLine($"cell[2,1] is element type 'double': {cell1.IsTypeOf<double>(2, 1)}");]]>
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'Cell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'Cell': True
            cell[2,1] is element type 'double': False (element is null.)
            </code></example>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)">
            <summary>
            Tests if a cell element is of the given element type. 
            </summary>
            <typeparam name="CellT">The array element type to probe the cell element for.</typeparam>
            <param name="A">The cell.</param>
            <param name="d0">Dimensional index into dimension #0.</param>
            <returns>true if the element found at the given position is an array of the given element type <typeparamref name="CellT"/>, false otherwise.</returns>
            <remarks><para>The method is helpful in order to inspect the contents of a cell array. If the actual types of cells in the cell array
            are unknown this function can be used to determine the type of the content of individual cells before attempting to retrieve any values.</para>
            <para>In most situations, elements of a cell are arrays of a distinct element type. This element type is given to 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/> as 
            typeparameter <typeparamref name="CellT"/>. That means, in order to find out, if the first cell element stores an array of int 
            <c><![CDATA[cell.IsTypeOf<int>(0)]]></c> is used.</para>
            <para>When testing for <see cref="T:ILNumerics.Logical"/> arrays <see cref="T:System.Boolean"/> is used for <typeparamref name="CellT"/>.</para>
            <para>In order to test for cell element type <typeparamref name="CellT"/> can be <see cref="T:ILNumerics.Cell"/> or <see cref="T:ILNumerics.BaseArray"/>: <c><![CDATA[cell.IsTypeOf<BaseArray>(0)]]></c>.</para>
            </remarks>
            <example>
            <para>In the following example a Cell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code><![CDATA[Cell cell1 = cell(size(3, 2), vector<BaseArray>(
                                "first element"
                                , 2.0
                                , cell(arrays: vector<BaseArray>(Math.PI, 100f))
                                , vector<short>(1, 2, 3, 4, 5, 6)
                                , vector<double>(-1.4, -1.5, -1.6 )));
            
            Console.Out.WriteLine($"cell[0,0] is element type 'string': {cell1.IsTypeOf<string>(0)}");
            Console.Out.WriteLine($"cell[0,0] is element type 'double': {cell1.IsTypeOf<double>(0)}");
            
            Console.Out.WriteLine($"cell[1,0] is element type 'double': {cell1.IsTypeOf<double>(1,0)}");
            Console.Out.WriteLine($"cell[2,0] is element type 'Cell': {cell1.IsTypeOf<Cell>(2,0)}");
            
            Console.Out.WriteLine($"cell[0,1] is element type 'short': {cell1.IsTypeOf<short>(0, 1)}");
            Console.Out.WriteLine($"cell[1,1] is element type 'Cell': {cell1.IsTypeOf<Cell>(1, 1)}");
            Console.Out.WriteLine($"cell[2,1] is element type 'double': {cell1.IsTypeOf<double>(2, 1)}");]]>
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'Cell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'Cell': True
            cell[2,1] is element type 'double': False (element is null.)
            </code></example>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64)">
            <summary>
            Tests if a cell element is of the given element type. 
            </summary>
            <typeparam name="CellT">The array element type to probe the cell element for.</typeparam>
            <param name="A">The cell.</param>
            <param name="d0">Dimensional index into dimension #0.</param>
            <param name="d1">Dimensional index into dimension #1.</param>
            <returns>true if the element found at the given position is an array of the given element type <typeparamref name="CellT"/>, false otherwise.</returns>
            <remarks><para>The method is helpful in order to inspect the contents of a cell array. If the actual types of cells in the cell array
            are unknown this function can be used to determine the type of the content of individual cells before attempting to retrieve any values.</para>
            <para>In most situations, elements of a cell are arrays of a distinct element type. This element type is given to 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/> as 
            typeparameter <typeparamref name="CellT"/>. That means, in order to find out, if the first cell element stores an array of int 
            <c><![CDATA[cell.IsTypeOf<int>(0)]]></c> is used.</para>
            <para>When testing for <see cref="T:ILNumerics.Logical"/> arrays <see cref="T:System.Boolean"/> is used for <typeparamref name="CellT"/>.</para>
            <para>In order to test for cell element type <typeparamref name="CellT"/> can be <see cref="T:ILNumerics.Cell"/> or <see cref="T:ILNumerics.BaseArray"/>: <c><![CDATA[cell.IsTypeOf<BaseArray>(0)]]></c>.</para>
            </remarks>
            <example>
            <para>In the following example a Cell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code><![CDATA[Cell cell1 = cell(size(3, 2), vector<BaseArray>(
                                "first element"
                                , 2.0
                                , cell(arrays: vector<BaseArray>(Math.PI, 100f))
                                , vector<short>(1, 2, 3, 4, 5, 6)
                                , vector<double>(-1.4, -1.5, -1.6 )));
            
            Console.Out.WriteLine($"cell[0,0] is element type 'string': {cell1.IsTypeOf<string>(0)}");
            Console.Out.WriteLine($"cell[0,0] is element type 'double': {cell1.IsTypeOf<double>(0)}");
            
            Console.Out.WriteLine($"cell[1,0] is element type 'double': {cell1.IsTypeOf<double>(1,0)}");
            Console.Out.WriteLine($"cell[2,0] is element type 'Cell': {cell1.IsTypeOf<Cell>(2,0)}");
            
            Console.Out.WriteLine($"cell[0,1] is element type 'short': {cell1.IsTypeOf<short>(0, 1)}");
            Console.Out.WriteLine($"cell[1,1] is element type 'Cell': {cell1.IsTypeOf<Cell>(1, 1)}");
            Console.Out.WriteLine($"cell[2,1] is element type 'double': {cell1.IsTypeOf<double>(2, 1)}");]]>
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'Cell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'Cell': True
            cell[2,1] is element type 'double': False (element is null.)
            </code></example>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64)">
            <summary>
            Tests if a cell element is of the given element type. 
            </summary>
            <typeparam name="CellT">The array element type to probe the cell element for.</typeparam>
            <param name="A">The cell.</param>
            <param name="d0">Dimensional index into dimension #0.</param>
            <param name="d1">Dimensional index into dimension #1.</param>
            <param name="d2">Dimensional index into dimension #2.</param>
            <returns>true if the element found at the given position is an array of the given element type <typeparamref name="CellT"/>, false otherwise.</returns>
            <remarks><para>The method is helpful in order to inspect the contents of a cell array. If the actual types of cells in the cell array
            are unknown this function can be used to determine the type of the content of individual cells before attempting to retrieve any values.</para>
            <para>In most situations, elements of a cell are arrays of a distinct element type. This element type is given to 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/> as 
            typeparameter <typeparamref name="CellT"/>. That means, in order to find out, if the first cell element stores an array of int 
            <c><![CDATA[cell.IsTypeOf<int>(0)]]></c> is used.</para>
            <para>When testing for <see cref="T:ILNumerics.Logical"/> arrays <see cref="T:System.Boolean"/> is used for <typeparamref name="CellT"/>.</para>
            <para>In order to test for cell element type <typeparamref name="CellT"/> can be <see cref="T:ILNumerics.Cell"/> or <see cref="T:ILNumerics.BaseArray"/>: <c><![CDATA[cell.IsTypeOf<BaseArray>(0)]]></c>.</para>
            </remarks>
            <example>
            <para>In the following example a Cell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code><![CDATA[Cell cell1 = cell(size(3, 2), vector<BaseArray>(
                                "first element"
                                , 2.0
                                , cell(arrays: vector<BaseArray>(Math.PI, 100f))
                                , vector<short>(1, 2, 3, 4, 5, 6)
                                , vector<double>(-1.4, -1.5, -1.6 )));
            
            Console.Out.WriteLine($"cell[0,0] is element type 'string': {cell1.IsTypeOf<string>(0)}");
            Console.Out.WriteLine($"cell[0,0] is element type 'double': {cell1.IsTypeOf<double>(0)}");
            
            Console.Out.WriteLine($"cell[1,0] is element type 'double': {cell1.IsTypeOf<double>(1,0)}");
            Console.Out.WriteLine($"cell[2,0] is element type 'Cell': {cell1.IsTypeOf<Cell>(2,0)}");
            
            Console.Out.WriteLine($"cell[0,1] is element type 'short': {cell1.IsTypeOf<short>(0, 1)}");
            Console.Out.WriteLine($"cell[1,1] is element type 'Cell': {cell1.IsTypeOf<Cell>(1, 1)}");
            Console.Out.WriteLine($"cell[2,1] is element type 'double': {cell1.IsTypeOf<double>(2, 1)}");]]>
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'Cell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'Cell': True
            cell[2,1] is element type 'double': False (element is null.)
            </code></example>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Tests if a cell element is of the given element type. 
            </summary>
            <typeparam name="CellT">The array element type to probe the cell element for.</typeparam>
            <param name="A">The cell.</param>
            <param name="d0">Dimensional index into dimension #0.</param>
            <param name="d1">Dimensional index into dimension #1.</param>
            <param name="d2">Dimensional index into dimension #2.</param>
            <param name="d3">Dimensional index into dimension #3.</param>
            <returns>true if the element found at the given position is an array of the given element type <typeparamref name="CellT"/>, false otherwise.</returns>
            <remarks><para>The method is helpful in order to inspect the contents of a cell array. If the actual types of cells in the cell array
            are unknown this function can be used to determine the type of the content of individual cells before attempting to retrieve any values.</para>
            <para>In most situations, elements of a cell are arrays of a distinct element type. This element type is given to 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/> as 
            typeparameter <typeparamref name="CellT"/>. That means, in order to find out, if the first cell element stores an array of int 
            <c><![CDATA[cell.IsTypeOf<int>(0)]]></c> is used.</para>
            <para>When testing for <see cref="T:ILNumerics.Logical"/> arrays <see cref="T:System.Boolean"/> is used for <typeparamref name="CellT"/>.</para>
            <para>In order to test for cell element type <typeparamref name="CellT"/> can be <see cref="T:ILNumerics.Cell"/> or <see cref="T:ILNumerics.BaseArray"/>: <c><![CDATA[cell.IsTypeOf<BaseArray>(0)]]></c>.</para>
            </remarks>
            <example>
            <para>In the following example a Cell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code><![CDATA[Cell cell1 = cell(size(3, 2), vector<BaseArray>(
                                "first element"
                                , 2.0
                                , cell(arrays: vector<BaseArray>(Math.PI, 100f))
                                , vector<short>(1, 2, 3, 4, 5, 6)
                                , vector<double>(-1.4, -1.5, -1.6 )));
            
            Console.Out.WriteLine($"cell[0,0] is element type 'string': {cell1.IsTypeOf<string>(0)}");
            Console.Out.WriteLine($"cell[0,0] is element type 'double': {cell1.IsTypeOf<double>(0)}");
            
            Console.Out.WriteLine($"cell[1,0] is element type 'double': {cell1.IsTypeOf<double>(1,0)}");
            Console.Out.WriteLine($"cell[2,0] is element type 'Cell': {cell1.IsTypeOf<Cell>(2,0)}");
            
            Console.Out.WriteLine($"cell[0,1] is element type 'short': {cell1.IsTypeOf<short>(0, 1)}");
            Console.Out.WriteLine($"cell[1,1] is element type 'Cell': {cell1.IsTypeOf<Cell>(1, 1)}");
            Console.Out.WriteLine($"cell[2,1] is element type 'double': {cell1.IsTypeOf<double>(2, 1)}");]]>
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'Cell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'Cell': True
            cell[2,1] is element type 'double': False (element is null.)
            </code></example>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Tests if a cell element is of the given element type. 
            </summary>
            <typeparam name="CellT">The array element type to probe the cell element for.</typeparam>
            <param name="A">The cell.</param>
            <param name="d0">Dimensional index into dimension #0.</param>
            <param name="d1">Dimensional index into dimension #1.</param>
            <param name="d2">Dimensional index into dimension #2.</param>
            <param name="d3">Dimensional index into dimension #3.</param>
            <param name="d4">Dimensional index into dimension #4.</param>
            <returns>true if the element found at the given position is an array of the given element type <typeparamref name="CellT"/>, false otherwise.</returns>
            <remarks><para>The method is helpful in order to inspect the contents of a cell array. If the actual types of cells in the cell array
            are unknown this function can be used to determine the type of the content of individual cells before attempting to retrieve any values.</para>
            <para>In most situations, elements of a cell are arrays of a distinct element type. This element type is given to 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/> as 
            typeparameter <typeparamref name="CellT"/>. That means, in order to find out, if the first cell element stores an array of int 
            <c><![CDATA[cell.IsTypeOf<int>(0)]]></c> is used.</para>
            <para>When testing for <see cref="T:ILNumerics.Logical"/> arrays <see cref="T:System.Boolean"/> is used for <typeparamref name="CellT"/>.</para>
            <para>In order to test for cell element type <typeparamref name="CellT"/> can be <see cref="T:ILNumerics.Cell"/> or <see cref="T:ILNumerics.BaseArray"/>: <c><![CDATA[cell.IsTypeOf<BaseArray>(0)]]></c>.</para>
            </remarks>
            <example>
            <para>In the following example a Cell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code><![CDATA[Cell cell1 = cell(size(3, 2), vector<BaseArray>(
                                "first element"
                                , 2.0
                                , cell(arrays: vector<BaseArray>(Math.PI, 100f))
                                , vector<short>(1, 2, 3, 4, 5, 6)
                                , vector<double>(-1.4, -1.5, -1.6 )));
            
            Console.Out.WriteLine($"cell[0,0] is element type 'string': {cell1.IsTypeOf<string>(0)}");
            Console.Out.WriteLine($"cell[0,0] is element type 'double': {cell1.IsTypeOf<double>(0)}");
            
            Console.Out.WriteLine($"cell[1,0] is element type 'double': {cell1.IsTypeOf<double>(1,0)}");
            Console.Out.WriteLine($"cell[2,0] is element type 'Cell': {cell1.IsTypeOf<Cell>(2,0)}");
            
            Console.Out.WriteLine($"cell[0,1] is element type 'short': {cell1.IsTypeOf<short>(0, 1)}");
            Console.Out.WriteLine($"cell[1,1] is element type 'Cell': {cell1.IsTypeOf<Cell>(1, 1)}");
            Console.Out.WriteLine($"cell[2,1] is element type 'double': {cell1.IsTypeOf<double>(2, 1)}");]]>
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'Cell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'Cell': True
            cell[2,1] is element type 'double': False (element is null.)
            </code></example>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Tests if a cell element is of the given element type. 
            </summary>
            <typeparam name="CellT">The array element type to probe the cell element for.</typeparam>
            <param name="A">The cell.</param>
            <param name="d0">Dimensional index into dimension #0.</param>
            <param name="d1">Dimensional index into dimension #1.</param>
            <param name="d2">Dimensional index into dimension #2.</param>
            <param name="d3">Dimensional index into dimension #3.</param>
            <param name="d4">Dimensional index into dimension #4.</param>
            <param name="d5">Dimensional index into dimension #5.</param>
            <returns>true if the element found at the given position is an array of the given element type <typeparamref name="CellT"/>, false otherwise.</returns>
            <remarks><para>The method is helpful in order to inspect the contents of a cell array. If the actual types of cells in the cell array
            are unknown this function can be used to determine the type of the content of individual cells before attempting to retrieve any values.</para>
            <para>In most situations, elements of a cell are arrays of a distinct element type. This element type is given to 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/> as 
            typeparameter <typeparamref name="CellT"/>. That means, in order to find out, if the first cell element stores an array of int 
            <c><![CDATA[cell.IsTypeOf<int>(0)]]></c> is used.</para>
            <para>When testing for <see cref="T:ILNumerics.Logical"/> arrays <see cref="T:System.Boolean"/> is used for <typeparamref name="CellT"/>.</para>
            <para>In order to test for cell element type <typeparamref name="CellT"/> can be <see cref="T:ILNumerics.Cell"/> or <see cref="T:ILNumerics.BaseArray"/>: <c><![CDATA[cell.IsTypeOf<BaseArray>(0)]]></c>.</para>
            </remarks>
            <example>
            <para>In the following example a Cell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code><![CDATA[Cell cell1 = cell(size(3, 2), vector<BaseArray>(
                                "first element"
                                , 2.0
                                , cell(arrays: vector<BaseArray>(Math.PI, 100f))
                                , vector<short>(1, 2, 3, 4, 5, 6)
                                , vector<double>(-1.4, -1.5, -1.6 )));
            
            Console.Out.WriteLine($"cell[0,0] is element type 'string': {cell1.IsTypeOf<string>(0)}");
            Console.Out.WriteLine($"cell[0,0] is element type 'double': {cell1.IsTypeOf<double>(0)}");
            
            Console.Out.WriteLine($"cell[1,0] is element type 'double': {cell1.IsTypeOf<double>(1,0)}");
            Console.Out.WriteLine($"cell[2,0] is element type 'Cell': {cell1.IsTypeOf<Cell>(2,0)}");
            
            Console.Out.WriteLine($"cell[0,1] is element type 'short': {cell1.IsTypeOf<short>(0, 1)}");
            Console.Out.WriteLine($"cell[1,1] is element type 'Cell': {cell1.IsTypeOf<Cell>(1, 1)}");
            Console.Out.WriteLine($"cell[2,1] is element type 'double': {cell1.IsTypeOf<double>(2, 1)}");]]>
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'Cell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'Cell': True
            cell[2,1] is element type 'double': False (element is null.)
            </code></example>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Tests if a cell element is of the given element type. 
            </summary>
            <typeparam name="CellT">The array element type to probe the cell element for.</typeparam>
            <param name="A">The cell.</param>
            <param name="d0">Dimensional index into dimension #0.</param>
            <param name="d1">Dimensional index into dimension #1.</param>
            <param name="d2">Dimensional index into dimension #2.</param>
            <param name="d3">Dimensional index into dimension #3.</param>
            <param name="d4">Dimensional index into dimension #4.</param>
            <param name="d5">Dimensional index into dimension #5.</param>
            <param name="d6">Dimensional index into dimension #6.</param>
            <returns>true if the element found at the given position is an array of the given element type <typeparamref name="CellT"/>, false otherwise.</returns>
            <remarks><para>The method is helpful in order to inspect the contents of a cell array. If the actual types of cells in the cell array
            are unknown this function can be used to determine the type of the content of individual cells before attempting to retrieve any values.</para>
            <para>In most situations, elements of a cell are arrays of a distinct element type. This element type is given to 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},ILNumerics.InArray{System.Int64})"/> as 
            typeparameter <typeparamref name="CellT"/>. That means, in order to find out, if the first cell element stores an array of int 
            <c><![CDATA[cell.IsTypeOf<int>(0)]]></c> is used.</para>
            <para>When testing for <see cref="T:ILNumerics.Logical"/> arrays <see cref="T:System.Boolean"/> is used for <typeparamref name="CellT"/>.</para>
            <para>In order to test for cell element type <typeparamref name="CellT"/> can be <see cref="T:ILNumerics.Cell"/> or <see cref="T:ILNumerics.BaseArray"/>: <c><![CDATA[cell.IsTypeOf<BaseArray>(0)]]></c>.</para>
            </remarks>
            <example>
            <para>In the following example a Cell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code><![CDATA[Cell cell1 = cell(size(3, 2), vector<BaseArray>(
                                "first element"
                                , 2.0
                                , cell(arrays: vector<BaseArray>(Math.PI, 100f))
                                , vector<short>(1, 2, 3, 4, 5, 6)
                                , vector<double>(-1.4, -1.5, -1.6 )));
            
            Console.Out.WriteLine($"cell[0,0] is element type 'string': {cell1.IsTypeOf<string>(0)}");
            Console.Out.WriteLine($"cell[0,0] is element type 'double': {cell1.IsTypeOf<double>(0)}");
            
            Console.Out.WriteLine($"cell[1,0] is element type 'double': {cell1.IsTypeOf<double>(1,0)}");
            Console.Out.WriteLine($"cell[2,0] is element type 'Cell': {cell1.IsTypeOf<Cell>(2,0)}");
            
            Console.Out.WriteLine($"cell[0,1] is element type 'short': {cell1.IsTypeOf<short>(0, 1)}");
            Console.Out.WriteLine($"cell[1,1] is element type 'Cell': {cell1.IsTypeOf<Cell>(1, 1)}");
            Console.Out.WriteLine($"cell[2,1] is element type 'double': {cell1.IsTypeOf<double>(2, 1)}");]]>
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'Cell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'Cell': True
            cell[2,1] is element type 'double': False (element is null.)
            </code></example>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetValueSeqAs``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)">
            <summary>
            Retrieves an ILNumerics array from a cell <paramref name="A"/> element of 'compatible' 
            element type. Only the target type is to be determined. 
            </summary>
            <typeparam name="T">Target element type. Must be a <see cref="T:System.ValueType"/>.</typeparam>
            <param name="i">Sequential element index into <paramref name="A"/></param>
            <param name="A">The source cell array.</param>
            <returns>Array retrieved at sequential index position <paramref name="i"/> in column major order. 
            Elements are converted into the target element type, if possible.</returns>
            <remarks><para>Note that the cell element position is specified as sequential index position only. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.UInt32},System.Int32)"/>
            in order to convert multidimensional indices into a sequential index.</para></remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.IsNullAt(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)">
            <summary>
            Test if the cell element at a given sequential position is null (Nothing in VB).
            </summary>
            <param name="i">Sequential position of the cell <paramref name="A"/> element to test.</param>
            <param name="A">The cell array to test for a null element.</param>
            <returns>true if the cell does not store an element at cell position <paramref name="i"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetBaseArray(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)">
            <summary>
            Retrieves a clone of the value at the position <paramref name="d0"/> as an array.
            </summary>
            <param name="A">The cell instance.</param>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Copy/clone of the elements value. Scalar values are wrapped into a scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond to the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage layouts both are likely to differ.</para> 
            <para>The type of the array returned corresponds to the type of the element addressed by <paramref name="d0"/>. Use 
            <see cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64)"/> in order to retrieve the element as its natural type. 
            <see cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/> can be used to inspect 
            the element type.</para>
            <para>Note, that the value addressed is not wrapped into a scalar cell before returning as would be the case for indexers on cells, 
            which always return cells. Thus the return value might be a cell or an ILNumerics array of any element type.
            Commonly, the value returned will be a volatile return type array. Thus, it will be released after the first use.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ToRetArray``1(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue``1(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/> of <paramref name="A"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.Size,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Efficient iterator over the array for use in foreach loops. 
            </summary>
            <param name="S">The array instance.</param>
            <param name="order">[Optional] Determines the order the elements are walked along. Default: <c>null</c> (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>)</param>
            <returns>Slim, self destructing iterator instance, iterating over all elements of this array.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{System.Double},System.Double@,System.Double@,System.Boolean)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="A"/>, optionally ignoring special floating point values.
            </summary>
            <param name="A">Input array.</param>
            <param name="min">[Output] The minimum value in <paramref name="A"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="A"/>.</param>
            <param name="ignoreInfinity">[Optional] When true only non-infinity and non-NaN values will be considered as regular values. Default: false.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>For complex values the real and imaginary parts of all elements are considered independently 
            and the limits are returned separated in the real and imaginary parts of <paramref name="min"/> and <paramref name="max"/>. </para>
            <para>The operation is efficiently performed on all elements of the input 
            <paramref name="A"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="A"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN and / or 'Infinity' -
             depending on the setting of <paramref name="ignoreInfinity"/>.</para>
            <para>The optional parameter <paramref name="ignoreInfinity"/> is useful, for example, to determine the 
            minimum and maximum values stored inside this array in order to find scaling factors and for 
            normalization purposes. Here, <see cref="F:System.Double.NegativeInfinity"/> and <see cref="F:System.Double.PositiveInfinity"/>
            can be ignored since they would be not useful as scaling factors. For the default value ('false')
            infinity values are considered regular values and contribute to the result.</para>
            <para>For arrays of real element types (<see cref="T:System.Double"/> and <see cref="T:System.Single"/>) the value 
            of the output parameters <paramref name="min"/> and <paramref name="max"/> is undefined if the function
            returns <see langword="false"/>. For <b>complex</b> element types the individual parts of <paramref name="min"/>
            and <paramref name="max"/> determine the limits found among the real parts and among the imaginary parts. If 
            limits could be computed for the real parts of the elements these limits will be stored into the real parts 
            of <paramref name="min"/> and <paramref name="max"/>. Similarly, the limits among the imaginary 
            elements are stored into the imaginary parts of <paramref name="min"/> and <paramref name="max"/>. If no limit
            could be computed (because all real or all imaginary element parts are all either NaN or Infinity (and 
            <paramref name="ignoreInfinity"/> was <see langword="true"/>) the corresponding part of <paramref name="min"/> 
            and <paramref name="max"/> will be NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.fcomplex@,ILNumerics.fcomplex@,System.Boolean)">
            <summary>fcomplex</summary>
            <param name="A">Input array.</param>
            <param name="min">[Output] The minimum value in <paramref name="A"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="A"/>.</param>
            <param name="ignoreInfinity">[Optional] When true only non-infinity and non-NaN values will be considered as regular values. Default: false.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>For complex values the real and imaginary parts of all elements are considered independently 
            and the limits are returned separated in the real and imaginary parts of <paramref name="min"/> and <paramref name="max"/>. </para>
            <para>The operation is efficiently performed on all elements of the input 
            <paramref name="A"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="A"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN and / or 'Infinity' -
             depending on the setting of <paramref name="ignoreInfinity"/>.</para>
            <para>The optional parameter <paramref name="ignoreInfinity"/> is useful, for example, to determine the 
            minimum and maximum values stored inside this array in order to find scaling factors and for 
            normalization purposes. Here, <see cref="!:fcomplex.NegativeInfinity"/> and <see cref="P:ILNumerics.fcomplex.PositiveInfinity"/>
            can be ignored since they would be not useful as scaling factors. For the default value ('false')
            infinity values are considered regular values and contribute to the result.</para>
            <para>For arrays of real element types (<see cref="T:System.Double"/> and <see cref="T:System.Single"/>) the value 
            of the output parameters <paramref name="min"/> and <paramref name="max"/> is undefined if the function
            returns <see langword="false"/>. For <b>complex</b> element types the individual parts of <paramref name="min"/>
            and <paramref name="max"/> determine the limits found among the real parts and among the imaginary parts. If 
            limits could be computed for the real parts of the elements these limits will be stored into the real parts 
            of <paramref name="min"/> and <paramref name="max"/>. Similarly, the limits among the imaginary 
            elements are stored into the imaginary parts of <paramref name="min"/> and <paramref name="max"/>. If no limit
            could be computed (because all real or all imaginary element parts are all either NaN or Infinity (and 
            <paramref name="ignoreInfinity"/> was <see langword="true"/>) the corresponding part of <paramref name="min"/> 
            and <paramref name="max"/> will be NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.complex@,ILNumerics.complex@,System.Boolean)">
            <summary>complex</summary>
            <param name="A">Input array.</param>
            <param name="min">[Output] The minimum value in <paramref name="A"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="A"/>.</param>
            <param name="ignoreInfinity">[Optional] When true only non-infinity and non-NaN values will be considered as regular values. Default: false.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>For complex values the real and imaginary parts of all elements are considered independently 
            and the limits are returned separated in the real and imaginary parts of <paramref name="min"/> and <paramref name="max"/>. </para>
            <para>The operation is efficiently performed on all elements of the input 
            <paramref name="A"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="A"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN and / or 'Infinity' -
             depending on the setting of <paramref name="ignoreInfinity"/>.</para>
            <para>The optional parameter <paramref name="ignoreInfinity"/> is useful, for example, to determine the 
            minimum and maximum values stored inside this array in order to find scaling factors and for 
            normalization purposes. Here, <see cref="!:complex.NegativeInfinity"/> and <see cref="P:ILNumerics.complex.PositiveInfinity"/>
            can be ignored since they would be not useful as scaling factors. For the default value ('false')
            infinity values are considered regular values and contribute to the result.</para>
            <para>For arrays of real element types (<see cref="T:System.Double"/> and <see cref="T:System.Single"/>) the value 
            of the output parameters <paramref name="min"/> and <paramref name="max"/> is undefined if the function
            returns <see langword="false"/>. For <b>complex</b> element types the individual parts of <paramref name="min"/>
            and <paramref name="max"/> determine the limits found among the real parts and among the imaginary parts. If 
            limits could be computed for the real parts of the elements these limits will be stored into the real parts 
            of <paramref name="min"/> and <paramref name="max"/>. Similarly, the limits among the imaginary 
            elements are stored into the imaginary parts of <paramref name="min"/> and <paramref name="max"/>. If no limit
            could be computed (because all real or all imaginary element parts are all either NaN or Infinity (and 
            <paramref name="ignoreInfinity"/> was <see langword="true"/>) the corresponding part of <paramref name="min"/> 
            and <paramref name="max"/> will be NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{System.Single},System.Single@,System.Single@,System.Boolean)">
            <summary>float</summary>
            <param name="A">Input array.</param>
            <param name="min">[Output] The minimum value in <paramref name="A"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="A"/>.</param>
            <param name="ignoreInfinity">[Optional] When true only non-infinity and non-NaN values will be considered as regular values. Default: false.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>For complex values the real and imaginary parts of all elements are considered independently 
            and the limits are returned separated in the real and imaginary parts of <paramref name="min"/> and <paramref name="max"/>. </para>
            <para>The operation is efficiently performed on all elements of the input 
            <paramref name="A"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="A"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN and / or 'Infinity' -
             depending on the setting of <paramref name="ignoreInfinity"/>.</para>
            <para>The optional parameter <paramref name="ignoreInfinity"/> is useful, for example, to determine the 
            minimum and maximum values stored inside this array in order to find scaling factors and for 
            normalization purposes. Here, <see cref="F:System.Single.NegativeInfinity"/> and <see cref="F:System.Single.PositiveInfinity"/>
            can be ignored since they would be not useful as scaling factors. For the default value ('false')
            infinity values are considered regular values and contribute to the result.</para>
            <para>For arrays of real element types (<see cref="T:System.Double"/> and <see cref="T:System.Single"/>) the value 
            of the output parameters <paramref name="min"/> and <paramref name="max"/> is undefined if the function
            returns <see langword="false"/>. For <b>complex</b> element types the individual parts of <paramref name="min"/>
            and <paramref name="max"/> determine the limits found among the real parts and among the imaginary parts. If 
            limits could be computed for the real parts of the elements these limits will be stored into the real parts 
            of <paramref name="min"/> and <paramref name="max"/>. Similarly, the limits among the imaginary 
            elements are stored into the imaginary parts of <paramref name="min"/> and <paramref name="max"/>. If no limit
            could be computed (because all real or all imaginary element parts are all either NaN or Infinity (and 
            <paramref name="ignoreInfinity"/> was <see langword="true"/>) the corresponding part of <paramref name="min"/> 
            and <paramref name="max"/> will be NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{System.SByte},System.SByte@,System.SByte@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="min">[Output] The minimum value in <paramref name="A"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="A"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{System.UInt64},System.UInt64@,System.UInt64@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="min">[Output] The minimum value in <paramref name="A"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="A"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{System.Int64},System.Int64@,System.Int64@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="min">[Output] The minimum value in <paramref name="A"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="A"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{System.UInt32},System.UInt32@,System.UInt32@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="min">[Output] The minimum value in <paramref name="A"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="A"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{System.Int32},System.Int32@,System.Int32@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="min">[Output] The minimum value in <paramref name="A"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="A"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{System.UInt16},System.UInt16@,System.UInt16@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="min">[Output] The minimum value in <paramref name="A"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="A"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{System.Int16},System.Int16@,System.Int16@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="min">[Output] The minimum value in <paramref name="A"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="A"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{System.Byte},System.Byte@,System.Byte@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="min">[Output] The minimum value in <paramref name="A"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="A"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> is empty.</exception>
        </member>
        <member name="T:ILNumerics.Core.Arrays.ConcreteArray`6">
            <summary>
            Abstract base class for concrete array implementations of type <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/>, <see cref="T:ILNumerics.InArray`1"/> and their conterparts for <see cref="T:ILNumerics.Logical"/> and <see cref="T:ILNumerics.Cell"/>. This class is not intended to be used directly. Use the concrete derived array classes instead! 
            </summary>
            <typeparam name="T1">The element type.</typeparam>
            <typeparam name="LocalT">The type of the local arrays: one of <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.Logical"/> or <see cref="T:ILNumerics.Cell"/>.</typeparam>
            <typeparam name="InT">The type of the input arrays: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InLogical"/>, or <see cref="T:ILNumerics.InCell"/> respectively.</typeparam>
            <typeparam name="OutT">The type of the output arrays: <see cref="T:ILNumerics.OutArray`1"/>, <see cref="T:ILNumerics.OutLogical"/>, or <see cref="T:ILNumerics.OutCell"/> respectively.</typeparam>
            <typeparam name="RetT">The type of the output arrays: <see cref="T:ILNumerics.RetArray`1"/>, <see cref="T:ILNumerics.RetLogical"/>, or <see cref="T:ILNumerics.RetCell"/> respectively.</typeparam>
            <typeparam name="StorageT">The concrete type of the internal storage object, determining all array types involved. This is derived from <see cref="T:ILNumerics.Core.StorageLayer.BaseStorage`6"/>.</typeparam>
            <remarks>This class implements most of the abstract base class <see cref="T:ILNumerics.BaseArray"/> public API. It also implements the public (strongly typed) API for 
            mutable arrays and the non-volatile input array types (<see cref="T:ILNumerics.InArray`1"/>, ...).</remarks>
            <seealso cref="T:ILNumerics.Core.Arrays.ConcreteRetArray`6"/>
            <summary>
            General base class for array objects like <see cref="T:ILNumerics.Array`1"/> and similar arrays types. 
            </summary>
            <summary>
            General base class for array objects like <see cref="T:ILNumerics.Array`1"/> and similar arrays types. 
            </summary>
            <summary>
            General base class for array objects like <see cref="T:ILNumerics.Array`1"/> and similar arrays types. 
            </summary>
            <summary>
            General base class for array objects like <see cref="T:ILNumerics.Array`1"/> and similar arrays types. 
            </summary>
        </member>
        <member name="F:ILNumerics.Core.Arrays.ConcreteArray`6.m_storage">
            <summary>
            The internal storage reference.
            </summary>
        </member>
        <member name="F:ILNumerics.Core.Arrays.ConcreteArray`6.SizeOfT">
            <summary>
            Gets the number of bytes spanned by a single element of this array. 
            </summary>
            <remarks><para>This value corresponds to the value computed by <see cref="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)"/> with the following exceptions: 
            for <typeparamref name="T1"/> of 'bool' 1 is returned. Referencd types return <see cref="P:System.IntPtr.Size"/>.</para></remarks>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.Storage">
            <summary>
            Gives access to the storage object holding the actual data of this array. (Does not release RetArray.)
            </summary>
            <remarks><para>The following storage objects exist currently: <see cref="T:ILNumerics.Core.StorageLayer.Storage`1"/> 
            (used by <see cref="T:ILNumerics.Array`1"/> and Co.), <see cref="T:ILNumerics.Core.StorageLayer.LogicalStorage"/> 
            (used by <see cref="T:ILNumerics.Logical"/> and Co.), and <see cref="T:ILNumerics.Core.StorageLayer.CellStorage"/> 
            (used by <see cref="T:ILNumerics.Cell"/> and Co.).</para>
            <para>During normal use accessing the storage object of the array is commonly
            unneccessary. The direct utilization of these objects is left to the experienced 
            user.</para>
            <para>For <see cref="T:ILNumerics.RetArray`1"/> this getter does not release the storage object!
            In fact, this is the only exception of a public function not releasing this array!</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.MaxValue">
            <summary>
            Retrieves the maximum value among all elements of this array.
            </summary>
            <remarks><para>This property is defined on all arrays, regardless if the element type is comparable or not. 
            Therefore, it has been deprecated and should be replaced with <see cref="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{System.Double},System.Double@,System.Double@,System.Boolean)"/>
            which is only available on arrays of numeric element type.</para></remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{System.Double},System.Double@,System.Double@,System.Boolean)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.MinValue"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.MinValue">
            <summary>
            Retrieves the minimum value among all elements of this array.
            </summary>
            <remarks><para>This property is defined on all arrays, regardless if the element type is comparable or not. 
            Therefore, it has been deprecated and should be replaced with <see cref="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{System.Double},System.Double@,System.Double@,System.Boolean)"/>
            which is only available on arrays of numeric element type.</para></remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetLimits(ILNumerics.BaseArray{System.Double},System.Double@,System.Double@,System.Boolean)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.MaxValue"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.Size">
            <summary>
            Gets the dimension descriptor for this array. [readonly]
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.S">
            <summary>
            Gets the dimension descriptor for this array (readonly). This is an alias for <see cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.Size"/>.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.IsColumnVector">
            <summary>
            Determines whether this array represents a column vector.
            </summary>
            <remarks>An array is considered a column vector when all elements are stored in the 
            first dimension (dimension index 0).</remarks>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.IsComplex">
            <summary>
            Returns true if elements of this array store a real and an imaginary part each. 
            </summary>
            <remarks>Currently, the element types <see cref="T:ILNumerics.complex"/>, <see cref="T:ILNumerics.fcomplex"/>, 
            and <see cref="T:System.Numerics.Complex"/> are considered here .</remarks>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.IsEmpty">
            <summary>
            Determines whether this array stores no elements. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.IsMatrix">
            <summary>
            Determines whether this array is a matrix. 
            </summary>
            <remarks>A matrix has less than three dimensions.</remarks>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.IsNumeric">
            <summary>
            Gets whether this array stores elements of a numeric type.
            </summary>
            <remarks>The list of such types considered 'numeric': <see cref="T:System.Double"/>, 
            <see cref="T:System.Single"/>
            <see cref="T:ILNumerics.complex"/>
            <see cref="T:ILNumerics.fcomplex"/>
            <see cref="T:System.Numerics.Complex"/>
            <see cref="T:System.Byte"/>
            <see cref="T:System.SByte"/>
            <see cref="T:System.Char"/>
            <see cref="T:System.Int16"/>
            <see cref="T:System.Int32"/>
            <see cref="T:System.Int64"/>
            <see cref="T:System.UInt16"/>
            <see cref="T:System.UInt32"/>
            <see cref="T:System.UInt64"/>. All other types are considered 'not numeric'.
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.IsOfType``1">
            <summary>
            Tests if this base array stores elements of type <typeparamref name="ElementType"/>. 
            </summary>
            <typeparam name="ElementType">Type to test against the actual element type of this array.</typeparam>
            <returns>True if the elements of this array are of type <typeparamref name="ElementType"/>. False otherwise.</returns>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.IsRowVector">
            <summary>
            Gets whether this array represents a row vector [readonly].
            </summary>
            <remarks><para>An array is considered a row vector, if all of the following is true: 
            its first dimension (index 0) has lengths 1 and the array has more than one dimension
            and all elements are stored in the second dimension.</para>
            </remarks>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.Length"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.IsVector"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.IsColumnVector"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.IsScalar">
            <summary>
            Gets whether this array has exactly one element.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.IsVector">
            <summary>
            Determines if this array represents a vector. 
            </summary>
            <remarks>An array is considered a vector when one of the following is true: the array has exactly one dimension, 
            or the array has exactly one non-singleton dimension, or the 
            array has exactly 1 element.</remarks>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.Length">
            <summary>
            Gets the number of elements stored in the longest dimension [readonly].
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetElementType">
            <summary>
            Gets a <see cref="T:System.Type"/> object describing the element type <typeparamref name="T1"/>.
            </summary>
            <returns>The element <see cref="T:System.Type"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.ShortInfo">
            <summary>
            Converts this array into a short textual representation, displaying the type, shape and a few element values.
            </summary>
            <returns>A short textual representation of this array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.ShortInfo(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Short textual summary of this instance, select individual info components.
            </summary>
            <returns>String representation of type, size, values, storage order as requested.</returns>
            <remarks>The type of elements and the size of the array are displayed. If the array
            is scalar, its value is displayed next to the type.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetProfileInfo">
            <summary>
            Returns the performance profiling information of the last command writing to this array, if available.
            </summary>
            <returns>Profile times as counter of microseconds [s] or empty string.</returns>
            <remarks>The function returns 5 individual numbers, each representing the time span of a corresponding action
            during the execution of computation creating the array result. Each number measures the number of s since the 
            computation was triggered programmatically. The actions are as follows:  
            <para><list type="number"> 
            <item>when the computation identified by event is enqueued in a command-queue by the host (commonly 0).</item>
            <item>when the command has been submitted by the host to the device.</item>
            <item>when the computation starts execution on the device.</item>
            <item>when the computation has finished execution on the device.</item>
            <item>when the computation and any child commands enqueued by this computation on the device have finished execution.</item>
            </list></para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.ToStream(System.IO.Stream,System.String,ILNumerics.ArrayStreamSerializationFlags)">
            <summary>
            Convert and store content of this array into a stream. This function is obsolete.
            </summary>
            <param name="outStream"></param>
            <param name="format"></param>
            <param name="method"></param>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.ToString">
            <summary>
            Create textual description of this array. Limits the number of elements shown for very large arrays.
            </summary>
            <returns>String describing this array.</returns>
            <remarks><para>This function creates a textual representation of the array, describing the dimensionality, size and element values.</para>
            <para>Elements of this array are displayed in a tabular form, corresponding to slices/subarrays of the whole array. Each table contains the 
            elements along the first two dimension (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> equal to <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>), or along 
            the last two dimensions (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> equal to <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) respectively. Note, that 
            a column major- or respective row major order representation is used according to the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/> - the 
            storage order of the array itself is not considered! </para>
            <para>Very large arrays are abreviated so that no more than a certain number of elements are displayed per dimension. 
            This is achieved by displaying elements at the beginning and at the end of a respective dimension only. Furthermore, a hard limit according to the value of <see cref="P:ILNumerics.Settings.ToStringMaxNumberElements"/>
            applies. ILNumerics will try to respect this limit by limiting the number of elements displayed in any dimension. I.e. the value of 
            <see cref="P:ILNumerics.Settings.ToStringMaxNumberElementsPerDimension"/> is adjusted as necessary.</para>
            <para>The display is optimized for common numeric element types.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.ToString(System.UInt32,System.UInt32,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean,System.Nullable{System.Int32})"/>
            <seealso cref="P:ILNumerics.Settings.ToStringMaxNumberElements"/>
            <seealso cref="P:ILNumerics.Settings.ToStringMaxNumberElementsPerDimension"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.ToString(System.UInt32,System.UInt32,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Creates a textual representation of this array and allows to control display parameters.
            </summary>
            <param name="maxNumberElementsPerDimension">Maximum number of elements displayed for any dimension.</param>
            <param name="maxNumberElements">[Optional] Overall maximum number of elements displayed. Default: 10000. Use 0 to remove this limit.</param>
            <param name="style">[Optional] Show the elements in row major or column major order. Default: <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (i.e.: currently selected ArrayStyle).</param>
            <param name="showType">[Optional] Add a header info with the element type. Default: true.</param>
            <param name="showSize">[Optional] Add a header info with the arrays size. Default: true.</param>
            <param name="columnWidth">[Optional] Controls the width of element columns (number of characters). Default: (auto, depends on type).</param>
            <returns>String with the content of this array converted according to the given parameters.</returns>
            <remarks><para>The function converts this array into a string for interactive display, for informal display and for utilization in interactive debug sessions.</para>
            <para>Large arrays will be converted into a shorter form to save resources. The number of elements per dimension is limited to the value <paramref name="maxNumberElementsPerDimension"/>. 
            Per default only 50 elements are shown from each dimension; 25 from the beginning and 25 from the end of each dimension. The value for <paramref name="maxNumberElementsPerDimension"/>
            may be adjusted to create smaller or larger output. 0 as value for <paramref name="maxNumberElementsPerDimension"/> removed the limit and shows all elements up to the number 
            of <see cref="F:System.UInt32.MaxValue"/>.</para>
            <para>The parameter <paramref name="maxNumberElements"/> limits the overall number of elements displayed, regardless of the actual dimension lengths. This parameter 
            takes precedence over <paramref name="maxNumberElementsPerDimension"/>: if the array has too many dimensions and displaying all elements would exceed the number given by <paramref name="maxNumberElements"/> 
            then the value of <paramref name="maxNumberElementsPerDimension"/> will automatically by adjusted (decreased) to keep the overall number of elements within the limits of <paramref name="maxNumberElements"/>.</para>
            <para>0 as value for <paramref name="maxNumberElements"/> removes the limit of overall number of elements for the output. In order to display all elements 
            of the array use <c>ToString(0,0)</c>. Caution: for very large arrays this may use a lot of resources and may take long!</para>
            <para>The elements of this array are displayed as "pages" or matrices. By default, and according to the current setting of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> these pages 
            visualize slices of the array along the first and second dimension (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>). Or the pages are created from the last two 
            dimensions (<see cref="F:ILNumerics.StorageOrders.RowMajor"/>). The <paramref name="style"/> parameter allows to explicitly control if the display should follow row major or 
            column major semantics.</para>
            <para>The parameters <paramref name="showSize"/> and <paramref name="showType"/> - if true - add a short info about the arrays size and type to the header (beginning) of the output.</para>
            <para><paramref name="columnWidth"/> allows to control the number of characters each element column of the output pages created will span. By default, this width 
            is automatically adjusted. For most numeric element types this width is 12.</para>
            <para>The signature of this function has been adjusted in version 5.4. The first parameter has been made [required]. The reason is that in some 
            cases the overload resolution of the C# compiler has been observed to fail to prefer the parameterless version of <see cref="M:System.Object.ToString"/> over this function. </para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.ToString"/>
            <seealso cref="P:ILNumerics.Settings.ToStringMaxNumberElements"></seealso>
            <seealso cref="P:ILNumerics.Settings.ToStringMaxNumberElementsPerDimension"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Dispose">
            <summary>
            Release this array after use. Cleans up on <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.Cell"/> and <see cref="T:ILNumerics.Logical"/> arrays 
            which are not inside a <see cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/> block.
            </summary>
            <remarks><para>This method is used in rare situations where no artificial scope exists around the current function body. Examples of 
            such situations are short <see cref="T:ILNumerics.Array`1"/>snippets in anonymous- or lambda functions, entry methods, or intended manual memory management.</para>
            <para>During 'normal' use the user places an artificial scope (<see cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/>) around the function body. All <see cref="T:ILNumerics.Array`1"/>, 
            <see cref="T:ILNumerics.Cell"/>, and <see cref="T:ILNumerics.Logical"/> arrays created within the scope block are automatically tracked and released once the scope block is left.</para>
            <para>Calling this method manually on local arrays as <see cref="T:ILNumerics.Array`1"/> &amp; Co. can be profitible in situations where no such scope block exists. 
            Otherwise, the memory would be reclaimed at some later point in time by the GC. <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Dispose"/> releases the array immediately. If no other 
            arrays are sharing the same memory, it will be released to the memory pool for immediate reusage.</para>
            <para>Note: failing to call <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Dispose"/> in such situations does not create a memory leak! But the array is only reclaimed 
            by the garbage collector and its memory is only freed by the finalization thread during the next GC collection. While this 
            is considered regular use, disposing the array manually is recommended in situations where high performance execution or 
            low memory consumption is required. </para>
            <para>Note further, that <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Dispose"/> is <b>not</b> required in 'common' array uses. I.e. when dealing with <see cref="T:ILNumerics.Array`1"/> 
            inside existing <see cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/> scope blocks or when a return value is utilized in some way (incl. assignment to <see cref="T:ILNumerics.Array`1"/>, 
            calling member functions on the return value or giving the return value to other functions as input parameter).</para></remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.Dispose"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.ReferenceCount">
            <summary>
            Gets the number of arrays currently sharing the storage with this array.
            </summary>
            <remarks>Mutable arrays (<see cref="T:ILNumerics.Array`1"/>) can only be modified when no other arrays share 
            the same storage. This will be true for <see cref="T:ILNumerics.Array`1"/> in regular use and can be verified 
            by reading the <see cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.ReferenceCount"/> property. In order for mutable arrays to allow modifications
            <see cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.ReferenceCount"/> must be 1.</remarks>
            <seealso cref="!:Array&lt;T&gt;.Dispose()"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetEnumerator">
            <summary>
            Enumerator returning elements as <typeparamref name="T1"/> in column major order. 
            </summary>
            <remarks><para>This standard iterator returns an <see cref="T:System.Collections.Generic.IEnumerator`1"/> and can be 
            used to iterate the elements of A along the rows. It is convenient for 
            using the <see cref="T:ILNumerics.Array`1"/> in foreach loops.</para>
            <para>If you require more control over the order of iteration use one of the [Array{T}].Iterator() 
            extension methods instead.</para></remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.BaseArray{System.Double},System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.ExportValues(`0[]@,ILNumerics.StorageOrders)">
             <summary>
             (Expert API) Export (copy) values into System.Array.
             </summary>
             <param name="result">System.Array with a copy of all element values from this array.</param>
             <param name="layout">[Optional] The storage layout of the elements to write to <paramref name="result"/>.</param>
             <remarks>The System.Array can be predefined. If its length is sufficient, it will be used and 
             its leading elements will be overwritten when function returns. If <paramref name="result"/> is null or has too few elements, 
             it will be recreated from the _GC managed heap_.
             <para>Excessive use of this method can be a hint of suboptimal design! Especially if no array /no sufficiently long 
             array is provided in <paramref name="result"/> the returned array will be created on the managed heap. 
             This works around the ILNumerics memory management and may increases the pressure on the GC and can lead to 
             frequent garbage collections and bad performance! Make sure to reuse the array <paramref name="result"/>.</para>
            <para>If<paramref name="layout"/> is <c>null</c> or<see cref="F:ILNumerics.StorageOrders.Other"/> the storage layout of this 
             array will be used to store the elements into <paramref name="result"/>.
             Make sure that the array <paramref name="result"/> is large enough, even if the current storage layout corresponds 
             to non-continously stored elements and may contain holes! Use <see cref="M:ILNumerics.Size.GetElementSpan"/> to compute 
             the absolute number of elements in <paramref name="result"/> necessary to hold all elements of this storage in its current
             storage order. Note further, that any potential holes in the element storage will not be cleared!</para>   
             <para>Exporting values of <see cref="T:ILNumerics.Cell"/> arrays gives a clone of the individual cell elements. Special care must be 
             taken when working with arrays of type <see cref="T:ILNumerics.BaseArray"/>. Its use is not recommended! Failing to handle BaseArray 
             instances properly may result in additional memory pressure, increased GC activation and unexpected <see cref="T:System.NullReferenceException"/>
             when accessing (automatically) disposed BaseArray objects.</para>
             <para>If - for some reasons - one needs to use <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.ExportValues(`0[]@,ILNumerics.StorageOrders)"/> on <see cref="T:ILNumerics.Cell"/>
             arrays nevertheless the following hints may serve as a rough guideline:</para>
             <list type="bullet">
             <item>Objects returned in <paramref name="result"/> are return type objects or null. Return type objects will dispose their
             content and itself after the first use. Make sure to <i>utilize</i> each object exactly once!</item>
             <item>Directly using an object in <paramref name="result"/> multiple times may give an error or unwanted side effects.</item>
             <item>In order to work with or to access a returned object multiple times it must be (immediately) converted to a local array of the 
             corresponding kind: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.Logical"/>, or <see cref="T:ILNumerics.Cell"/>. This, if course, requires knowledge 
             of the actual type of the object from within the cell.</item>
             <item>Failing to <i>use</i> the array at least once may leaves references to other data arrays (memory handles) open. 
             This may causes memory pressure on the GC and bad performance. However, in ILNumerics memory leaks (as for native languages) 
             cannot happen.</item>
             </list>
             </remarks>
             <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.IsOfType``1"/>
             <seealso cref="M:ILNumerics.ExtensionMethods.IsTypeOf``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64)"/>
             <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
             <seealso cref="T:ILNumerics.ExtensionMethods"/>
             <seealso cref="M:ILNumerics.ExtensionMethods.GetArray``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.BaseArray,ILNumerics.Cell,ILNumerics.InCell,ILNumerics.OutCell,ILNumerics.RetCell,ILNumerics.Core.StorageLayer.CellStorage},System.Int64,System.Int64)"/>
             <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64,System.Int64)"/>
             <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetArrayForRead(ILNumerics.StorageOrders)">
            <summary>
            Gets a copy of the array elements for <b>read access</b>.
            </summary>
            <param name="order">[Optional] The order used for copying the elements into the returned System array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Managed System.Array with copies of the elements contained in this ILNumerics array.</returns>
            <remarks><para>This method is provided for experts only! Use this array only for reading! Changes 
            will not populate back to the internal array storage. Note 
            the default element storage format: column major. </para>
            <para> Keep in mind, the length of the array may exceeds the number of elements! </para>
            <para>The range of elements addresses by this ILNumerics array starts with index 0 of the <see cref="T:System.Array"/> 
            returned. Any <see cref="P:ILNumerics.Size.BaseOffset"/> of this ILNumerics array is removed when copying the 
            elements to the managed array. The internal elements will be read in <paramref name="order"/>.</para>
            <para>The semantic of this method has changed with ILNumerics version 5. It now creates a 
            copy of the internal elements in column major element storage order layout. The copy uses 
            new memory from the regular, GC managed heap. This fact and the required memory copy 
            introduce a computational effort which disqualifies this method for high performance algorithms.</para>
            <para>The recommended way for experts to access internal elements directly, is now, to acquire a pointer 
            to the memory and to use the pointer in your unsafe code.</para>
            <para>In order to save the allocation of the managed array returned, consider using the method <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.ExportValues(`0[]@,ILNumerics.StorageOrders)"/>.</para>
            <para>The <paramref name="order"/> parameter allows to control the order of the elements returned. Valid 
            values are <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> and <see cref="F:ILNumerics.StorageOrders.RowMajor"/>. The default value is <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</para>
            <para>This method is now partly obsolete but it will remain here since it serves its purpose still: by copying 
            the elements one enables compatibility with other .NET APIs, at the same time it ensures that the 
            values returned will still be around and will not be affected by the cleanup mechanisms all internal 
            array storage is subject of. BUT: note the size limitation all <see cref="T:System.Array"/> in .NET undergo! 
            Attempts to acquire the elements of such arrays which exceed the maximum sizes of .NET objects will trigger an exception.</para>
            <para>The former versions (&lt; 5) method 'GetArrayForWrite()' has been replaced by <see cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.ExportValues(`0[]@,ILNumerics.StorageOrders)"/>
            <seealso cref="P:ILNumerics.Size.BaseOffset"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.ArgumentException">if <paramref name="order"/> is none of column major or row major.</exception>
            <exception cref="T:System.OutOfMemoryException">if this array is too large to fit into a managed array or if there is not enough memory currently available to allocate the return array.</exception>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [Expert API - UNSAFE!] Acquire a read pointer to the memory storing the first element of this array. 
            </summary>
            <param name="order">[Optional] Ensures that the array is in a specific storage layout before acquiring the pointer. Default: (null) don't change the storage layout.</param>
            <returns>Pointer to the first element of this array.</returns>
            <remarks>This function returns a pointer to the first element stored in this array. Any 
            base offset configured for the array is taken into account. The pointer points to the 
            memory used by this array directly - not to a copy of this memory!
            <para>Do not use this pointer for modifying the value of an element of this array! This 
            pointer is for <b>read purposes only!</b></para>
            <para>For empty arrays A (where A.<see cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.IsEmpty"/> is <c>true</c>) the value of the pointer returned is undefined.</para>
            <para>This pointer is valid only as long as this array is not modified or released! Do not 
            attempt to use this pointer after the array has been released, ran out of the current scope (meaning 
            the current function scope as well as <see cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/>), or is modified!</para>
            <para>The order of elements in this array is determined by the size descriptor <see cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.Size"/>. 
            Use the strides, dimension lengths and the size of the <typeparamref name="T1"/> elements (<see cref="F:ILNumerics.Core.Arrays.ConcreteArray`6.SizeOfT"/>)
            in order to compute the byte offset to individual elements relative to this pointer.</para>
            <para>The memory region addressed by the pointer returned exists on the <b>unmanaged</b> heap. 
            Hence, it does not need to be pinned and will not be moved by the GC. However, this memory 
            is subject of deterministic disposal, pooling and frequent reuse by other arrays. Do not use 
            the pointer returned after this array left the current function scope, was modified, reassigned or released!</para>
            <para>When <paramref name="order"/> is not null the storage order of the array is modified according 
            to <paramref name="order"/>. Valid values for <paramref name="order"/> are <see cref="F:ILNumerics.StorageOrders.RowMajor"/>, 
            <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>, and null. The <paramref name="order"/> parameter can be 
            convenient in order to access elements of non-continous array layouts. Instead of computing the address 
            of individual elements (<see cref="M:ILNumerics.Size.GetSeqIndex(System.Int64,System.Int64,System.Int64,System.Int64)"/>, or <see cref="M:ILNumerics.Size.GetStride(System.UInt32)"/>) 
            the array can be brought into a continous storage layout before acquiring the pointer. Afterwards, elements can 
            be accessed sequentially in memory, with unity strides. The price is the rearranging of the whole storage which 
            commonly requires a copy of all elements.</para>
            <para>This function may imply a copy operation from device specific memory onto host memory. This copy - if required - will
            be performed transparently to the user. The copy is done synchronously, i.e.: when the function returns the pointer
            returned will be valid. The user is not required to wait for asynchronous operations.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException"> if called on a return type array or if the elements are not of a <see cref="T:System.ValueType"/>.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetArrayForRead(ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="P:ILNumerics.Size.BaseOffset"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.C">
            <summary>
            Create lazy, shallow clone of this array. 
            </summary>
            <returns>An array which acts as a lazy, shallow copy of this array.</returns>
            <remarks>The array returned is of the same size and type.
            <para>The copy is done in a lazy manner. This means, the new array shares the memory 
            with this array. Only when attempting to <b>alter</b> the new array it will 
            be copied and use new memory then.</para></remarks>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteArray`6.T">
            <summary>
            Return transposed version of this array.
            </summary>
            <remarks>
            <para>For arrays having <see cref="P:ILNumerics.Size.NumberOfDimensions"/> &lt; 2 <see cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.T"/> returns the same array.</para>
            <para>For matrices, <see cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.T"/> swaps columns with rows. </para>
            <para>For arrays and if <see cref="P:ILNumerics.Settings.ArrayStyle"/> is <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>, the 
            dimensions are shifted by one. For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/> the 
            behavior is similar to (but more efficient than) calling <see cref="M:ILNumerics.Size.SwapDimensions"/> on a copy of this array.</para>
            <para>Note, for complex elements, <b>no</b> conjugate is created! Use conj(A.T) if this is intended.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Equals(System.Object)">
            <summary>
            Test if this array equals another array.
            </summary>
            <param name="obj">The other array.</param>
            <returns>True if the element type, all element values and dimension sizes match, false otherwise.</returns>
            <remarks><para>The comparison returns true if both arrays are of the same type, have the same shape and if all element values match.</para>
            <para>Note, that the <see cref="P:ILNumerics.Size.StorageOrder"/> of the arrays is not considered for the comparison. This way 
            it is perfectly legal for two arrays to return <c>true</c> while one array is stored in, let's say: 
            <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> and the other array is ordered along the rows (<see cref="F:ILNumerics.StorageOrders.RowMajor"/>). 
            However, all elements at matching sequencial positions / with matching indices in the flattened array must equal in order to return true.</para>
            <para>Singleton dimensions are ignored. As one consequence, <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Equals(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})"/>  and 
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Equals(System.Object)"/> accept two vectors even if the orientations do not match. A row vector 
            with the same element values than another column vector of the same lengths are considered to be equal to each other.</para>
            <para><b>This function returns <c>true</c> for empty arrays of the same shape and element type. It always returns 
            <c>true</c> when used on an array with itself as parameter <paramref name="obj"/>.</b></para>
            <para>Comparing <see cref="T:System.ValueType"/> of type <typeparamref name="T1"/> as <paramref name="obj"/> returns <c>true</c>
            if this array is scalar (i.e.: it has exactly one element) and the value of the only element equals the value of 
            the provided scalar.</para>
            <para>For floating point element types <typeparamref name="T1"/> the comparison is made on the byte-level. Thus, only exact 
            matches are considered 'equal'. Therefore, this function is not intended to compare the results of such floating point
            operations which are subject of rounding errors. Consider computing the absolute distance of both floating point results 
            instead and compare this to the eps value of the floating point data type with appropriate precision and scaling.</para>
            <para><see cref="F:System.Double.NaN"/> values are never equal to itself or any other value.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Equals(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.Size"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="P:ILNumerics.Size.StorageOrder"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Equals(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>
            Test if this array equals another array.
            </summary>
            <param name="A">The other array.</param>
            <returns>True if the element type, all element values and dimension sizes match, false otherwise.</returns>
            <remarks><para>The comparison returns true if both arrays are of the same type, have the same 
            shape and if all element values match.</para>
            <para>Note, that the <see cref="P:ILNumerics.Size.StorageOrder"/> of the arrays is not considered for the comparison. This way 
            it is perfectly legal for two arrays to return <c>true</c> while one array is stored in, let's say: 
            <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> and the other array is ordered along the rows (<see cref="F:ILNumerics.StorageOrders.RowMajor"/>)
            storage layout. However, all elements at matching <i>sequencial</i> positions / with matching indices 
            in a <i>flattened</i> version of the array must equal in order to return <c>true</c>.</para>
            <para>Singleton dimensions are ignored! As one consequence, <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Equals(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})"/> 
            and <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Equals(System.Object)"/> accept two vectors as input argument and can return <c>true</c> even 
            if the orientations do not match. A row vector with the same element values than another column vector 
            of the same lengths are considered equal to each other.</para>
            <para>Comparing <see cref="T:System.ValueType"/> of type <typeparamref name="T1"/> as <paramref name="A"/> returns <c>true</c>
            if this array is scalar (i.e.: it has exactly one element) and the value of the only element equals the value of 
            the provided scalar.</para>
            <para><b>This function returns <c>true</c> for empty arrays of the same shape and element type.</b></para>
            <para>For floating point element types <typeparamref name="T1"/> the comparison is made on the byte-level. Thus, only exact 
            matches are considered 'equal'. Therefore, this function is not intended to compare the results of such floating point
            operations which are subject of rounding errors. Consider computing the absolute distance of both floating point results 
            instead and compare this to the eps value of the floating point data type with appropriate precision and scaling.</para>
            <para><see cref="F:System.Double.NaN"/> values are never equal to itself or any other value.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Equals(System.Object)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.Size"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="P:ILNumerics.Size.StorageOrder"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHashCode">
            <summary>
            Generate a hash code based on the current values.
            </summary>
            <returns>Hash code</returns>
            <remarks>The hashcode is created by taking the values currently stored in the array into account.
            Therefore, the function iterates over all elements in the array - which makes it somehow an expensive 
            operation. Take this into account if you consider using large arrays in collections like dictionaries 
            or hash tables, which make great use of such hash codes.
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Finish">
            <summary>
            Waits for any pending operation writing to this array.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.T_get(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>
            Return transposed version of this array.
            </summary>
            <remarks>For matrices, this swaps columns with rows. For arrays, the dimensions are shifted by one.
            <para>Note, for complex elements, <b>no</b> conjugate is created! Use conj(A.T) if this is intended.</para>
            <para>The storage format of the array returned depends on the original storage format. Matrices stored in 
            column major format will produce row major matrices and vice versa. Note that the storage format for vectors
            (1 dimensional arrays) will not change since it is the same for both formats.</para>
            <para>The transpose is executed by modifying the size descriptor (swapping dimensions and strides) only.</para>
            <para>If possible and when performed on return type arrays the transposed array will be the result 
            of mutating the size descriptor of the original array directly. Hence, the same array is returned after performing 
            the transpose 'in-place'. 'Possible' here refers to the original arrays memory being referenced by 
            no other arrays.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_Explicit(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})~`0">
            <summary>
            Cast scalar array to system value type.
            </summary>
            <param name="a">Source array.</param>
            <exception cref="T:System.InvalidCastException">if the source array <paramref name="a"/> is not scalar or null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_Addition(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>
            Elementwise addition operator on two numeric arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Array with result of A + B, with element type T.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such precautions exist and the 
            result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>T must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_Modulus(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>Elementwise modulo operator on two numeric arrays.</summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Array with result of A % B, with element type T.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such precautions exist and the 
            result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>T must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_Division(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>Elementwise division operator on two numeric arrays.</summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Array with result of A / B, with element type T.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such precautions exist and the 
            result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>T must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_Multiply(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>Elementwise multiplication operator on two numeric arrays.</summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Array with result of A * B, with element type T.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such precautions exist and the 
            result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>T must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_Subtraction(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>Elementwise subtraction operator on two numeric arrays.</summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Array with result of A - B, with element type T.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such precautions exist and the 
            result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>T must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_Equality(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>
            Elementwise 'equals' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with result of A == B.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>The input element type T1 must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_Inequality(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>Elementwise 'unequal to'  operator on two arrays.</summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the result of performing A != B.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>The input element type T1 must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_GreaterThan(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>Elementwise 'greater than'  operator on two arrays.</summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the result of performing A &gt; B.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>The input element type T1 must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_LessThanOrEqual(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>Elementwise 'lower or equal'  operator on two arrays.</summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the result of performing A  B.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>The input element type T1 must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_GreaterThanOrEqual(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>Elementwise 'greater or equal'  operator on two arrays.</summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the result of performing A  B.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>The input element type T1 must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_LessThan(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>Elementwise 'lower than' operator on two arrays.</summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the result of performing A &lt; B.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>The input element type T1 must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_BitwiseAnd(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>
            Binary, elementwise, bitwise/logical 'and' operator.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Array with result of A &amp; B, with element type <typeref name="T1"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such precautions exist and the 
            result of the binary operation is exactly the same as for operating the elements (<see href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/checked-and-unchecked">unchecked</see>) as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>T must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_ExclusiveOr(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>Elementwise bitwise 'xor' operator on two integer arrays.</summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Array with result of bitwise A xor B.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such precautions exist and the 
            result of the binary operation is exactly the same as for operating the elements (<see href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/checked-and-unchecked">unchecked</see>) as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>T must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_BitwiseOr(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>Elementwise bitwise 'or' operator on two integer arrays.</summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Array with result of bitwise A or B.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such precautions exist and the 
            result of the binary operation is exactly the same as for operating the elements (<see href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/checked-and-unchecked">unchecked</see>) as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>T must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_LeftShift(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},System.Int32)">
            <summary>Elementwise bitwise '<![CDATA[<<]]>' operator on two integer arrays.</summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Array with result of bit shifting elements of A by B.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such precautions exist and the 
            result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>T must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_RightShift(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},System.Int32)">
            <summary>Elementwise bitwise '<![CDATA[>>]]>' operator on two integer arrays.</summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Array with result of bit shifting elements of A by B.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such precautions exist and the 
            result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            <para>T must be a numeric value type, including <see cref="T:ILNumerics.complex"/> and <see cref="T:ILNumerics.fcomplex"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_LogicalNot(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>
            Logical negation operator.
            </summary>
            <param name="A">The input array.</param>
            <returns>Array with result of negating all elements, type <typeref name="T1"/>.</returns>
            <remarks><para>The operation is defined on Logical arrays only and corresponds to the ! operator on <see cref="T:System.Boolean"/>.</para>
            <para>If possible, the operation is performed 'inplace' by reusing the input array for the result.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_OnesComplement(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>
            Unary, bitwise negation operator.
            </summary>
            <param name="A">The input array.</param>
            <returns>Array with result of negating all elements, type <typeref name="T1"/>.</returns>
            <remarks><para>The operation is defined on integer arrays only and corresponds to the ~ operator on <see cref="T:System.Int32"/>.</para>
            <para>If possible, the operation is performed 'inplace' by reusing the input array for the result.</para>
            <para>Note, that ~ is not defined on floating point types and not on arrays of element type <see cref="T:System.UInt64"/>.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_UnaryNegation(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>
            Unary, elementwise negation operator.
            </summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having its elements negated (as if: multiplying by -1).</returns>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.op_Implicit(`0)~ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5}">
            <summary>
            Implicitly convert system scalar <paramref name="A"/> to a scalar array.
            </summary>
            <param name="A">Scalar value as <see cref="T:System.ValueType"/>.</param>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.UInt32[],System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Creates reshaped version, accepts dimension lengths as array.
            </summary>
            <param name="dimLengths">Lengths array.</param>
            <param name="order">Storage order for reading and writing</param>
            <returns>Reshaped array.</returns>
            <remarks><para>All dimensions of the target shape must be specified explicitly. In order to 
            infer one of the dimensions automatically, use <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[],System.Nullable{ILNumerics.StorageOrders})"/> instead.</para>
            <para>This function is tested for up to 7 dimensions only!</para>
            <para>This function is provided for such situations where the size / shape 
            of the target array is computed automatically. Here, it is convenient to 
            provide the dimension lengths as a single array parameter.</para>
            <para>The same limitations exist as for the overloads with individual dimension parameters.</para>
            </remarks>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[])"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape``1(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[],System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.ArgumentException"> if <paramref name="dimLengths"/> is null or longer than the maximum number of dimensions supported: <see cref="F:ILNumerics.Size.MaxNumberOfDimensions"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped, 1 dimensional version of this array. Flattens the array to a vector.
            </summary>
            <param name="d0">Length of the vector produced. This must be equal to <see cref="P:ILNumerics.Size.NumberOfElements"/> or a negative number.</param>
            <param name="order">[Optional] Storage order for the new array. Default: null (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>).</param>
            <returns>A new array with the same values as this array, lined up in a 1-dimensional vector.</returns>
            <remarks><para>The (redundant) parameter <paramref name="d0"/> indicates the number of elements along the first 
            dimension for the returned array. If <paramref name="d0"/> is positive, its value must equal the number of
            elements in this array. If <paramref name="d0"/> is negative, the correct number of elements is substituted automatically.</para>
            <para>The setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is taken into account. 
            Therefore - by default - the array returned will have 2 dimensions, since the default value for 
            <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is 2.</para>
            <para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array with a modified size descriptor.</para>
            </remarks>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape``1(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[],System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 0.</param>
            <param name="d1">Number of elements along dim 1.</param>
            <param name="order">[Optional] Storage order for the output array. Default: 
            null (Settings.DefaultStorageOrder).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array and uses another size descriptor only.</para>
            </remarks>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape``1(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[],System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 0.</param>
            <param name="d1">Number of elements along dim 1.</param>
            <param name="d2">Number of elements along dim 2.</param>
            <param name="order">[Optional] Storage order for the output array. Default: 
            null (Settings.DefaultStorageOrder).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array and uses another size descriptor only.</para>
            </remarks>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape``1(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[],System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 0.</param>
            <param name="d1">Number of elements along dim 1.</param>
            <param name="d2">Number of elements along dim 2.</param>
            <param name="d3">Number of elements along dim 3.</param>
            <param name="order">[Optional] Storage order for the output array. Default: 
            null (Settings.DefaultStorageOrder).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array and uses another size descriptor only.</para>
            </remarks>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape``1(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[],System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 0.</param>
            <param name="d1">Number of elements along dim 1.</param>
            <param name="d2">Number of elements along dim 2.</param>
            <param name="d3">Number of elements along dim 3.</param>
            <param name="d4">Number of elements along dim 4.</param>
            <param name="order">[Optional] Storage order for the output array. Default: 
            null (Settings.DefaultStorageOrder).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array and uses another size descriptor only.</para>
            </remarks>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape``1(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[],System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 0.</param>
            <param name="d1">Number of elements along dim 1.</param>
            <param name="d2">Number of elements along dim 2.</param>
            <param name="d3">Number of elements along dim 3.</param>
            <param name="d4">Number of elements along dim 4.</param>
            <param name="d5">Number of elements along dim 5.</param>
            <param name="order">[Optional] Storage order for the output array. Default: 
            null (Settings.DefaultStorageOrder).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array and uses another size descriptor only.</para>
            </remarks>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape``1(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[],System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 0.</param>
            <param name="d1">Number of elements along dim 1.</param>
            <param name="d2">Number of elements along dim 2.</param>
            <param name="d3">Number of elements along dim 3.</param>
            <param name="d4">Number of elements along dim 4.</param>
            <param name="d5">Number of elements along dim 5.</param>
            <param name="d6">Number of elements along dim 6.</param>
            <param name="order">[Optional] Storage order for the output array. Default: 
            null (Settings.DefaultStorageOrder).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for reading and writing. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array and uses another size descriptor only.</para>
            </remarks>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape``1(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[],System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[],System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Creates reshaped version, accepts dimension lengths as array.
            </summary>
            <param name="dimLengths">Lengths array.</param>
            <param name="order">[Optional] Storage order for reading and writing. Default: <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>, 
            depends on <see cref="P:ILNumerics.Settings.ArrayStyle"/>.</param>
            <returns>Reshaped array.</returns>
            <remarks>
            <para>This function is provided for such situations where the size / shape 
            of the target array is computed automatically. Here, it is convenient to 
            provide the dimension lengths as a single array parameter.</para>
            <para>The same limitations exist as for the overloads with individual dimension parameters.</para>
            </remarks>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape``1(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[],System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.ArgumentException"> if <paramref name="dimLengths"/> is null or longer than the maximum number of dimensions supported: <see cref="F:ILNumerics.Size.MaxNumberOfDimensions"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[])">
            <summary>
            Creates reshaped version of this array, accepts variable length arguments array.
            </summary>
            <param name="size">Size for the new array, can be provided as individual literals.</param>
            <returns>Reshaped array.</returns>
            <remarks><para>This function is provided for such situations where the size / shape 
            of the target array is computed automatically. Here, it is convenient to 
            provide the dimension lengths as a single array parameter.</para>
            <para>Also, a variable number of number literals are accepted ('params' argument list, C#).</para>
            <para>The same limitations exist as for the overloads with individual dimension parameters.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape``1(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[],System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.ArgumentException"> if <paramref name="size"/> is null or longer than the maximum number of dimensions supported: <see cref="F:ILNumerics.Size.MaxNumberOfDimensions"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape``1(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Creates reshaped version, accepts dimension lengths as array.
            </summary>
            <param name="dimLengths">Numeric array with target dimension lengths. null or an empty array creates a (0-D) scalar if possible.</param>
            <param name="order">Storage order for reading and writing</param>
            <returns>Reshaped array.</returns>
            <remarks><para>This function is provided for situations where the size / shape 
            of the target array is computed for unknown number of dimensions. Here, it is convenient to 
            provide the dimension lengths as a single array parameter.</para>
            <para>Empty <paramref name="dimLengths"/> leads to the creation of a 0-D scalar array, respecting the current settings 
            of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>, though.</para>
            <para>Elements of <paramref name="dimLengths"/> are interpreted as the target dimension lengths for the array returned.</para>
            <para>All but one element in <paramref name="dimLengths"/> must be positive. If one negative element is found
            the function will infer the required dimension length for the corresponding dimension from the other elements provided.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64[],System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.ArgumentException"> if <paramref name="dimLengths"/> is longer than the maximum number of allowed dimensions: <see cref="F:ILNumerics.Size.MaxNumberOfDimensions"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)">
            <summary>
            Retrieve the element addressed by the <i>sequential</i> index <paramref name="i"/>.
            </summary>
            <param name="i">Sequential index (1 dim), assuming <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> storage order.</param>
            <returns>Boxed copy of the element at position <paramref name="i"/> if the elements stored in this 
            array are structs. Otherwise a reference copy of the element at <paramref name="i"/> is returned.</returns>
            <remarks>This function provides a way to access element values of this untyped base array for 
            convenience reasons. It is needed in very rare cases only. Don't expect great performance 
            from using untyped functions like this! The recommended performant way is to use the strongly typed classes 
            (<see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.Cell"/>) and the corresponding typed 
            API functions only.
            <para>The element is found by 'sequential' index <paramref name="i"/>. This corresponds to the 
            position of the element in a flattened version of this array, where the flattening operation
            was performed in <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> storage order.</para>
            </remarks>
            <seealso cref="T:ILNumerics.Array`1"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Boolean},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(ILNumerics.InArray{System.Int64})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="T:ILNumerics.StorageOrders"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec)">
            <summary>
            Extract part from this array. Matlab and numpy indexing.
            </summary>
            <param name="d0">Range specification along the first dimension.</param>
            <returns>New array as vector with parts of this array elements as specified by <paramref name="d0"/>.</returns>
            <remarks><para>This method considers a single dimension specifier only. For multi-dimensional arrays 
            a flattened version is considered and the range <paramref name="d0"/> is extracted from the 
            flattened version. The term 'flatten' here means: reshaping the array to a 1-dimensional array by lining-up all 
            elements of the array in column major order.</para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is respected for the array returned.</para>
            <para>The setting <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. In <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) it allows <paramref name="d0"/> to refer to any element inside <i>all</i> dimensions of this array (and 
            not only inside this dimension) in the same manner as the 'linear indexing' feature known from 
            Matlab et al.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in <paramref name="d0"/> addresses 
            any elements outside the range of this array. I.e.: <paramref name="d0"/> 
            refers to a non-existing element. See <see cref="P:ILNumerics.Settings.ArrayStyle"/>.</exception>
            <exception cref="T:System.NotSupportedException"> if <paramref name="d0"/> attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="d0"/>
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="d0">Range specification along dimension #0.</param>
            <param name="d1">Range specification along dimension #1.</param>
            <returns>New array with parts of this array as specified by <paramref name="d0"/> and <paramref name="d1"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. In <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>Due to the simplicity of the specifiers <paramref name="d0"/>, ... the subarray creation is optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array. Only when trying to modify either one of this array 
            or the subarray a copy will be made.</para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is respected for the array returned.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="d0"/>,... addresses 
            a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="d0"/>,... attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="d0"/>
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="d0">Range specification along dimension #0.</param>
            <param name="d1">Range specification along dimension #1.</param>
            <param name="d2">Range specification along dimension #2.</param>
            <returns>New array with parts of this array as specified by <paramref name="d0"/> ... <paramref name="d2"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. In <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>Due to the simplicity of the specifiers <paramref name="d0"/>, ... the subarray creation is optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array. Only when trying to modify either one of this array 
            or the subarray a copy will be made.</para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is respected for the array returned.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="d0"/>,... addresses 
            a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="d0"/>,... attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="d0"/>
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="d0">Range specification along dimension #0.</param>
            <param name="d1">Range specification along dimension #1.</param>
            <param name="d2">Range specification along dimension #2.</param>
            <param name="d3">Range specification along dimension #3.</param>
            <returns>New array with parts of this array as specified by <paramref name="d0"/> ... <paramref name="d3"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. In <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>Due to the simplicity of the specifiers <paramref name="d0"/>, ... the subarray creation is optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array. Only when trying to modify either one of this array 
            or the subarray a copy will be made.</para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is respected for the array returned.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="d0"/>,... addresses 
            a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="d0"/>,... attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="d0"/>
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="d0">Range specification along dimension #0.</param>
            <param name="d1">Range specification along dimension #1.</param>
            <param name="d2">Range specification along dimension #2.</param>
            <param name="d3">Range specification along dimension #3.</param>
            <param name="d4">Range specification along dimension #4.</param>
            <returns>New array with parts of this array as specified by <paramref name="d0"/> ... <paramref name="d4"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. In <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>Due to the simplicity of the specifiers <paramref name="d0"/>, ... the subarray creation is optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array. Only when trying to modify either one of this array 
            or the subarray a copy will be made.</para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is respected for the array returned.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="d0"/>,... addresses 
            a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="d0"/>,... attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="d0"/>
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="d0">Range specification along dimension #0.</param>
            <param name="d1">Range specification along dimension #1.</param>
            <param name="d2">Range specification along dimension #2.</param>
            <param name="d3">Range specification along dimension #3.</param>
            <param name="d4">Range specification along dimension #4.</param>
            <param name="d5">Range specification along dimension #5.</param>
            <returns>New array with parts of this array as specified by <paramref name="d0"/> ... <paramref name="d5"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. In <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>Due to the simplicity of the specifiers <paramref name="d0"/>, ... the subarray creation is optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array. Only when trying to modify either one of this array 
            or the subarray a copy will be made.</para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is respected for the array returned.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="d0"/>,... addresses 
            a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="d0"/>,... attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="d0"/>
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="d0">Range specification along dimension #0.</param>
            <param name="d1">Range specification along dimension #1.</param>
            <param name="d2">Range specification along dimension #2.</param>
            <param name="d3">Range specification along dimension #3.</param>
            <param name="d4">Range specification along dimension #4.</param>
            <param name="d5">Range specification along dimension #5.</param>
            <param name="d6">Range specification along dimension #6.</param>
            <returns>New array with parts of this array as specified by <paramref name="d0"/> ... <paramref name="d6"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. In <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>Due to the simplicity of the specifiers <paramref name="d0"/>, ... the subarray creation is optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array. Only when trying to modify either one of this array 
            or the subarray a copy will be made.</para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is respected for the array returned.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="d0"/>,... addresses 
            a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="d0"/>,... attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="d0"/>
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec[])">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="dims">Range specification for arbitrary dimensions as vector.</param>
            <returns>New array with parts of this array as specified by <paramref name="dims"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. For example, in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>Due to the simplicity of the individual specifiers <paramref name="dims"/> the subarray creation is optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array. Only when trying to modify either one of this array 
            or the subarray a copy will be made.</para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (as controlled by <see cref="P:ILNumerics.Settings.ArrayStyle"/>) 
            is respected for the array returned.</para>
            <para>This overload of Subarray() allows to define range specifiers for individual dimensions as a system array. 
            It is convenient when subarrays are to be created without knowing the number of dimensions and the concrete
            range parameters in advance. It is not recommended for situations where high performance is crucial. Note, that 
            individual <see cref="T:ILNumerics.DimSpec"/> objects for each dimension addressed in <paramref name="dims"/> can be used in 
            exactly one call to <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec[])"/> and are released in the function automatically. Thus, when
            calling <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec[])"/> in loops make sure to recreate <i>all</i> dimension specifier prior to
            each call to <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec[])"/>.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="dims"/> addresses 
            a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="dims"/> attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="dims"/>[0]
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{ILNumerics.BaseArray},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray)">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <returns>New array with parts of this array as specified by <paramref name="d0"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. For example, in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>For simple dimension specifiers <paramref name="d0"/>,... the subarray creation is often optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array in this case. Only when trying to modify either 
            one of this array or the subarray a copy will be made. More complex subarray specifications may require 
            iterating and copying addressed elements into new memory. </para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (as controlled by <see cref="P:ILNumerics.Settings.ArrayStyle"/>) 
            is respected for the array returned.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="d0"/>,... 
            addresses a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="d0"/>,... attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="d0"/>
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <returns>New array with parts of this array as specified by <paramref name="d0"/>...<paramref name="d1"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. For example, in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>For simple dimension specifiers <paramref name="d0"/>,... the subarray creation is often optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array in this case. Only when trying to modify either 
            one of this array or the subarray a copy will be made. More complex subarray specifications may require 
            iterating and copying addressed elements into new memory. </para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (as controlled by <see cref="P:ILNumerics.Settings.ArrayStyle"/>) 
            is respected for the array returned.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="d0"/>,... 
            addresses a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="d0"/>,... attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="d0"/>
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <returns>New array with parts of this array as specified by <paramref name="d0"/>...<paramref name="d2"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. For example, in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>For simple dimension specifiers <paramref name="d0"/>,... the subarray creation is often optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array in this case. Only when trying to modify either 
            one of this array or the subarray a copy will be made. More complex subarray specifications may require 
            iterating and copying addressed elements into new memory. </para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (as controlled by <see cref="P:ILNumerics.Settings.ArrayStyle"/>) 
            is respected for the array returned.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="d0"/>,... 
            addresses a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="d0"/>,... attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="d0"/>
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <param name="d3">Range specification for dimension #3.</param>
            <returns>New array with parts of this array as specified by <paramref name="d0"/>...<paramref name="d3"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. For example, in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>For simple dimension specifiers <paramref name="d0"/>,... the subarray creation is often optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array in this case. Only when trying to modify either 
            one of this array or the subarray a copy will be made. More complex subarray specifications may require 
            iterating and copying addressed elements into new memory. </para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (as controlled by <see cref="P:ILNumerics.Settings.ArrayStyle"/>) 
            is respected for the array returned.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="d0"/>,... 
            addresses a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="d0"/>,... attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="d0"/>
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <param name="d3">Range specification for dimension #3.</param>
            <param name="d4">Range specification for dimension #4.</param>
            <returns>New array with parts of this array as specified by <paramref name="d0"/>...<paramref name="d4"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. For example, in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>For simple dimension specifiers <paramref name="d0"/>,... the subarray creation is often optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array in this case. Only when trying to modify either 
            one of this array or the subarray a copy will be made. More complex subarray specifications may require 
            iterating and copying addressed elements into new memory. </para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (as controlled by <see cref="P:ILNumerics.Settings.ArrayStyle"/>) 
            is respected for the array returned.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="d0"/>,... 
            addresses a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="d0"/>,... attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="d0"/>
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <param name="d3">Range specification for dimension #3.</param>
            <param name="d4">Range specification for dimension #4.</param>
            <param name="d5">Range specification for dimension #5.</param>
            <returns>New array with parts of this array as specified by <paramref name="d0"/>...<paramref name="d5"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. For example, in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>For simple dimension specifiers <paramref name="d0"/>,... the subarray creation is often optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array in this case. Only when trying to modify either 
            one of this array or the subarray a copy will be made. More complex subarray specifications may require 
            iterating and copying addressed elements into new memory. </para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (as controlled by <see cref="P:ILNumerics.Settings.ArrayStyle"/>) 
            is respected for the array returned.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="d0"/>,... 
            addresses a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="d0"/>,... attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="d0"/>
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <param name="d3">Range specification for dimension #3.</param>
            <param name="d4">Range specification for dimension #4.</param>
            <param name="d5">Range specification for dimension #5.</param>
            <param name="d6">Range specification for dimension #6.</param>
            <returns>New array with parts of this array as specified by <paramref name="d0"/>...<paramref name="d6"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. For example, in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>For simple dimension specifiers <paramref name="d0"/>,... the subarray creation is often optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array in this case. Only when trying to modify either 
            one of this array or the subarray a copy will be made. More complex subarray specifications may require 
            iterating and copying addressed elements into new memory. </para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (as controlled by <see cref="P:ILNumerics.Settings.ArrayStyle"/>) 
            is respected for the array returned.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="d0"/>,... 
            addresses a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="d0"/>,... attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="d0"/>
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])">
            <summary>
            Extract part of this array. Matlab and numpy indexing.
            </summary>
            <param name="dims">Range specification for arbitrary dimensions as vector of <see cref="T:ILNumerics.BaseArray"/>.</param>
            <returns>New array with parts of this array as specified by <paramref name="dims"/>.</returns>
            <remarks>
            <para>This method considers the given dimensional range specifiers to extract a subarray from this array. 
            Both indexing styles: <see cref="F:ILNumerics.ArrayStyles.numpy"/> and Matlab indexing (<see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>)
            are supported. For such indexing features specific to one or the other style the current setting of 
            <see cref="P:ILNumerics.Settings.ArrayStyle"/> is considered. For example, in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> 
            array style (default) the last given dimension specifier may refer to elements inside <i>merged, trailing, 
            unspecified</i> dimensions of this array (and not only inside this dimension) in the same manner as the 'linear indexing' 
            feature known from Matlab, Octave, <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4">ILNumerics version 4</see> et al.</para>
            <para>For simple dimension specifiers <paramref name="dims"/> the subarray creation is often optimized 
            to be fast and efficient, often without requiring new memory for copying elements. Note, that the array 
            returned may use the same element storage as this array in this case. Only when trying to modify either 
            one of this array or the subarray a copy will be made. More complex subarray specifications may require 
            iterating and copying addressed elements into new memory. </para>
            <para>The setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (as controlled by <see cref="P:ILNumerics.Settings.ArrayStyle"/>) 
            is respected for the array returned.</para>
            <para>This overload of Subarray() allows to define range specifiers for individual dimensions as a system array. 
            It is convenient when subarrays are to be created without knowing the number of dimensions and the concrete
            range parameters in advance. It is not recommended for situations where high performance is crucial. Note, that 
            individual <see cref="T:ILNumerics.BaseArray"/> objects for each dimension addressed in <paramref name="dims"/> can be used in 
            exactly one call to <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/> and are released in the function automatically. Thus, when
            calling <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/> in loops make sure to recreate <i>all</i> dimension specifier prior to
            every call to <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the range provided in a specifier <paramref name="dims"/> addresses 
            a non existing element.</exception>
            <exception cref="T:System.NotSupportedException"> if any of <paramref name="dims"/> attempts to use an indexing feature which 
            is not supported in the current <see cref="P:ILNumerics.Settings.ArrayStyle"/> mode. For example, if <paramref name="dims"/>[0]
            was provided as <see cref="F:ILNumerics.Globals.newaxis"/> while being in <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> mode.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
        </member>
        <member name="T:ILNumerics.Core.Arrays.ConcreteRetArray`6">
            <summary>
            This class serves internal purposes as the abstract base class for all 'return'-type arrays: <see cref="T:ILNumerics.RetArray`1"/>, <see cref="T:ILNumerics.RetLogical"/>, or <see cref="T:ILNumerics.RetCell"/> respectively..
            </summary>
            <typeparam name="T1">The element type.</typeparam>
            <typeparam name="LocalT">The type of the local arrays: one of <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.Logical"/> or <see cref="T:ILNumerics.Cell"/>.</typeparam>
            <typeparam name="InT">The type of the input arrays: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InLogical"/>, or <see cref="T:ILNumerics.InCell"/> respectively.</typeparam>
            <typeparam name="OutT">The type of the output arrays: <see cref="T:ILNumerics.OutArray`1"/>, <see cref="T:ILNumerics.OutLogical"/>, or <see cref="T:ILNumerics.OutCell"/> respectively.</typeparam>
            <typeparam name="RetT">The type of the output arrays: <see cref="T:ILNumerics.RetArray`1"/>, <see cref="T:ILNumerics.RetLogical"/>, or <see cref="T:ILNumerics.RetCell"/> respectively.</typeparam>
            <typeparam name="StorageT">The concrete type of the internal storage object, determining all array 
            types involved. This is derived from <see cref="T:ILNumerics.Core.StorageLayer.BaseStorage`6"/>.</typeparam>
            <remarks><para>This class implements most of the abstract base class <see cref="T:ILNumerics.BaseArray"/> public API. 
            It also implements the public (strongly typed) API for immutable return type arrays 
            (<see cref="T:ILNumerics.RetArray`1"/>, <see cref="T:ILNumerics.RetLogical"/>, ...).</para>
            <para>This class is necessary since 'return' type arrays have a slightly different implementation than other
            concrete array types. The main work is still done by delegating the function call to the storage objects and 
            its implementation. But return type-arrays must release themself after each public access.</para></remarks>
            <seealso cref="T:ILNumerics.Core.Arrays.ConcreteArray`6"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.EnterScope">
            <summary>
            Action called when this array is about to enter an artificial scope. 
            </summary>
            <returns>False, since return-type arrays are not recognized by artificial scopes.</returns>
            <see cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/>
            <see cref="T:ILNumerics.InArray`1"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteRetArray`6.Size">
            <summary>
            Gets the dimension descriptor for this array. [readonly]
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteRetArray`6.S">
            <summary>
            Gets the dimension descriptor for this array (readonly). This is an alias for <see cref="P:ILNumerics.Core.Arrays.ConcreteRetArray`6.Size"/>.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteRetArray`6.IsColumnVector">
            <summary>
            Determines whether this array has the shape of a column vector [n x 1].  
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteRetArray`6.IsComplex">
            <summary>
            Determines whether this array hosts complex elements. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteRetArray`6.IsEmpty">
            <summary>
            Determines whether this array has empty dimensions and no elements.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteRetArray`6.IsMatrix">
            <summary>
            Determines whether this array has not more than two dimensions.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteRetArray`6.IsNumeric">
            <summary>
            Determines whether the element type of this array <typeparamref name="T1"/> is a numeric value type.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.IsOfType``1">
            <summary>
            Tests if this array stores elements of type <typeparamref name="ElementType"/>. Does NOT release the array!
            </summary>
            <typeparam name="ElementType">Type to test against the actual element type of this array.</typeparam>
            <returns>True if the elements of this array are of type <typeparamref name="ElementType"/>. 
            False otherwise.</returns>
            <remarks><para>Regular dense arrays can be tested for a specific type by providing the assumed 
            element type as generic type parameter <typeparamref name="ElementType"/>.</para>
            <para>To test if an array is a logical array, provide <see cref="T:System.Boolean"/> as 
            <typeparamref name="ElementType"/>.</para>
            <para>In order to test for cell types an <typeparamref name="ElementType"/> of <see cref="T:ILNumerics.BaseArray"/>
            is to be provided.</para></remarks>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteRetArray`6.IsRowVector">
            <summary>
            Gets whether this array has the shape of a row vector, [1 x n]. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteRetArray`6.IsScalar">
            <summary>
            Gets whether this array has the shape of a scalar, a single element [1 x 1]. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteRetArray`6.IsVector">
            <summary>
            Gets whether this array is a row vector or a column vector. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteRetArray`6.Length">
            <summary>
            Gets the length of the longest dimension of this array or 0 if no such dimension exists. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.Dispose">
            <summary>
            Release this array after use. Cleans up on <see cref="T:ILNumerics.RetArray`1"/>, <see cref="T:ILNumerics.RetCell"/> and <see cref="T:ILNumerics.RetLogical"/> arrays which are not otherwise 'utilized'.
            </summary>
            <remarks>This method is used in rare situations where the return value from an ILNumerics method is not used. Let's say: the user 
            called a method with <see cref="T:ILNumerics.OutArray`1"/> parameters and only the output parameter value is needed. If the 
            method has a regular return value (<see cref="T:ILNumerics.RetArray`1"/>) this is not released automatically: return values are automatically 
            released after they are used for the _first time_. In order to release the array and to reclaim its storage call <see cref="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.Dispose"/> on it.
            <para>Note: failing to call <see cref="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.Dispose"/> in such situations does not create a memory leak. But the array is only reclaimed 
            by the garbage collector and its memory is only freed by the finalization thread during the next GC collection. While this 
            is considered valid use, disposing the array manually is recommended in situations where high performance execution and/or 
            low memory consumption is required. </para>
            <para>Note further, that <see cref="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.Dispose"/> is <b>not</b> required in 'common' array uses. I.e. when dealing with <see cref="T:ILNumerics.Array`1"/> 
            inside existing <see cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/> scope blocks or when the return value is utilized in some way (incl. assignment to <see cref="T:ILNumerics.Array`1"/>, 
            calling member functions on the return value or giving the return value to other functions as input parameter).</para></remarks>
            <example><code><![CDATA[
            Array<double> A = rand(10); 
            Array<long> I = 1; 
            sort(A, Indices: I).Dispose(); // <- cleaning up manually
            ]]></code>
            <para>Here, we only access the output parameter I of the sort function. The array returned 
            from sort(A, I) as the return value is not used, thus it is not released automatically. 
            In order to free its resources immediately, one can call Dispose() on the returned array. 
            Note, that no memory leak is produced without manually calling Dispose(). The array would 
            be cleaned up by the GC instead. For best performance, however, it is recommended to call 
            Dispose() here.</para>
            </example>
            <seealso cref="T:ILNumerics.Core.Arrays.ConcreteRetArray`6"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.Dispose"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Release"/>
            <seealso cref="P:ILNumerics.BaseArray.IsDisposed"/>
            <seealso cref="T:ILNumerics.Core.Arrays.IVolatile"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.GetElementType">
            <summary>
            Gets a <see cref="T:System.Type"/> object describing the element type <typeparamref name="T1"/>.
            </summary>
            <returns>The element <see cref="T:System.Type"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.ShortInfo">
            <summary>
            Short textual summary of this instance, used for debug output.
            </summary>
            <returns>String representation of type and size</returns>
            <remarks>The type of elements and the size of the array are displayed. If the array
            is scalar, its value is displayed next to the type.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.ToStream(System.IO.Stream,System.String,ILNumerics.ArrayStreamSerializationFlags)">
            <summary>
            Write values of this instance to a stream. 
            </summary>
            <param name="outStream">Stream to write the values into.</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
            <param name="method">A constant out of <see cref="T:ILNumerics.ArrayStreamSerializationFlags"/>. Specifies the way 
            the values will be serialized.</param>
            <remarks><para>If method 'Formatted' is used, any occurences of NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style for the output.</para>
            <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as 
            the array name for writing. This array instance will be the only array in the mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream. Or use the classes in the 
            <see cref="N:ILNumerics.IO.HDF5"/> namespace to create a HDF5 format file (recommended).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.ToString">
            <summary>
            Convert this array to a string.
            </summary>
            <returns>String representation of the content and shape of this array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.Retain">
            <summary>
            Retain this array. A NOP for return arrays...
            </summary>
            <remarks><para>On a ret array, calling <see cref="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.Retain"/> does not have any effect since the call 
            would trigger an immediate <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Release"/>.</para></remarks>
        </member>
        <member name="P:ILNumerics.Core.Arrays.ConcreteRetArray`6.ReferenceCount">
            <summary>
            Counts the number of arrays currently referencing (sharing) the storage of this array. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.GetEnumerator">
            <summary>
            Gives an enumerator returning elements of this array as <typeparamref name="T1"/>. 
            </summary>
            <remarks><para>This function enables ILNumerics arrays to be used in 'foreach' constructs (C#).</para>
            <para>The iteration is performed in the natural order of storage (column major storage) over all 
            elements of this array.</para>
            <para>Return-type arrays are automatically released after the iteration of the elements was completed or canceled. 
            In order for this to work properly one has to use foreach() on the array directly or make sure to 
            dispose the enumerator returned here after finishing iterating the values. What foreach does automatically -
            in the case of manually using IEnumerator{T}.MoveNext() the <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Release"/> call will only be performed
            <i>after all</i> values have been iterated! So one must dispose the enumerator explicitly when 
            the iteration is cancelled prematurely by calling <c>enumerator.Dispose()</c>. Again, this is 
            not necessary when foreach() is used.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.ExportValues(`0[]@,ILNumerics.StorageOrders)">
             <summary>
             Export (copy) values into System.Array.
             </summary>
             <param name="result">System.Array with a copy of all element values from this array.</param>
             <param name="layout">[Optional] The storage layout of the elements to write to <paramref name="result"/>.</param>
             <remarks>The System.Array should be predefined. If its length is sufficient, it will be used and 
             its leading elements will be overwritten when function returns. If <paramref name="result"/> is null or has too few elements, 
             it will be recreated from the _GC managed heap_.
             <para>Excessive use of this method can be a hint of suboptimal design! Especially if no array /no sufficiently long 
             array is provided in <paramref name="result"/> the returned array will be created on the managed heap. 
             This works around the ILNumerics memory management and may increases the pressure on the GC and can lead to 
             frequent garbage collections and bad performance! Make sure to reuse the array <paramref name="result"/>.</para>
            <para>If<paramref name="layout"/> is <c>null</c> or<see cref="F:ILNumerics.StorageOrders.Other"/> the storage layout of this 
             array will be used to store the elements into <paramref name="result"/>.
             Make sure that the array <paramref name="result"/> is large enough, even if the current storage layout corresponds 
             to non-continously stored elements and may contain holes! Use <see cref="M:ILNumerics.Size.GetElementSpan"/> to compute 
             the absolute number of elements in <paramref name="result"/> necessary to hold all elements of this storage in its current
             storage order. Note further, that any potentially existing holes in the element storage will not be cleared!</para>        
             </remarks>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.GetArrayForRead(ILNumerics.StorageOrders)">
            <summary>
            Gets a copy of the array elements for <b>read access</b>.
            </summary>
            <param name="order">[Optional] The order used for copying the elements into the returned System array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Managed System.Array with copies of the elements contained in this ILNumerics array.</returns>
            <remarks><para>This method is provided for experts only! Use this array only for reading! Changes 
            will not populate back to the internal array storage. Note 
            the default element storage format: column major. </para>
            <para> Keep in mind, the length of the array may exceeds the number of elements! </para>
            <para>The range of elements addresses by this ILNumerics array starts with index 0 of the <see cref="T:System.Array"/> 
            returned. Any <see cref="P:ILNumerics.Size.BaseOffset"/> of this ILNumerics array is removed when copying the 
            elements to the managed array. The internal elements will be read in <paramref name="order"/>.</para>
            <para>The semantic of this method has changed with ILNumerics version 5. It now creates a 
            copy of the internal elements in column major element storage order layout. The copy uses 
            new memory from the regular, GC managed heap. This fact and the required memory copy 
            introduce a computational effort which disqualifies this method for high performance algorithms.</para>
            <para>The recommended way for experts to access internal elements directly, is now, to acquire a pointer 
            to the memory and to use the pointer in your unsafe code.</para>
            <para>In order to save the allocation of the managed array returned, consider using the method <see cref="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.ExportValues(`0[]@,ILNumerics.StorageOrders)"/>.</para>
            <para>The <paramref name="order"/> parameter allows to control the order of the elements returned. Valid 
            values are <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> and <see cref="F:ILNumerics.StorageOrders.RowMajor"/>. The default value is <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</para>
            <para>This method is now partly obsolete but it will remain here since it serves its purpose still: by copying 
            the elements one enables compatibility with other .NET APIs, at the same time it ensures that the 
            values returned will still be around and will not be affected by the cleanup mechanisms all internal 
            array storage is subject of. BUT: note the size limitation all <see cref="T:System.Array"/> in .NET undergo! 
            Attempts to acquire the elements of such arrays which exceed the maximum sizes of .NET objects will trigger an exception.</para>
            <para>The former versions (&lt; 5) method 'GetArrayForWrite()' has been replaced by <see cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.ExportValues(`0[]@,ILNumerics.StorageOrders)"/>
            <seealso cref="P:ILNumerics.Size.BaseOffset"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.ArgumentException">if <paramref name="order"/> is none of column major or row major.</exception>
            <exception cref="T:System.OutOfMemoryException">if this array is too large to fit into a managed array or if there is not enough memory currently available to allocate the return array.</exception>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [Invalid] This method cannot be used on return type arrays! Create a local array instead! Acquire the pointer elements from the local array then. 
            </summary>
            <returns>This function always throws an exception when called on return type array.</returns>
            <remarks><para>This function is defined on return type arrays. Its sole purpose is to invalidate 
            the corresponding function of the base class <see cref="T:ILNumerics.Core.Arrays.ConcreteArray`6"/>. 
            Since return type arrays are released after the first use, returning a pointer to its elements
            as this only 'use' would immediately render the pointer invalid. Hence, this function will throw
            an exception when called on return type arrays.</para>
            <para>Consider assigning the return type array to a local array <see cref="T:ILNumerics.Array`1"/> (<see cref="T:ILNumerics.Logical"/>) and call 
            this function on the local array instead.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException"> is always thrown when this function is called on a return type array (RetArray{T} &amp; Co).</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.GetArrayForRead(ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.Equals(System.Object)">
            <summary>
            Compare elements and shape of this array with another array.
            </summary>
            <param name="A">Other array</param>
            <returns>true if shape and element values of both arrays match, false otherwise</returns>
            <remarks><para>'Equals' accepts two vectors even if the orientations do not match. Therefore, a row vector 
            with the same element values than another column vector of the same lengths are considered to be equal to each other.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.GetHashCode">
            <summary>
            Generate a hash code based on the current arrays values
            </summary>
            <returns>Hash code</returns>
            <remarks>The hashcode is created by taking the values currently stored in the array into account.
            Therefore, the function iterates over all elements in the array - which makes it somehow an expensive 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hash tables, which make great use of such hash codes.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.GetItem(System.Int64)">
            <summary>
            Retrieve the value of the element addressed by the sequential index in <paramref name="i"/>.
            </summary>
            <param name="i">Sequential index (1 dim), taking the striding (<see cref="P:ILNumerics.BaseArray.Size"/>) of 
            this array into account.</param>
            <returns>Boxed copy of the element at position <paramref name="i"/> if the elements stored in this 
            array are structs. Otherwise a reference copy of the element at <paramref name="i"/> is returned.</returns>
            <remarks>This function provides a way to access element values of this untyped base array for 
            convenience reasons. It is needed in very rare cases only. Don't expect great performance 
            from using untyped functions like this! The recommended performant way is to use the strongly typed classes 
            (<see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.Cell"/>) and the corresponding typed 
            API functions only.
            <para><paramref name="i"/> refers to the position of the element whos value to retrieve, where the 
            position is considered the index of the same element when lining all elements up in 
            <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> order.</para></remarks>
            <seealso cref="T:ILNumerics.Array`1"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
        </member>
        <member name="T:ILNumerics.Core.Arrays.IVolatile">
            <summary>
            Interface used to identify volatile array instances (<see cref="T:ILNumerics.RetArray`1"/>,<see cref="T:ILNumerics.RetCell"/>, <see cref="T:ILNumerics.RetLogical"/>).
            </summary>
        </member>
        <member name="T:ILNumerics.Core.Arrays.Mutable`6">
            <summary>
            Base class for all mutable array types. Internal use.
            </summary>
            <typeparam name="T1">The element type.</typeparam>
            <typeparam name="LocalT">The local array type of this array type set. </typeparam>
            <typeparam name="InT">The input array type of this array type set.</typeparam>
            <typeparam name="OutT">The output array type of this array type set.</typeparam>
            <typeparam name="RetT">The return array type of this array type set.</typeparam>
            <typeparam name="StorageT">The storage type of this array type set.</typeparam>
            <summary>
            Base class for all mutable array types. Internal use.
            </summary>
            <summary>
            Base class for all mutable array types. Internal use.
            </summary>
            <summary>
            Base class for all mutable array types. Internal use.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.shape">
            <summary>
            [numpy API] The dimension lengths as ILNumerics vector of length corresponding to <see cref="P:ILNumerics.Size.NumberOfDimensions"/>.
            </summary>
            <remarks><para>This property allows to query the dimension lengths as an ILNumerics vector. The vector returned will have 
            at least (<see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>) one dimension with the dimension lengths of this array as elements. Numpy scalars return an empty vector.</para>
            <para>For mutable arrays the shape can also be changed inplace by assigning to this property. Changing the shape is only allowed 
            for mutable arrays which are in a suitable state: the storage must be continously layed out, the number of elements must not change.</para>
            <para>Immutable arrays do not expose a setter property / function for the shape attribute.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.InvalidOperationException"> if this array is currently shared with multiple instance. For example, if it is in use 
            by an instance of <see cref="T:ILNumerics.InArray`1"/> as function parameter and the function has not returned yet. Applying the ILNumerics function 
            rules prevent from such situations commonly.</exception>
            <exception cref="T:System.ArgumentException"> if trying to assign a vector having too many elements, having negative elements, 
            if the new dimensions specified would result in a different number of elements than <see cref="P:ILNumerics.Size.NumberOfElements"/>, or if the storage 
            of this array cannot be reshaped without copying elements (<see cref="P:ILNumerics.Size.IsContinuous"/> is false).</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.strides">
            <summary>
            [numpy API] The strides of elements within the dimensions. Unit: element size.
            </summary>
            <remarks>Elements within a dimension of ILNumerics arrays are separated in memory by a certain, fixed address offset. This offset is 
            the same for all elements within the same dimension. The array returned gives this offset for each dimension of this array.
            <para>Note that the unit of the distance is the <i>element size</i>, i.e. the number of bytes consumed by a single element. In difference 
            to that, the numpy attribute <see href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.strides.html#numpy.ndarray.strides"/> 
            gives this distance in <i>bytes</i>.</para>
            <para>This attribute is readonly.</para></remarks>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.itemsize"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.shape"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.ndim">
            <summary>
            [numpy API] The number of dimensions stored for this array.
            </summary>
            <remarks><para>This readonly attribute is an alias for <see cref="P:ILNumerics.Size.NumberOfDimensions"/>.</para></remarks>
            <seealso cref="P:ILNumerics.Size.NumberOfDimensions"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.data">
            <summary>
            [numpy API][Expert API!] Gives a reference to the memory handle used to store elements of this array on the host. 
            </summary>
            <remarks><para>The memory handle returned gives access to the memory used to store the arrays data. In order 
            to read and/or write from / to this memory one must take many considerations into account, including but not 
            limited to: <see cref="P:ILNumerics.Core.Arrays.Mutable`6.shape"/>,<see cref="P:ILNumerics.Core.Arrays.Mutable`6.strides"/>,<see cref="P:ILNumerics.Core.Arrays.Mutable`6.itemsize"/>,<see cref="P:ILNumerics.Size.BaseOffset"/>, <see cref="P:ILNumerics.BaseArray.ReferenceCount"/>,
            <see cref="P:ILNumerics.Core.CountableArray.ReferenceCount"/>. Failing to do so may result in memory access violations or in corrupted 
            objects.</para>
            <para>Handling with memory handles directly is inherently unsafe! Neither the ILNumerics API nor the .NET CLR will 
            prevent you from doing wrong! Therefore, this API is for expert users only. You have been warned and you are on your own!</para>
            <para>The handle returned will be a <see cref="T:ILNumerics.Core.MemoryLayer.NativeHostHandle"/> for <see cref="T:System.ValueType"/> elements and a <see cref="T:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1"/>
            for reference type <typeparamref name="T1"/>. Latter, in general live on the managed heap while former address unmanaged heap process memory.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.InvalidOperationException"> if this attribute is called on a return type array.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.size_">
            <summary>
            [numpy API] Gives the number of elements in this array. This attribute is an alias for <see cref="P:ILNumerics.Size.NumberOfElements"/>. [readonly]
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.nbytes">
            <summary>
            [numpy API] The total number of bytes required to store all elements of this array. [readonly] 
            </summary>
            <remarks>The number returned counts the bytes for the elements of the array only. It does not take into 
            account the memory used for non-element fields and attributes. Also, <see cref="P:ILNumerics.Core.Arrays.Mutable`6.nbytes"/> may not be 
            a measure for the overall size of the memory region actually _used_ to store the elements. This region
            might be larger if elements are non-contiguously laid-out in memory.</remarks>
            <seealso cref="P:ILNumerics.Core.Arrays.Mutable`6.strides"/>
            <seealso cref="M:ILNumerics.Size.GetElementSpan"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.itemsize">
            <summary>
            [numpy API] The number of bytes required to store a single element <typeparamref name="T1"/> in memory. [readonly]
            </summary>
            <remarks>The number of bytes for a single element <typeparamref name="T1"/> mostly correspond to the sizeof(T1) operator in C# for numeric types. 
            One exception are the elements of <see cref="T:ILNumerics.Logical"/> arrays which consume only 1 byte (sizeof(bool) = 4). <see cref="P:ILNumerics.Core.Arrays.Mutable`6.itemsize"/> 
            can be seen as a more general variant of 'sizeof(T1)', taking these subtleties into account.</remarks>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.flat">
            <summary>
            Readonly iterator over the elements of this array in row-major order. 
            </summary>
            <returns>Iterator object.</returns>
            <remarks><para>The <see cref="T:System.Collections.Generic.IEnumerable`1"/> returned allows to iterate over the elements of an array A as if 'A.flatten' 
            was called first. Iteration goes along the rows (last dimension indices varying fastest). </para>
            <para>The iterator extends the lifetime of volatile arrays (<see cref="T:ILNumerics.RetArray`1"/>) until iteration is finished or canceled.</para>
            <para>Note that in difference to numpys 'flatiter' objects, the source array cannot be changed via the iterator. 
            For assigning to elements consider utilizing a size iterator <see cref="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.Size,System.Nullable{ILNumerics.StorageOrders})"/> 
            to acquire an iterator over the element offsets in memory and use <see cref="!:SetValue(T1, long)"/> or <see cref="!:Array&lt;T&gt;.GetHostPointerForWrite()"/> 
            to write to the memory.</para>
            <para><see cref="P:ILNumerics.Core.Arrays.Mutable`6.flat"/> is defined for reference type elements and for all numeric value type element arrays.</para>
            </remarks> 
            <seealso href="https://ilnumerics.net/ArrayImExport.html"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>     
            <seealso cref="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.Size,System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.UInt32)">
            <summary>
            Retrieves the value(s) of the element(s) at the position specified by <paramref name="d0"/> or sets them.
            </summary>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value(s) wrapped into a new array.</returns>
            <value>Right side array with value(s) to be assigned to the element(s) addressed.</value>
            <remarks><para>This functions retrieves/ modifies an individual element or a subarray corresponding to 
            the index <paramref name="d0"/>.</para> 
            <para>If this array has more dimensions than indices specified the size of the subarray returned / of the subarray 
            addressed depends on the setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>  
            <paramref name="d0"/> is considered a <b>sequential</b> index into its own and into subsequent, merged dimensions.  
            The array returned will be a scalar. This mode allows to expand / to remove parts of this array when using the 
            set accessor.</para> 
            <para>For <see cref="F:ILNumerics.ArrayStyles.numpy"/> all indices must fit into their dimensions. Any unspecified 
            trailing dimensions are substituted with <see cref="P:ILNumerics.Globals.full"/> and the array returned contains multiple 
            elements from those dimensions. <see cref="F:ILNumerics.ArrayStyles.numpy"/> does not allow to change the size of existing arrays.</para>
            <para>This indexer is readonly on immutable types. It is optimized for efficient single element access by providing 
            a distinct index parameter for each dimension of this array. Providing a number of indices matching the number of 
            dimensions in this array is recommended for speed and for compatibility of the index access with both <see cref="T:ILNumerics.ArrayStyles"/>.</para> 
            <para>In order to access elements based on their element type <typeparamref name="T1"/> directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use one of the extension methods  
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> or similar overloads for concrete arrays.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if the value of a given index exceeds the valid range.</exception>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value(s) of the element(s) at the position specified by <paramref name="d0"/> and <paramref name="d1"/> or sets them.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value(s) wrapped into a new array.</returns>
            <value>Right side array with value(s) to be assigned to the element(s) addressed.</value>
            <remarks><para>This functions retrieves/ modifies an individual element or a subarray corresponding to 
            <paramref name="d0"/> and <paramref name="d1"/>.</para> 
            <para>If this array has more dimensions than indices specified the size of the subarray returned / of the subarray 
            addressed depends on the setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>  
            <paramref name="d1"/> is considered a <b>sequential</b> index into its own and into subsequent, merged dimensions.  
            The array returned will be a scalar. This mode allows to expand / to remove parts of this array when using the 
            set accessor.</para> 
            <para>For <see cref="F:ILNumerics.ArrayStyles.numpy"/> all indices must fit into their dimensions. Any unspecified 
            trailing dimensions are substituted with <see cref="P:ILNumerics.Globals.full"/> and the array returned contains multiple 
            elements from those dimensions. <see cref="F:ILNumerics.ArrayStyles.numpy"/> does not allow to change the size of existing arrays.</para>
            <para>This indexer is readonly on immutable types. It is optimized for efficient single element access by providing 
            a distinct index parameter for each dimension of this array. Providing a number of indices matching the number of 
            dimensions in this array is recommended for speed and for compatibility of the index access with both <see cref="T:ILNumerics.ArrayStyles"/>.</para> 
            <para>In order to access elements based on their element type <typeparamref name="T1"/> directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use one of the extension methods  
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> or similar overloads for concrete arrays.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if the value of a given index exceeds the valid range.</exception>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value(s) of the element(s) at the position specified by <paramref name="d0"/> ... <paramref name="d2"/> or sets them.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value(s) wrapped into a new array.</returns>
            <value>Right side array with value(s) to be assigned to the element(s) addressed.</value>
            <remarks><para>This functions retrieves/ modifies an individual element or a subarray corresponding to 
            <paramref name="d0"/> ... <paramref name="d2"/>.</para> 
            <para>If this array has more dimensions than indices specified the size of the subarray returned / of the subarray 
            addressed depends on the setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>  
            <paramref name="d2"/> is considered a <b>sequential</b> index into its own and into subsequent, merged dimensions.  
            The array returned will be a scalar. This mode allows to expand / to remove parts of this array when using the 
            set accessor.</para> 
            <para>For <see cref="F:ILNumerics.ArrayStyles.numpy"/> all indices must fit into their dimensions. Any unspecified 
            trailing dimensions are substituted with <see cref="P:ILNumerics.Globals.full"/> and the array returned contains multiple 
            elements from those dimensions. <see cref="F:ILNumerics.ArrayStyles.numpy"/> does not allow to change the size of existing arrays.</para>
            <para>This indexer is readonly on immutable types. It is optimized for efficient single element access by providing 
            a distinct index parameter for each dimension of this array. Providing a number of indices matching the number of 
            dimensions in this array is recommended for speed and for compatibility of the index access with both <see cref="T:ILNumerics.ArrayStyles"/>.</para> 
            <para>In order to access elements based on their element type <typeparamref name="T1"/> directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use one of the extension methods  
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> or similar overloads for concrete arrays.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if the value of a given index exceeds the valid range.</exception>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value(s) of the element(s) at the position specified by <paramref name="d0"/> ... <paramref name="d3"/> or sets them.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value(s) wrapped into a new array.</returns>
            <value>Right side array with value(s) to be assigned to the element(s) addressed.</value>
            <remarks><para>This functions retrieves/ modifies an individual element or a subarray corresponding to 
            <paramref name="d0"/> ... <paramref name="d3"/>.</para> 
            <para>If this array has more dimensions than indices specified the size of the subarray returned / of the subarray 
            addressed depends on the setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>  
            <paramref name="d3"/> is considered a <b>sequential</b> index into its own and into subsequent, merged dimensions.  
            The array returned will be a scalar. This mode allows to expand / to remove parts of this array when using the 
            set accessor.</para> 
            <para>For <see cref="F:ILNumerics.ArrayStyles.numpy"/> all indices must fit into their dimensions. Any unspecified 
            trailing dimensions are substituted with <see cref="P:ILNumerics.Globals.full"/> and the array returned contains multiple 
            elements from those dimensions. <see cref="F:ILNumerics.ArrayStyles.numpy"/> does not allow to change the size of existing arrays.</para>
            <para>This indexer is readonly on immutable types. It is optimized for efficient single element access by providing 
            a distinct index parameter for each dimension of this array. Providing a number of indices matching the number of 
            dimensions in this array is recommended for speed and for compatibility of the index access with both <see cref="T:ILNumerics.ArrayStyles"/>.</para> 
            <para>In order to access elements based on their element type <typeparamref name="T1"/> directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use one of the extension methods  
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> or similar overloads for concrete arrays.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if the value of a given index exceeds the valid range.</exception>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value(s) of the element(s) at the position specified by <paramref name="d0"/> ... <paramref name="d4"/> or sets them.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value(s) wrapped into a new array.</returns>
            <value>Right side array with value(s) to be assigned to the element(s) addressed.</value>
            <remarks><para>This functions retrieves/ modifies an individual element or a subarray corresponding to 
            <paramref name="d0"/> ... <paramref name="d4"/>.</para> 
            <para>If this array has more dimensions than indices specified the size of the subarray returned / of the subarray 
            addressed depends on the setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>  
            <paramref name="d4"/> is considered a <b>sequential</b> index into its own and into subsequent, merged dimensions.  
            The array returned will be a scalar. This mode allows to expand / to remove parts of this array when using the 
            set accessor.</para> 
            <para>For <see cref="F:ILNumerics.ArrayStyles.numpy"/> all indices must fit into their dimensions. Any unspecified 
            trailing dimensions are substituted with <see cref="P:ILNumerics.Globals.full"/> and the array returned contains multiple 
            elements from those dimensions. <see cref="F:ILNumerics.ArrayStyles.numpy"/> does not allow to change the size of existing arrays.</para>
            <para>This indexer is readonly on immutable types. It is optimized for efficient single element access by providing 
            a distinct index parameter for each dimension of this array. Providing a number of indices matching the number of 
            dimensions in this array is recommended for speed and for compatibility of the index access with both <see cref="T:ILNumerics.ArrayStyles"/>.</para> 
            <para>In order to access elements based on their element type <typeparamref name="T1"/> directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use one of the extension methods  
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> or similar overloads for concrete arrays.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if the value of a given index exceeds the valid range.</exception>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value(s) of the element(s) at the position specified by <paramref name="d0"/> ... <paramref name="d5"/> or sets them.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value(s) wrapped into a new array.</returns>
            <value>Right side array with value(s) to be assigned to the element(s) addressed.</value>
            <remarks><para>This functions retrieves/ modifies an individual element or a subarray corresponding to 
            <paramref name="d0"/> ... <paramref name="d5"/>.</para> 
            <para>If this array has more dimensions than indices specified the size of the subarray returned / of the subarray 
            addressed depends on the setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>  
            <paramref name="d5"/> is considered a <b>sequential</b> index into its own and into subsequent, merged dimensions.  
            The array returned will be a scalar. This mode allows to expand / to remove parts of this array when using the 
            set accessor.</para> 
            <para>For <see cref="F:ILNumerics.ArrayStyles.numpy"/> all indices must fit into their dimensions. Any unspecified 
            trailing dimensions are substituted with <see cref="P:ILNumerics.Globals.full"/> and the array returned contains multiple 
            elements from those dimensions. <see cref="F:ILNumerics.ArrayStyles.numpy"/> does not allow to change the size of existing arrays.</para>
            <para>This indexer is readonly on immutable types. It is optimized for efficient single element access by providing 
            a distinct index parameter for each dimension of this array. Providing a number of indices matching the number of 
            dimensions in this array is recommended for speed and for compatibility of the index access with both <see cref="T:ILNumerics.ArrayStyles"/>.</para> 
            <para>In order to access elements based on their element type <typeparamref name="T1"/> directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use one of the extension methods  
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> or similar overloads for concrete arrays.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if the value of a given index exceeds the valid range.</exception>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the value(s) of the element(s) at the position specified by <paramref name="d0"/> ... <paramref name="d6"/> or sets them.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value(s) wrapped into a new array.</returns>
            <value>Right side array with value(s) to be assigned to the element(s) addressed.</value>
            <remarks><para>This functions retrieves/ modifies an individual element or a subarray corresponding to 
            <paramref name="d0"/> ... <paramref name="d4"/>.</para> 
            <para>If this array has more dimensions than indices specified the size of the subarray returned / of the subarray 
            addressed depends on the setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>  
            <paramref name="d4"/> is considered a <b>sequential</b> index into its own and into subsequent, merged dimensions.  
            The array returned will be a scalar. This mode allows to expand / to remove parts of this array when using the 
            set accessor.</para> 
            <para>For <see cref="F:ILNumerics.ArrayStyles.numpy"/> all indices must fit into their dimensions. Any unspecified 
            trailing dimensions are substituted with <see cref="P:ILNumerics.Globals.full"/> and the array returned contains multiple 
            elements from those dimensions. <see cref="F:ILNumerics.ArrayStyles.numpy"/> does not allow to change the size of existing arrays.</para>
            <para>This indexer is readonly on immutable types. It is optimized for efficient single element access by providing 
            a distinct index parameter for each dimension of this array. Providing a number of indices matching the number of 
            dimensions in this array is recommended for speed and for compatibility of the index access with both <see cref="T:ILNumerics.ArrayStyles"/>.</para> 
            <para>In order to access elements based on their element type <typeparamref name="T1"/> directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use one of the extension methods  
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> or similar overloads for concrete arrays.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if the value of a given index exceeds the valid range.</exception>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64)">
            <summary>
            Retrieves the value(s) of the element(s) at the position specified by <paramref name="d0"/> or sets them.
            </summary>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value(s) wrapped into a new array.</returns>
            <value>Right side array with value(s) to be assigned to the element(s) addressed.</value>
            <remarks><para>This functions retrieves/ modifies an individual element or a subarray corresponding to <paramref name="d0"/>.</para> 
            <para>If this array has more dimensions than indices specified the size of the subarray returned / of the subarray 
            addressed depends on the setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>  
            <paramref name="d0"/> is considered a <b>sequential</b> index into its own and into subsequent, merged dimensions.  
            The array returned will be a scalar. This mode allows to expand / to remove parts of this array when using the set accessor.</para> 
            <para>For <see cref="F:ILNumerics.ArrayStyles.numpy"/> all indices must fit into their dimensions. Any unspecified 
            trailing dimensions are substituted with <see cref="P:ILNumerics.Globals.full"/> and the array returned may contain multiple 
            elements from those dimensions. <see cref="F:ILNumerics.ArrayStyles.numpy"/> does not allow to change the size of existing arrays.</para>
            <para>This indexer is readonly on immutable types. It is optimized for efficient single element access by providing 
            a distinct index parameter for each dimension of this array. Providing a number of indices matching the number of 
            dimensions in this array is recommended for speed and for compatibility of the index access with both <see cref="T:ILNumerics.ArrayStyles"/>.</para> 
            <para>In order to access elements based on their element type <typeparamref name="T1"/> directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use one of the extension methods  
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> or similar overloads for concrete arrays.</para>
            <para>This overload allows indexing into huge arrays and negative indices, addressing elements from the end of their 
            respective dimension / merged dimensions.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds 
            the <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64,System.Int64)">
            <summary>
            Retrieves the value(s) of the element(s) at the position specified by <paramref name="d0"/> and <paramref name="d1"/> or sets them.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions.</param>
            <returns>Element value(s) wrapped into a new array.</returns>
            <value>Right side array with value(s) to be assigned to the element(s) addressed.</value>
            <remarks><para>This functions retrieves/ modifies an individual element or a subarray corresponding to <paramref name="d0"/> and <paramref name="d1"/>.</para> 
            <para>If this array has more dimensions than indices specified the size of the subarray returned / of the subarray 
            addressed depends on the setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>  
            <paramref name="d1"/> is considered a <b>sequential</b> index into its own and into subsequent, merged dimensions.  
            The array returned will be a scalar. This mode allows to expand / to remove parts of this array when using the 
            set accessor.</para> 
            <para>For <see cref="F:ILNumerics.ArrayStyles.numpy"/> all indices must fit into their dimensions. Any unspecified 
            trailing dimensions are substituted with <see cref="P:ILNumerics.Globals.full"/> and the array returned contains multiple 
            elements from those dimensions. <see cref="F:ILNumerics.ArrayStyles.numpy"/> does not allow to change the size of existing arrays.</para>
            <para>This indexer is readonly on immutable types. It is optimized for efficient single element access by providing 
            a distinct index parameter for each dimension of this array. Providing a number of indices matching the number of 
            dimensions in this array is recommended for speed and for compatibility of the index access with both <see cref="T:ILNumerics.ArrayStyles"/>.</para> 
            <para>In order to access elements based on their element type <typeparamref name="T1"/> directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use one of the extension methods  
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> or similar overloads for concrete arrays.</para>
            <para>This overload allows indexing into huge arrays and negative indices, addressing elements from the end of their 
            respective dimension / merged dimensions.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if the value of a given index exceeds the valid range.</exception>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value(s) of the element(s) at the position specified by <paramref name="d0"/> ... <paramref name="d2"/> or sets them.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value(s) wrapped into a new array.</returns>
            <value>Right side array with value(s) to be assigned to the element(s) addressed.</value>
            <remarks><para>This functions retrieves/ modifies an individual element or a subarray corresponding to 
            <paramref name="d0"/> ... <paramref name="d2"/>.</para> 
            <para>If this array has more dimensions than indices specified the size of the subarray returned / of the subarray 
            addressed depends on the setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>  
            <paramref name="d2"/> is considered a <b>sequential</b> index into its own and into subsequent, merged dimensions.  
            The array returned will be a scalar. This mode allows to expand / to remove parts of this array when using the 
            set accessor.</para> 
            <para>For <see cref="F:ILNumerics.ArrayStyles.numpy"/> all indices must fit into their dimensions. Any unspecified 
            trailing dimensions are substituted with <see cref="P:ILNumerics.Globals.full"/> and the array returned contains multiple 
            elements from those dimensions. <see cref="F:ILNumerics.ArrayStyles.numpy"/> does not allow to change the size of existing arrays.</para>
            <para>This indexer is readonly on immutable types. It is optimized for efficient single element access by providing 
            a distinct index parameter for each dimension of this array. Providing a number of indices matching the number of 
            dimensions in this array is recommended for speed and for compatibility of the index access with both <see cref="T:ILNumerics.ArrayStyles"/>.</para> 
            <para>In order to access elements based on their element type <typeparamref name="T1"/> directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use one of the extension methods  
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> or similar overloads for concrete arrays.</para>
            <para>This overload allows indexing into huge arrays and negative indices, addressing elements from the end of their 
            respective dimension / merged dimensions.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if the value of a given index exceeds the valid range.</exception>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value(s) of the element(s) at the position specified by <paramref name="d0"/> ... <paramref name="d3"/> or sets them.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value(s) wrapped into a new array.</returns>
            <value>Right side array with value(s) to be assigned to the element(s) addressed.</value>
            <remarks><para>This functions retrieves/ modifies an individual element or a subarray corresponding to 
            <paramref name="d0"/> ... <paramref name="d3"/>.</para> 
            <para>If this array has more dimensions than indices specified the size of the subarray returned / of the subarray 
            addressed depends on the setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>  
            <paramref name="d3"/> is considered a <b>sequential</b> index into its own and into subsequent, merged dimensions.  
            The array returned will be a scalar. This mode allows to expand / to remove parts of this array when using the 
            set accessor.</para> 
            <para>For <see cref="F:ILNumerics.ArrayStyles.numpy"/> all indices must fit into their dimensions. Any unspecified 
            trailing dimensions are substituted with <see cref="P:ILNumerics.Globals.full"/> and the array returned contains multiple 
            elements from those dimensions. <see cref="F:ILNumerics.ArrayStyles.numpy"/> does not allow to change the size of existing arrays.</para>
            <para>This indexer is readonly on immutable types. It is optimized for efficient single element access by providing 
            a distinct index parameter for each dimension of this array. Providing a number of indices matching the number of 
            dimensions in this array is recommended for speed and for compatibility of the index access with both <see cref="T:ILNumerics.ArrayStyles"/>.</para> 
            <para>In order to access elements based on their element type <typeparamref name="T1"/> directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use one of the extension methods  
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> or similar overloads for concrete arrays.</para>
            <para>This overload allows indexing into huge arrays and negative indices, addressing elements from the end of their 
            respective dimension / merged dimensions.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if the value of a given index exceeds the valid range.</exception>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value(s) of the element(s) at the position specified by <paramref name="d0"/> ... <paramref name="d4"/> or sets them.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value(s) wrapped into a new array.</returns>
            <value>Right side array with value(s) to be assigned to the element(s) addressed.</value>
            <remarks><para>This functions retrieves/ modifies an individual element or a subarray corresponding to 
            <paramref name="d0"/> ... <paramref name="d4"/>.</para> 
            <para>If this array has more dimensions than indices specified the size of the subarray returned / of the subarray 
            addressed depends on the setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>  
            <paramref name="d4"/> is considered a <b>sequential</b> index into its own and into subsequent, merged dimensions.  
            The array returned will be a scalar. This mode allows to expand / to remove parts of this array when using the 
            set accessor.</para> 
            <para>For <see cref="F:ILNumerics.ArrayStyles.numpy"/> all indices must fit into their dimensions. Any unspecified 
            trailing dimensions are substituted with <see cref="P:ILNumerics.Globals.full"/> and the array returned contains multiple 
            elements from those dimensions. <see cref="F:ILNumerics.ArrayStyles.numpy"/> does not allow to change the size of existing arrays.</para>
            <para>This indexer is readonly on immutable types. It is optimized for efficient single element access by providing 
            a distinct index parameter for each dimension of this array. Providing a number of indices matching the number of 
            dimensions in this array is recommended for speed and for compatibility of the index access with both <see cref="T:ILNumerics.ArrayStyles"/>.</para> 
            <para>In order to access elements based on their element type <typeparamref name="T1"/> directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use one of the extension methods  
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> or similar overloads for concrete arrays.</para>
            <para>This overload allows indexing into huge arrays and negative indices, addressing elements from the end of their 
            respective dimension / merged dimensions.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if the value of a given index exceeds the valid range.</exception>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value(s) of the element(s) at the position specified by <paramref name="d0"/> ... <paramref name="d5"/> or sets them.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value(s) wrapped into a new array.</returns>
            <value>Right side array with value(s) to be assigned to the element(s) addressed.</value>
            <remarks><para>This functions retrieves/ modifies an individual element or a subarray corresponding to 
            <paramref name="d0"/> ... <paramref name="d5"/>.</para> 
            <para>If this array has more dimensions than indices specified the size of the subarray returned / of the subarray 
            addressed depends on the setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>  
            <paramref name="d5"/> is considered a <b>sequential</b> index into its own and into subsequent, merged dimensions.  
            The array returned will be a scalar. This mode allows to expand / to remove parts of this array when using the 
            set accessor.</para> 
            <para>For <see cref="F:ILNumerics.ArrayStyles.numpy"/> all indices must fit into their dimensions. Any unspecified 
            trailing dimensions are substituted with <see cref="P:ILNumerics.Globals.full"/> and the array returned contains multiple 
            elements from those dimensions. <see cref="F:ILNumerics.ArrayStyles.numpy"/> does not allow to change the size of existing arrays.</para>
            <para>This indexer is readonly on immutable types. It is optimized for efficient single element access by providing 
            a distinct index parameter for each dimension of this array. Providing a number of indices matching the number of 
            dimensions in this array is recommended for speed and for compatibility of the index access with both <see cref="T:ILNumerics.ArrayStyles"/>.</para> 
            <para>In order to access elements based on their element type <typeparamref name="T1"/> directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use one of the extension methods  
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> or similar overloads for concrete arrays.</para>
            <para>This overload allows indexing into huge arrays and negative indices, addressing elements from the end of their 
            respective dimension / merged dimensions.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if the value of a given index exceeds the valid range.</exception>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value(s) of the element(s) at the position specified by <paramref name="d0"/> ... <paramref name="d6"/> or sets them.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array, if any.</param>
            <returns>Element value(s) wrapped into a new array.</returns>
            <value>Right side array with value(s) to be assigned to the element(s) addressed.</value>
            <remarks><para>This functions retrieves/ modifies an individual element or a subarray corresponding to 
            <paramref name="d0"/> ... <paramref name="d6"/>.</para> 
            <para>If this array has more dimensions than indices specified the size of the subarray returned / of the subarray 
            addressed depends on the setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>  
            <paramref name="d6"/> is considered a <b>sequential</b> index into its own and into subsequent, merged dimensions.  
            The array returned will be a scalar. This mode allows to expand / to remove parts of this array when using the 
            set accessor.</para> 
            <para>For <see cref="F:ILNumerics.ArrayStyles.numpy"/> all indices must fit into their dimensions. Any unspecified 
            trailing dimensions are substituted with <see cref="P:ILNumerics.Globals.full"/> and the array returned contains multiple 
            elements from those dimensions. <see cref="F:ILNumerics.ArrayStyles.numpy"/> does not allow to change the size of existing arrays.</para>
            <para>This indexer is readonly on immutable types. It is optimized for efficient single element access by providing 
            a distinct index parameter for each dimension of this array. Providing a number of indices matching the number of 
            dimensions in this array is recommended for speed and for compatibility of the index access with both <see cref="T:ILNumerics.ArrayStyles"/>.</para> 
            <para>In order to access elements based on their element type <typeparamref name="T1"/> directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use one of the extension methods  
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> or similar overloads for concrete arrays.</para>
            <para>This overload allows indexing into huge arrays and negative indices, addressing elements from the end of their 
            respective dimension / merged dimensions.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if the value of a given index exceeds the valid range.</exception>
            <seealso href="https://ilnumerics.net/subarrays-v5.html">Subarray tutorial in the ILNumerics online documentation</seealso>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.DimSpec,ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec[])">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="dims">Array with range specification(s) for dimensions of this array.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="dims"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec)">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="d0"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="d0"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="d0"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <param name="d3">Range specification for dimension #3.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="d0"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <param name="d3">Range specification for dimension #3.</param>
            <param name="d4">Range specification for dimension #4.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="d0"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <param name="d3">Range specification for dimension #3.</param>
            <param name="d4">Range specification for dimension #4.</param>
            <param name="d5">Range specification for dimension #5.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="d0"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <param name="d3">Range specification for dimension #3.</param>
            <param name="d4">Range specification for dimension #4.</param>
            <param name="d5">Range specification for dimension #5.</param>
            <param name="d6">Range specification for dimension #6.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="d0"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray)">
            <summary>
            Gets a subarray from this array or replaces the values of parts of this array.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="d0"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="d0"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="d0"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <param name="d3">Range specification for dimension #3.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="d0"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <param name="d3">Range specification for dimension #3.</param>
            <param name="d4">Range specification for dimension #4.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="d0"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <param name="d3">Range specification for dimension #3.</param>
            <param name="d4">Range specification for dimension #4.</param>
            <param name="d5">Range specification for dimension #5.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="d0"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="d0">Range specification for dimension #0.</param>
            <param name="d1">Range specification for dimension #1.</param>
            <param name="d2">Range specification for dimension #2.</param>
            <param name="d3">Range specification for dimension #3.</param>
            <param name="d4">Range specification for dimension #4.</param>
            <param name="d5">Range specification for dimension #5.</param>
            <param name="d6">Range specification for dimension #6.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="d0"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.Item(ILNumerics.BaseArray[])">
            <summary>
            Gets a subarray from this array or replaces the values of part of this array.
            </summary>
            <param name="dims">Array with range specification(s) for dimensions of this array.</param>
            <value>The right side array providing the new values.</value>
            <returns>Subarray according to the range specification(s) <paramref name="dims"/>...</returns>
            <remarks><para>This indexer supports subarray retrieval and subarray assignment 
            for mutable ILNumerics array types: <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.OutArray`1"/> and 
            the corresponding array types for <see cref="T:ILNumerics.Logical"/>, <see cref="T:ILNumerics.OutLogical"/>, <see cref="T:ILNumerics.Cell"/>
            and <see cref="T:ILNumerics.OutCell"/>.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Mutable`6.a">
            <summary>
            Assign another array to this array variable. This is an optional, yet more efficient alternative to using '=' for assigning to the array directly.
            </summary>
            <param name="value">The new array.</param>
            <remarks>By using this method, the storage of this array is immediately released to the memory pool and replaced by the new arrays content. In difference to that, 
            by using the common '=' assignment operator, the existing arrays storage is released only at the time, the current 
            <see cref="M:ILNumerics.Scope.Enter"/> block  is left. Therefeore, prefer this method if a 
            smaller memory pool is crucial.</remarks>
            <seealso cref="P:ILNumerics.OutArray`1.a"/>
        </member>
        <member name="M:ILNumerics.Core.Arrays.Mutable`6.Assign(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>
            Assign another array to this array variable. This is an optional, yet more efficient alternative to using '=' for assigning to the array directly. 
            </summary>
            <param name="value">The new array.</param>
            <remarks>By using this method, the storage of this array is immediately released to the memory pool and replaced by the new arrays content. In difference to that, 
            by using the common '=' assignment operator, the existing arrays storage is released only at the time, the current 
            <see cref="M:ILNumerics.Scope.Enter"/> block  is left. Therefeore, prefer this method if a 
            smaller memory pool is crucial.</remarks>
            <seealso cref="P:ILNumerics.OutArray`1.a"/>
        </member>
        <member name="T:ILNumerics.Core.Arrays.Immutable`6">
            <summary>
            Base class for all mutable array types. Internal use.
            </summary>
            <summary>
            Base class for all mutable array types. Internal use.
            </summary>
            <typeparam name="T1">The element type.</typeparam>
            <typeparam name="LocalT">The local array type of this array type set. </typeparam>
            <typeparam name="InT">The input array type of this array type set.</typeparam>
            <typeparam name="OutT">The output array type of this array type set.</typeparam>
            <typeparam name="RetT">The return array type of this array type set.</typeparam>
            <typeparam name="StorageT">The storage type of this array type set.</typeparam>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.shape">
            <summary>
            [numpy API] The dimension lengths as ILNumerics vector of length corresponding to <see cref="P:ILNumerics.Size.NumberOfDimensions"/>.
            </summary>
            <remarks><para>This property allows to query the dimension lengths as an ILNumerics vector. The vector returned will have 
            at least (<see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>) one dimension with the dimension lengths of this array as elements. Numpy scalars return an empty vector.</para>
            <para>For mutable arrays the shape can also be changed inplace by assigning to this property. Changing the shape is only allowed 
            for mutable arrays which are in a suitable state: the storage must be continously layed out, the number of elements must not change.</para>
            <para>Immutable arrays do not expose a setter property / function for the shape attribute.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.InvalidOperationException"> if this array is currently shared with multiple instance. For example, if it is in use 
            by an instance of <see cref="T:ILNumerics.InArray`1"/> as function parameter and the function has not returned yet. Applying the ILNumerics function 
            rules prevent from such situations commonly.</exception>
            <exception cref="T:System.ArgumentException"> if trying to assign a vector having too many elements, having negative elements, 
            if the new dimensions specified would result in a different number of elements than <see cref="P:ILNumerics.Size.NumberOfElements"/>, or if the storage 
            of this array cannot be reshaped without copying elements (<see cref="P:ILNumerics.Size.IsContinuous"/> is false).</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.strides">
            <summary>
            [numpy API] The strides of elements within the dimensions. Unit: element size.
            </summary>
            <remarks>Elements within a dimension of ILNumerics arrays are separated in memory by a certain, fixed address offset. This offset is 
            the same for all elements within the same dimension. The array returned gives this offset for each dimension of this array.
            <para>Note that the unit of the distance is the <i>element size</i>, i.e. the number of bytes consumed by a single element. In difference 
            to that, the numpy attribute <see href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.strides.html#numpy.ndarray.strides"/> 
            gives this distance in <i>bytes</i>.</para>
            <para>This attribute is readonly.</para></remarks>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.itemsize"/>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.shape"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.ndim">
            <summary>
            [numpy API] The number of dimensions stored for this array.
            </summary>
            <remarks><para>This readonly attribute is an alias for <see cref="P:ILNumerics.Size.NumberOfDimensions"/>.</para></remarks>
            <seealso cref="P:ILNumerics.Size.NumberOfDimensions"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.size_">
            <summary>
            [numpy API] Gives the number of elements in this array. This attribute is an alias for <see cref="P:ILNumerics.Size.NumberOfElements"/>. [readonly]
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.nbytes">
            <summary>
            [numpy API] The total number of bytes required to store all elements of this array. [readonly] 
            </summary>
            <remarks>The number returned counts the bytes for the elements of the array only. It does not take into 
            account the memory used for non-element fields and attributes. Also, <see cref="P:ILNumerics.Core.Arrays.Immutable`6.nbytes"/> may not be 
            a measure for the overall size of the memory region actually _used_ to store the elements. This region
            might be larger if elements are non-contiguously laid-out in memory.</remarks>
            <seealso cref="P:ILNumerics.Core.Arrays.Immutable`6.strides"/>
            <seealso cref="M:ILNumerics.Size.GetElementSpan"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.itemsize">
            <summary>
            [numpy API] The number of bytes required to store a single element <typeparamref name="T1"/> in memory. [readonly]
            </summary>
            <remarks>The number of bytes for a single element <typeparamref name="T1"/> mostly correspond to the sizeof(T1) operator in C# for numeric types. 
            One exception are the elements of <see cref="T:ILNumerics.Logical"/> arrays which consume only 1 byte (sizeof(bool) = 4). <see cref="P:ILNumerics.Core.Arrays.Immutable`6.itemsize"/> 
            can be seen as a more general variant of 'sizeof(T1)', taking these subtleties into account.</remarks>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.flat">
            <summary>
            Readonly iterator over the elements of this array in row-major order. 
            </summary>
            <returns>Iterator object.</returns>
            <remarks><para>The <see cref="T:System.Collections.Generic.IEnumerable`1"/> returned allows to iterate over the elements of an array A as if 'A.flatten' 
            was called first. Iteration goes along the rows (last dimension indices varying fastest). </para>
            <para>The iterator extends the lifetime of volatile arrays (<see cref="T:ILNumerics.RetArray`1"/>) until iteration is finished or canceled.</para>
            <para>Note that in difference to numpys 'flatiter' objects, the source array cannot be changed via the iterator. 
            For assigning to elements consider utilizing a size iterator <see cref="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.Size,System.Nullable{ILNumerics.StorageOrders})"/> 
            to acquire an iterator over the element offsets in memory and use <see cref="!:SetValue(T1, long)"/> or <see cref="!:Array&lt;T&gt;.GetHostPointerForWrite()"/> 
            to write to the memory.</para>
            <para><see cref="P:ILNumerics.Core.Arrays.Immutable`6.flat"/> is defined for reference type elements and for all numeric value type element arrays.</para>
            </remarks> 
            <seealso href="https://ilnumerics.net/ArrayImExport.html"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>     
            <seealso cref="M:ILNumerics.ExtensionMethods.Iterator(ILNumerics.Size,System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32)">
            <summary>
            (TODO: add numpy indexing docu) Retrieves the value of the element at the position specified by <paramref name="d0"/> or set its value.
            </summary>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value wrapped into a new scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond to the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to be different.</para> 
            <para>This indexer is readonly on immutable types. The get accessor returns a scalar array. In order to 
            receive the value of the element addressed as system type directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use 
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds 
            the <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32,System.UInt32)">
            <summary>
            (TODO: add numpy indexing docu) Retrieves the value of the element at the position specified by <paramref name="d0"/> and <paramref name="d1"/> or set its value.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value wrapped into a new scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            <para>This indexer is readonly on immutable types. The get accessor returns a scalar array. In order to 
            receive the value of the element addressed as system type directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use 
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32,System.UInt32)"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            (TODO: add numpy indexing docu) Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d2"/> or set its value.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            (TODO: add numpy indexing docu) Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d3"/> or set its value.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            (TODO: add numpy indexing docu) Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d4"/> or set its value.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            (TODO: add numpy indexing docu) Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d5"/> or set its value.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            (TODO: add numpy indexing docu) Retrieves the value of the element at the position specified by <paramref name="d0"/> ... <paramref name="d6"/> or set its value.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.Int64)">
            <summary>
            Retrieves the value(s) of the element(s) at the position(s) specified by <paramref name="d0"/>. Deep indexing for cells.
            </summary>
            <param name="d0">Index into the first dimension or sequential index into the array.</param>
            <returns>Element value wrapped into a new scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element at <b>sequential</b> index <paramref name="d0"/>. Note that 
            the index provided in <paramref name="d0"/> does not correspond to the storage position of the element to retrieve. This 
            would only be true for special cases of storage layout and dimension numbers. For arbitrary storage 
            layouts both are likely to be different.</para> 
            <para>This indexer is readonly on immutable types. The get accessor returns a scalar array. In order to 
            receive the value of the element addressed as system type directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use 
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/> and/or its specific 
            overloads for the individiual element types.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.DimSpec)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.Int64,System.Int64)">
            <summary>
            Retrieves the value(s) of the element(s) at the position(s) specified by <paramref name="d0"/> and <paramref name="d1"/>. Deep indexing for cells.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value wrapped into a new scalar array.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first two dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            <para>This indexer is readonly on immutable types. The get accessor returns a scalar array. In order to 
            receive the value of the element addressed as system type directly (i.e.: without wrapping it into a new 
            array) and as a faster alternative for scalar or mostly-scalar algorithms use 
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32,System.UInt32)"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.Int64,System.Int64)"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value(s) of the element(s) at the position(s) specified by <paramref name="d0"/> ... <paramref name="d2"/>. Deep indexing for cells.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first three dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if the value of <paramref name="d0"/> exceeds the number of elements in the 
            first dimension, or the value of <paramref name="d1"/> exceeds the number of elements in the 2nd dimension, 
            or the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value(s) of the element(s) at the position(s) specified by <paramref name="d0"/> ... <paramref name="d3"/>. Deep indexing for cells.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first four dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value(s) of the element(s) at the position(s) specified by <paramref name="d0"/> ... <paramref name="d4"/>. Deep indexing for cells.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first five dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value(s) of the element(s) at the position(s) specified by <paramref name="d0"/> ... <paramref name="d5"/>. Deep indexing for cells.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension or sequential index into remaining dimensions of the array.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the first six dimensions. </para>
            <para>If the value provided by the last index parameter exceeds the number of elements in its corresponding dimension
            the superflous index value is translated into subsequent dimensions.</para> 
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the value(s) of the element(s) at the position(s) specified by <paramref name="d0"/> ... <paramref name="d6"/>. Deep indexing for cells.
            </summary>
            <param name="d0">Index into the first dimension. </param>
            <param name="d1">Index into the second dimension. </param>
            <param name="d2">Index into the third dimension. </param>
            <param name="d3">Index into the fourth dimension. </param>
            <param name="d4">Index into the fifths dimension. </param>
            <param name="d5">Index into the sixths dimension. </param>
            <param name="d6">Index into the sevenths dimension or sequential index into remaining dimensions of the array, if any.</param>
            <returns>Element value.</returns>
            <remarks><para>This functions retrieves the value of the element as given by the indices into the seven dimensions. </para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.GetValue(ILNumerics.BaseArray{System.Double},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetHostPointerForRead(System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Array`1.GetHostPointerForWrite(System.Nullable{ILNumerics.StorageOrders})"/>
            <exception cref="T:System.IndexOutOfRangeException">if at least one of the values of <paramref name="d0"/>, 
            <paramref name="d1"/>, <paramref name="d2"/>, <paramref name="d3"/>, <paramref name="d4"/>, <paramref name="d5"/> exceeds the number of elements in its corresponding dimension, 
            or if the computed index according to all index parameters <paramref name="d0"/>, <paramref name="d1"/>,... exceeds the 
            <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec)">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="d0">Range specification(s).</param>
            <returns>Subarray according to the range specification(s) in <paramref name="d0"/>.</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'fast' subarray API: the array returned will reference the same memory as this array in a 'lazy, copy on-write' 
            scheme.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="d0">Range specification(s) for dimension #0.</param>
            <param name="d1">Range specification(s) for dimension #1.</param>
            <returns>Subarray according to the range specification(s) in <paramref name="d0"/>, ...</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'fast' subarray API: the array returned will reference the same memory as this array in a 'lazy, copy on-write' 
            scheme.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="d0">Range specification(s) for dimension #0.</param>
            <param name="d1">Range specification(s) for dimension #1.</param>
            <param name="d2">Range specification(s) for dimension #2.</param>
            <returns>Subarray according to the range specification(s) in <paramref name="d0"/>, ...</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'fast' subarray API: the array returned will reference the same memory as this array in a 'lazy, copy on-write' 
            scheme.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="d0">Range specification(s) for dimension #0.</param>
            <param name="d1">Range specification(s) for dimension #1.</param>
            <param name="d2">Range specification(s) for dimension #2.</param>
            <param name="d3">Range specification(s) for dimension #3.</param>
            <returns>Subarray according to the range specification(s) in <paramref name="d0"/>, ...</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'fast' subarray API: the array returned will reference the same memory as this array in a 'lazy, copy on-write' 
            scheme.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="d0">Range specification(s) for dimension #0.</param>
            <param name="d1">Range specification(s) for dimension #1.</param>
            <param name="d2">Range specification(s) for dimension #2.</param>
            <param name="d3">Range specification(s) for dimension #3.</param>
            <param name="d4">Range specification(s) for dimension #4.</param>
            <returns>Subarray according to the range specification(s) in <paramref name="d0"/>, ...</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'fast' subarray API: the array returned will reference the same memory as this array in a 'lazy, copy on-write' 
            scheme.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="d0">Range specification(s) for dimension #0.</param>
            <param name="d1">Range specification(s) for dimension #1.</param>
            <param name="d2">Range specification(s) for dimension #2.</param>
            <param name="d3">Range specification(s) for dimension #3.</param>
            <param name="d4">Range specification(s) for dimension #4.</param>
            <param name="d5">Range specification(s) for dimension #5.</param>
            <returns>Subarray according to the range specification(s) in <paramref name="d0"/>, ...</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'fast' subarray API: the array returned will reference the same memory as this array in a 'lazy, copy on-write' 
            scheme.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec,ILNumerics.DimSpec)">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="d0">Range specification(s) for dimension #0.</param>
            <param name="d1">Range specification(s) for dimension #1.</param>
            <param name="d2">Range specification(s) for dimension #2.</param>
            <param name="d3">Range specification(s) for dimension #3.</param>
            <param name="d4">Range specification(s) for dimension #4.</param>
            <param name="d5">Range specification(s) for dimension #5.</param>
            <param name="d6">Range specification(s) for dimension #6.</param>
            <returns>Subarray according to the range specification(s) in <paramref name="d0"/>, ...</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'fast' subarray API: the array returned will reference the same memory as this array in a 'lazy, copy on-write' 
            scheme.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.DimSpec[])">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="dims">Array with range specification(s) for dimensions of this array.</param>
            <returns>Subarray according to the range specification(s) in <paramref name="dims"/>.</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.).</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray)">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="d0">Range specification(s) for dimension #0.</param>
            <returns>Subarray according to the range specification(s) in <paramref name="d0"/>.</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'flexible' subarray API: the array returned will reference new memory with copies of the elements from this array.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="d0">Range specification(s) for dimension #0.</param>
            <param name="d1">Range specification(s) for dimension #1.</param>
            <returns>Subarray according to the range specification(s) in <paramref name="d0"/>,... .</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'flexible' subarray API: the array returned will reference new memory with copies of the elements from this array.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="d0">Range specification(s) for dimension #0.</param>
            <param name="d1">Range specification(s) for dimension #1.</param>
            <param name="d2">Range specification(s) for dimension #2.</param>
            <returns>Subarray according to the range specification(s) in <paramref name="d0"/>,... .</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'flexible' subarray API: the array returned will reference new memory with copies of the elements from this array.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="d0">Range specification(s) for dimension #0.</param>
            <param name="d1">Range specification(s) for dimension #1.</param>
            <param name="d2">Range specification(s) for dimension #2.</param>
            <param name="d3">Range specification(s) for dimension #3.</param>
            <returns>Subarray according to the range specification(s) in <paramref name="d0"/>,... .</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'flexible' subarray API: the array returned will reference new memory with copies of the elements from this array.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="d0">Range specification(s) for dimension #0.</param>
            <param name="d1">Range specification(s) for dimension #1.</param>
            <param name="d2">Range specification(s) for dimension #2.</param>
            <param name="d3">Range specification(s) for dimension #3.</param>
            <param name="d4">Range specification(s) for dimension #4.</param>
            <returns>Subarray according to the range specification(s) in <paramref name="d0"/>,... .</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'flexible' subarray API: the array returned will reference new memory with copies of the elements from this array.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="d0">Range specification(s) for dimension #0.</param>
            <param name="d1">Range specification(s) for dimension #1.</param>
            <param name="d2">Range specification(s) for dimension #2.</param>
            <param name="d3">Range specification(s) for dimension #3.</param>
            <param name="d4">Range specification(s) for dimension #4.</param>
            <param name="d5">Range specification(s) for dimension #5.</param>
            <returns>Subarray according to the range specification(s) in <paramref name="d0"/>,... .</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'flexible' subarray API: the array returned will reference new memory with copies of the elements from this array.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Gets a subarray from this array.
            </summary>
            <param name="d0">Range specification(s) for dimension #0.</param>
            <param name="d1">Range specification(s) for dimension #1.</param>
            <param name="d2">Range specification(s) for dimension #2.</param>
            <param name="d3">Range specification(s) for dimension #3.</param>
            <param name="d4">Range specification(s) for dimension #4.</param>
            <param name="d5">Range specification(s) for dimension #5.</param>
            <param name="d6">Range specification(s) for dimension #6.</param>
            <returns>Subarray according to the range specification(s) in <paramref name="d0"/>,... .</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'flexible' subarray API: the array returned will reference new memory with copies of the elements from this array.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="P:ILNumerics.Core.Arrays.Immutable`6.Item(ILNumerics.BaseArray[])">
            <summary>
            Gets a subarray from this array, ranges are based on an array of index arrays.
            </summary>
            <param name="dims">Range specification(s).</param>
            <returns>Subarray according to the range specification(s) in <paramref name="dims"/>.</returns>
            <remarks><para>This indexer supports subarray retrieval from immutable arrays (RetArray, RetLogical etc.). This is 
            part of the 'flexible' subarray API: the array returned will reference new memory with copies of the elements from this array.</para></remarks>
            <seealso href="https://ilnumerics.net/subarrays-v5.html"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Subarray(ILNumerics.BaseArray[])"/>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.SetRange(ILNumerics.BaseArray{`0},ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.SetValue``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0,System.Int64,System.Int64)"/>
            <exception cref="T:System.IndexOutOfRangeException">If an index lays outside of the allowed range. The exception message 
            will carry more details regarding the cause of this error.</exception>
        </member>
        <member name="T:ILNumerics.Core.Global.ArrayDebuggerProxy`6">
            <summary>
            This class is for internal use only. Do not instantiate from this class!
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ILNumerics.Core.Global.ArrayOperationAttribute">
            <summary>
            Attribute used to identify acceleratable operations on ILNumerics arrays. Used by ILNumerics.Accelerator.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Global.ArrayOperationAttribute.#ctor(System.String)">
            <summary>
            Create a new <see cref="T:ILNumerics.Core.Global.ArrayOperationAttribute"/>.
            </summary>
            <param name="proxyTypeName">The name of a type providing extensive information about the operation.</param>
        </member>
        <member name="T:ILNumerics.Core.Global.Helper">
            <summary>
            Helper functions for internal use.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Global.Helper.BC_broadcastOutDims(ILNumerics.Size,ILNumerics.Size,System.Int64*,System.UInt32@)">
            <summary>
            Computes the output shape from A and B. 
            </summary>
            <param name="A">Size of input array A.</param>
            <param name="B">Size of input array B.</param>
            <param name="buffer">buffer of long* with room for at least 3 + <see cref="F:ILNumerics.Size.MaxNumberOfDimensions"/> elements.</param>
            <param name="ndims">[out] broadcasted number of dimension on return.</param>
            <remarks>This function sets buffer[0] (ndims), buffer[1] (nelem) and the dimension lengths (buffer + 2 + [1...ndims]) only. 
            It checks for matching broadcasting sizes and throws an exception on error.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Global.Helper.BC_configureFinalize(System.Int64*,System.Nullable{ILNumerics.StorageOrders},System.Int32)">
            <summary>
            Completes metadata configuration for output array.
            </summary>
            <param name="bsd">Start of the BSD of the ouput array.</param>
            <param name="order">Storage order for the output. Not used.</param>
            <param name="leadingDim">Leading dimension: the dimension where elements will be sequentially stored along. Subsequent dimensions are ordered accordingly in increasing dimension index order.</param>
        </member>
        <member name="M:ILNumerics.Core.Global.Helper.BC_prepareIterationDims``2(ILNumerics.Size,ILNumerics.Size,System.Int64*,System.Boolean)">
            <summary>
            Prepares all dimension and strides array for efficient iteration in binary, broadcasting operators.
            </summary>
            <typeparam name="T_In">Element type. Used to determine the element size / strides.</typeparam>
            <typeparam name="T_Out">Output element type. Used to determine strides.</typeparam>
            <param name="sizeA"></param>
            <param name="sizeB"></param>
            <param name="buffer">Input / output: predefined array with dimension lengths. Output: holds dimension lengths and strides, ready for iteration.</param>
            <param name="reverse">True: reverses the dimensions / strides of the returned BSD.</param>
            <remarks><para>This functions takes the dimension lengths in <paramref name="buffer"/> and completes the buffer 
            with * out strides, * A strides and * B strides for binary operator iteration.</para>
            <para>All strides are multiplied with the element size of <typeparamref name="T_In"/> in bytes.</para>
            <para>All dims are decreased by 1 for easier iteration later.</para>
            <para><paramref name="buffer"/> is of minimum length 3 + 7 * 4, for [ndims, nelem, offs] + outdims + outstrides ++ stridesA ++ stridesB. On entry, 
            only elements 0, 1 and 3...[ndims-1] are expected. other info (strides) are completed and returned within this function.</para>
            <para>If <paramref name="reverse"/> is true all dimensions and strides are reversed. This corresponds to an output array in row major order.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Global.Helper.BC_prepareIterationDims``3(ILNumerics.Size,ILNumerics.Size,System.Int64*,System.Boolean)">
            <summary>
            Prepares all dimension and strides array for efficient iteration in binary, broadcasting operators.
            </summary>
            <typeparam name="T_In1">Element type, input 1. Used to determine the element size / strides.</typeparam>
            <typeparam name="T_In2">Element type, input 2. Used to determine the element size / strides.</typeparam>
            <typeparam name="T_Out">Output element type. Used to determine strides.</typeparam>
            <param name="sizeA"></param>
            <param name="sizeB"></param>
            <param name="buffer">Input / output: predefined array with dimension lengths. Output: holds dimension lengths and strides, ready for iteration.</param>
            <param name="reverse">True: reverses the dimensions / strides of the returned BSD.</param>
            <remarks><para>This functions takes the dimension lengths in <paramref name="buffer"/> and completes the buffer 
            with * out strides, * A strides and * B strides for binary operator iteration.</para>
            <para>All strides are multiplied with the element size of <typeparamref name="T_In1"/> / <typeparamref name="T_In2"/> resp., in bytes.</para>
            <para>All dims are decreased by 1 for easier iteration later.</para>
            <para><paramref name="buffer"/> is of minimum length 3 + 7 * 4, for [ndims, nelem, offs] + outdims + outstrides ++ stridesA ++ stridesB. On entry, 
            only elements 0, 1 and 3...[ndims-1] are expected. other info (strides) are completed and returned within this function.</para>
            <para>If <paramref name="reverse"/> is true all dimensions and strides are reversed. This corresponds to an output array in row major order.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Global.Helper.PrepareBSD(ILNumerics.StorageOrders,System.Int64*,System.Int64*,System.UInt32,System.Int32)">
            <summary>
            Prepares an iteration BSD, considering output storage order and strides.
            </summary>
            <param name="outStorageOrder">The target storage order. For <see cref="F:ILNumerics.StorageOrders.Other"/> the smallest strided dimension is used for iteration (cache awareness).</param>
            <param name="bsd">The source bsd.</param>
            <param name="ordered_bsd">[Out] re-ordered bsd, starting with the lead iteration dim at dim #0.</param>
            <param name="dimOffset">[Optional] offset for the dimension length. Some strided iterators use dim -1 instead of dim to save us some calculations inside inner loops.</param>
            <param name="strideFactor">Element sizes. Multiplied to the strides of the iteration bsd returned.</param>
        </member>
        <member name="M:ILNumerics.Core.Global.Helper.PrepareBSD4CopyTo(ILNumerics.StorageOrders,System.Int64*,System.Int64*,ILNumerics.Size,System.UInt32)">
            <summary>
            reorder inBSD for iteration according to storageOrder and store into ordered_bsd. initialize outBSD accordingly (strides may differ!).
            </summary>
            <param name="storageOrder"></param>
            <param name="inBSD"></param>
            <param name="ordered_bsd"></param>
            <param name="outBSD"></param>
            <param name="myBSD"></param>
            <param name="stride_factor"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.Global.Helper.PrepareBSD4CopyTo(ILNumerics.StorageOrders,System.Int64*,System.UInt32*,ILNumerics.Size,System.UInt32)">
            
            <summary>
            reorder inBSD for iteration according to storageOrder and store into ordered_bsd. initialize outBSD accordingly (strides may differ!).
            </summary>
            <param name="storageOrder"></param>
            <param name="inBSD"></param>
            <param name="ordered_bsd"></param>
            <param name="outBSD"></param>
            <param name="myBSD"></param>
            <param name="stride_factor"></param>
            <returns></returns>
            <remarks><para>ordered_bsd stores the dest BSD (original, reordered), dims + strides (corrected) for src</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Global.Helper.PrepareBSD4WriteTo(ILNumerics.Size,System.Int64*,System.UInt32,System.Int64*)">
            <summary>
            creates the bsd and strides for fast iteration in WriteTo functions
            </summary>
            <param name="inSize">size of input (right side) array.</param>
            <param name="ordered_bsd">temp BSD / dim / strides for iteration. This is expected to be at least of len: ndims * 3 + 3 for: (out)ndims, nelem, baseoffset, dims, strides, (in) strides</param>
            <param name="outBSD">size of destination (left side) array</param>
            <param name="stride_factor">stride size (elements byte) factor</param>
            <remarks><para>This function prepares the strides for iterating over the 
            output elements of the destination array efficiently: </para>
            <para>1) Dimensions are reordered to iterate along the dimension of the 
            destination array with the smallest strides.</para>
            <para>2) virtual dimensions in inSize are replaced with singleton dimensions, 
            so that the number of dimensions in inSize equals ndims of outSize.</para>
            <para>3) all singleton dimensions in inSize get a stride of 0 assigned.</para>
            <para>4) broadcasting is allowed on the right side only!</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Global.Helper.dims2string(System.Int64*,System.UInt32,System.Boolean)">
            <summary>
            Creates a comma separated list of indices in <paramref name="outDims"/> without limiting brackets or parantheses.
            </summary>
            <param name="outDims"></param>
            <param name="nrOutDims"></param>
            <param name="reverse">[Optional] reverse the listing of indices in <paramref name="nrOutDims"/>. Default: (false) list indices in the stored order.</param>
            <returns>String representation of the indices in <paramref name="nrOutDims"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Global.Helper.isfinite(System.Double)">
            <summary>
            Find out, if value is finite-
            </summary>
            <param name="input">Input value</param>
            <returns>1 for finite values</returns>
        </member>
        <member name="M:ILNumerics.Core.Global.Helper.isfinite(ILNumerics.complex)">
            <summary>
            Find out, if value is finite
            </summary>
            <param name="input">Input value</param>
            <returns>1 for finite values</returns>
        </member>
        <member name="M:ILNumerics.Core.Global.Helper.isfinite(System.Single)">
            <summary>
            Find out, if value is finite
            </summary>
            <param name="input">Input value</param>
            <returns>1 for finite values</returns>
        </member>
        <member name="M:ILNumerics.Core.Global.Helper.isfinite(ILNumerics.fcomplex)">
            <summary>
            Find out, if value is finite
            </summary>
            <param name="input">Input value</param>
            <returns>1 for finite values</returns>
        </member>
        <member name="T:ILNumerics.Core.Global.ThreadPool">
            <summary>
            Legacy thread pool. Handles Action[IntPt]. 
            </summary>
        </member>
        <member name="T:ILNumerics.Core.Global.ThreadPool`1">
            <summary>
            Simple, efficient thread pool implementation - THIS CLASS IS NOT THREAD SAFE !! 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Global.ThreadPool`1.Pool">
            <summary>
            Get the ThreadPool associated with the current thread.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Global.ThreadPool`1.MaxNumberThreads">
            <summary>
            Property returns the maximum number of threads used in pool.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Global.ThreadPool`1.#ctor(System.UInt32)">
            <summary>
            Constructor used to create a new ILThreadPool object.
            </summary>
            <param name="maxThreads">Initialize the pool with the given maximum number of threads.</param>
        </member>
        <member name="M:ILNumerics.Core.Global.ThreadPool`1.QueueUserWorkItem(System.UInt32,System.Action{`0},`0)">
            <summary>
            Enqueue a new work item for parallel processing in a worker thread.
            </summary>
            <param name="id">The id /index of the target thread.</param>
            <param name="action">Delegate with the work definition.</param>
            <param name="data">Data to be send to the delegate for processing.</param>
            <returns>True if the work chunk has been successfully enqueded and is ready for processing.</returns>
        </member>
        <member name="M:ILNumerics.Core.Global.ThreadPool`1.Wait4Workers(System.Int32@)">
            <summary>
            Synchronously wait until the variable referenced by <paramref name="workerCount"/> reached 0.
            </summary>
            <param name="workerCount">Variable to wait on.</param>
            <returns>Integer value indicating the time waited on the variable. Used for optimizing future operations in a feedback loop.</returns>
        </member>
        <member name="T:ILNumerics.Core.Global.ThreadPool`1.ThreadPoolWorkItem`1">
            <summary>
            Structure describing a single work item used to define a work chunk. 
            </summary>
        </member>
        <member name="F:ILNumerics.Core.Global.ThreadPool`1.ThreadPoolWorkItem`1.Action">
            <summary>
            Encapsulates a method that has a single parameter and does not return value.
            </summary>
        </member>
        <member name="F:ILNumerics.Core.Global.ThreadPool`1.ThreadPoolWorkItem`1.Data">
            <summary>
            ThreadPoolWorkItem data object.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Global.ThreadPool`1.Thread`1.End">
            <summary>
            Signal this thread to finish processing work items and to destroy itself ASAP.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Global.ThreadPool`1.Thread`1.Queue(ILNumerics.Core.Global.ThreadPool{`0}.ThreadPoolWorkItem{`1})">
            <summary>
            Queue a new work item for processing by this thread.
            </summary>
            <param name="workItem"></param>
        </member>
        <member name="P:ILNumerics.Core.DeviceManagement.Device.LA">
            <summary>
            Load access costs.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.DeviceManagement.Device.SA">
            <summary>
            Store access costs.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.DeviceManagement.Device.CostEnqueued">
            <summary>
            Approximate sum of currently enqueued workloads. This may be changed at anytime! 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.DeviceManagement.Device.MemoryPool">
            <summary>
            Thread local access to the (native) memory pool for this device. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.DeviceManagement.Device.Name">
            <summary>
            A name used to identify this device. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.DeviceManagement.Device.Index">
            <summary>
            The 0-based index of this device in the ordered set of devices currently avaiable on this system.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.DeviceManagement.Device.DeviceType">
            <summary>
            Gets the type(s) of the device. A bitfield with bits set according to values from <see cref="T:ILNumerics.DeviceTypes"/>.
            </summary>
            <seealso cref="!:CLDevice.IsTypeOf(DeviceTypes)"/>
            <seealso cref="!:CLDevice.SupportsDeviceProperty(ulong, DeviceInfos)"/>
        </member>
        <member name="P:ILNumerics.Core.DeviceManagement.Device.IsSVM">
            <summary>
            Flag indicating whether or not this device is part of a shared memory context, 
            accessing the computers main memory. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.Device.EnsureBufferAsync(ILNumerics.Core.CountableArray)">
            <summary>
            Ensures that a memory handle for the array exists on this device. Its content may not be ready yet, though. 
            </summary>
            <param name="handles"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.Device.IsLowMemory">
            <summary>
            Informs about the current system health, memory related. Derived classes implement device specific measures. This base implementation always returns false. 
            </summary>
            <returns>true if there is high memory pressure. Allocations should be limited.</returns>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.Device.GetMaxPoolSizeHint">
            <summary>
            Default maximum size of a memory pool: 200MB.
            </summary>
            <returns>Size in bytes. (200MB)</returns>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.Device.GetValue``1(ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt64)">
            <summary>
            Read a single value of type <typeparamref name="T"/> from the memory position <paramref name="handle"/> on this device.
            </summary>
            <typeparam name="T">The type of the value to read. Must derive from <see cref="T:System.ValueType"/>.</typeparam>
            <param name="index">The index of the first element of type <typeparamref name="T"/> to retrieve relative to the 
            start of the memory region referenced by <paramref name="handle"/>.</param>
            <param name="handle">Memory handle to the memory containing the value to be retrieved.</param>
            <returns>The value read from the memory address.</returns>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.Device.SetValue``1(``0,ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt64)">
            <summary>
            Store the <paramref name="value"/> at the memory with element position <paramref name="index"/> on this device.
            </summary>
            <typeparam name="T">The element type of <paramref name="value"/> (derived from <see cref="T:System.ValueType"/>).</typeparam>
            <param name="value">The new value to be written to the memory.</param>
            <param name="index">The element index of the element to be written.</param>
            <param name="handle">Memory handle to the memory containing the element whose value is going to be replaced. This handle must belong to this device.</param>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.Device.CopyFromHost(ILNumerics.Core.MemoryLayer.MemoryHandle,ILNumerics.Core.MemoryLayer.MemoryHandle,System.IntPtr,System.IntPtr)">
            <summary>
            Copy a range of memory from the host to this device. 
            </summary>
            <param name="hostHandle">Memory handle to host device.</param>
            <param name="deviceHandle">Memory handle to device memory.</param>
            <param name="offset">Offset of the first byte to read.</param>
            <param name="length">Number of bytes to copy.</param>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.Device.CopyToHost(ILNumerics.Core.MemoryLayer.MemoryHandle,ILNumerics.Core.MemoryLayer.MemoryHandle,System.IntPtr,System.IntPtr)">
            <summary>
            Copies a block of bytes from this device to the host memory. Blocking operation. Memory barrier for related handles.
            </summary>
            <param name="deviceHandle"></param>
            <param name="hostHandle"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.Device.Copy(ILNumerics.Core.MemoryLayer.MemoryHandle,ILNumerics.Core.MemoryLayer.MemoryHandle,System.IntPtr,System.IntPtr)">
            <summary>
            Copy memory onto the same device. 
            </summary>
            <param name="sourceHandle">Handle to memory on this device, the region to copy.</param>
            <param name="destHandle">Handle to the destination region, must be on this device.</param>
            <param name="offset">Start offset in bytes.</param>
            <param name="length">Number of bytes to copy. </param>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.Device.New``1(System.UInt64,System.Boolean)">
            <summary>
            Allocate new memory for the given number of elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="elementCount">Number of elements to store.</param>
            <param name="clear">[Optional] true: make sure the memory is cleared on return. Default: false.</param>
            <returns><see cref="T:ILNumerics.Core.MemoryLayer.NativeHostHandle"/> for structs, <see cref="T:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1"/> for reference types <typeparamref name="T"/>.</returns>
            <remarks>The handle returned has a reference count set to 0.</remarks>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.Device.New``1(System.UInt64,ILNumerics.Core.CountableArray)">
            <summary>
            Allocate memory on this OpenCL device and store it into <paramref name="A"/>. Suitable for shared memory devices.  
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="numberOfElements">Numbmer of elements to allocate.</param>
            <param name="A">Target for the new memory handle / buffer.</param>
        </member>
        <member name="T:ILNumerics.Core.DeviceManagement.DeviceManager">
            <summary>
            This class allows to access all <see cref="T:ILNumerics.Core.DeviceManagement.Device"/> objects available on the system.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.DeviceManager.GetDeviceCount">
            <summary>
            Gets the number of <see cref="T:ILNumerics.Core.DeviceManagement.Device"/>s currently available on the system. 
            </summary>
            <returns>Device count.</returns>
            <seealso cref="M:ILNumerics.Core.DeviceManagement.DeviceManager.GetDevice(System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.DeviceManagement.DeviceManager.GetDevices"/>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.DeviceManager.GetDevices">
            <summary>
            Gives the (original!) array of available <see cref="T:ILNumerics.Core.DeviceManagement.Device"/> objects. Use with care and do not change the elements! No copy is made for performance reasons!
            </summary>
            <returns>Direct reference to the array hosting <see cref="T:ILNumerics.Core.DeviceManagement.Device"/> objects available on the system.</returns>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.DeviceManager.GetDevice(System.UInt32)">
            <summary>
            Get the device stored at index <paramref name="i"/>.
            </summary>
            <param name="i">The index of the device in the array of devices.</param>
            <returns>The device pointed to by <paramref name="i"/>.</returns>
            <remarks><para>There will always be at least one <see cref="T:ILNumerics.Core.DeviceManagement.Device"/> on a system: the host device at index 0.</para>
            <para>Make sure to request indices for available devices only! <paramref name="i"/> must be <c>%gt;= 0</c> and lower than <see cref="M:ILNumerics.Core.DeviceManagement.DeviceManager.GetDeviceCount"/>.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.DeviceManager.Copy(ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt32,ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt32,System.UInt64,System.IntPtr)">
            <summary>
            Copy memory from one device to another device, potentially using the host as temporary storage. 
            </summary>
            <param name="source">Handle to the source memory.</param>
            <param name="sourceDevice">Index of the source memory device.</param>
            <param name="target">Handle to the target memory.</param>
            <param name="targetDevice">Index of the target device. </param>
            <param name="start">Offset / index of the first byte to copy from <paramref name="source"/>.</param>
            <param name="length">Number of bytes to copy.</param>
            <remarks><para>If <paramref name="sourceDevice"/> and <paramref name="targetDevice"/> are not equal the memory will 
            be stored on the host device first and copied to the <paramref name="target"/>, unless <paramref name="targetDevice"/> != 0.</para></remarks>
        </member>
        <member name="T:ILNumerics.Core.DeviceManagement.HostDevice">
            <summary>
            This class represents the host processor as ILNumerics device. It is used for all .NET based code.
            </summary>
        </member>
        <member name="F:ILNumerics.Core.DeviceManagement.HostDevice.m_memoryPool">
            <summary>
            The memory pool instance for the host. Unique for each local thread.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.DeviceManagement.HostDevice.MemoryPool">
            <summary>
            Thread local access to the (native) memory pool for this device. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.DeviceManagement.HostDevice.DeviceType">
            <summary>
            Gives the type (kind) of this device. This returns <see cref="F:ILNumerics.DeviceTypes.Host"/>.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.HostDevice.Copy(ILNumerics.Core.MemoryLayer.MemoryHandle,ILNumerics.Core.MemoryLayer.MemoryHandle,System.IntPtr,System.IntPtr)">
            <summary>
            Copy memory from <paramref name="source"/> to <paramref name="dest"/>, both from hosts virtual memory. 
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
            <param name="length"></param>
            <param name="offset"></param>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.HostDevice.Copy(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Copy memory from <paramref name="source"/> to <paramref name="dest"/>, both from hosts virtual memory. 
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
            <param name="length"></param>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.HostDevice.CopyToHost(ILNumerics.Core.MemoryLayer.MemoryHandle,ILNumerics.Core.MemoryLayer.MemoryHandle,System.IntPtr,System.IntPtr)">
            <summary>
            Copies device memory to the host. 
            </summary>
            <param name="deviceHandle"></param>
            <param name="hostHandle"></param>
            <param name="offset">Offset into the device handle.</param>
            <param name="length">Number of bytes to copy.</param>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.HostDevice.GetValue``1(ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt64)">
            <summary>
            Read a single value of type <typeparamref name="T"/> from the element position <paramref name="index"/> on this device.
            </summary>
            <typeparam name="T">The type of the value to read. Must derive from <see cref="T:System.ValueType"/>.</typeparam>
            <param name="index">The index of the first element of type <typeparamref name="T"/> to retrieve relative to the 
            start of the memory region referenced by <paramref name="handle"/>.</param>
            <param name="handle">Memory handle to the memory containing the value to be retrieved.</param>
            <returns>The value of the element addressed by <paramref name="index"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.HostDevice.SetValue``1(``0,ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt64)">
            <summary>
            Store the <paramref name="value"/> at the memory with element position <paramref name="index"/> on this device.
            </summary>
            <typeparam name="T">The element type of <paramref name="value"/> (derived from <see cref="T:System.ValueType"/>).</typeparam>
            <param name="value">The new value to be written to the memory.</param>
            <param name="index">The element index of the element to be written.</param>
            <param name="handle">Memory handle to the memory containing the element whose value is going to be replaced. This handle must belong to this device.</param>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.HostDevice.New``1(System.UInt64,System.Boolean)">
            <summary>
            Acquire a memory handle / array from this pool or create a new one. This class allows <typeparamref name="T"/> to be a reference type.
            </summary>
            <typeparam name="T">Type of elements which will be stored in the memory.</typeparam>
            <param name="elementCount">Number of elements. This determins the size of the memory required.</param>
            <param name="clear">[Optional] True: clear the element values. False: do not clear the elements (default).</param>
            <returns>A <see cref="T:ILNumerics.Core.MemoryLayer.NativeHostHandle"/> referencing a region of main (virtual) memory sufficient to store <paramref name="elementCount"/> elements of type <typeparamref name="T"/>.</returns>
            <remarks><para>The <see cref="T:ILNumerics.Core.DeviceManagement.HostDevice"/> allocates arrays for <see cref="T:System.ValueType"/> elements on 
            native process memory instead on the managed heap. Reference type elements, however, are allocated on the managed heap. 
            Hence, the handle returned will either be a <see cref="T:ILNumerics.Core.MemoryLayer.NativeHostHandle"/> or a <see cref="T:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1"/>. Note, both 
            categories of memory are managed in their own pools. In the case of <see cref="T:System.ValueType"/> elements and native storage 
            the new memory will - if possible - be taken from the <see cref="T:ILNumerics.Core.MemoryLayer.NativeHostPool"/> pool associated with the current thread and the host device. 
            For managed arrays the global, static, thread local pool <see cref="P:ILNumerics.Core.MemoryLayer.ManagedHostPool`1.Pool"/> is considered.</para></remarks>
            <seealso cref="T:ILNumerics.Core.MemoryLayer.NativeHostPool"/>
            <seealso cref="T:ILNumerics.Core.MemoryLayer.ManagedHostPool`1"/>
            <see cref="M:ILNumerics.Core.CountableArray.New``1(System.UInt64,System.UInt32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.DeviceManagement.HostDevice.EnsureBuffer(ILNumerics.Core.CountableArray)">
            <summary>
            Make sure up to-date data are available on the host memory (as NativeHostHandle).
            </summary>
            <param name="array">The array of handles whose data existence needs to be ensured for the host memory.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vec(System.Double,System.Double)">
            <summary>
            Creates vector of evenly spaced values over a closed interval, elements of <see cref="T:System.Double"/>.
            </summary>
            <param name="start">Start value, inclusive.</param>
            <param name="end">End value, inclusive.</param>
            <returns>Vector with n equally spaced elements from <paramref name="start"/> to <paramref name="end"/>, all with interval 1.</returns>
            <remarks>
            <para>The last element of the returned vector is less than or equal to <paramref name="end"/>.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vec(System.Double,System.Double)"/> can not create empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/> or the like to create empty arrays.</para>
            <para>This function is provided for compatibility with older versions only. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)"/> instead!</para>
            </remarks>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/><![CDATA[>]]> <paramref name="end"/>.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vec(System.Double,System.Double,System.Double)">
            <summary>
            Creates vector of evenly spaced values of certain step size over a closed interval, elements of <see cref="T:System.Double"/>.
            </summary>
            <param name="start">Start value, inclusive.</param>
            <param name="end">End value, inclusive.</param>
            <param name="step">Step value.</param>
            <returns>Vector with equally spaced elements from <paramref name="start"/> to <paramref name="end"/>, all with interval 1.</returns>
            <remarks>
            <para>The last element of the returned vector is less than or equal to <paramref name="end"/>.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vec(System.Double,System.Double,System.Double)"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vec(System.Double,System.Double)"/> can not create 
            empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/> or 
            the similar to create empty arrays.</para>
            <para>This function is provided for compatibility with older versions only. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)"/> instead!</para>
            </remarks>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/><![CDATA[>]]> <paramref name="end"/>.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vec``1(``0,``0)">
            <summary>
            Creates vector of evenly spaced values over a closed interval, elements of type <typeparamref name="T"/>.
            </summary>
            <param name="start">Start value, inclusive.</param>
            <param name="end">End value, inclusive.</param>
            <returns>Vector with n equally spaced elements from <paramref name="start"/> to <paramref name="end"/>, all with interval 1.</returns>
            <remarks><para>The last element of the returned vector is less than or equal to <paramref name="end"/>.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vec``1(``0,``0)"/> can not create empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/> or the like to create empty arrays.</para>
            <para>This function is provided for compatibility with older versions only. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)"/> instead!</para>
            </remarks>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/><![CDATA[>]]> <paramref name="end"/>, 
            if <typeparamref name="T"/> is not a supported numeric value type, if <paramref name="start"/> or <paramref name="end"/> is 
            not scalar, is null or is not of a supported numeric, convertible element type.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vec``1(``0,``0,``0)">
            <summary>
            Creates vector of N evenly spaced values of given step size over a closed interval, numeric, real elements of type <typeparamref name="T"/>.
            </summary>
            <param name="start">Start value.</param>
            <param name="step">Step size.</param>
            <param name="end">End value.</param>
            <returns>(Column) vector of length N.</returns>
            <remarks>
            <para>The function creates N values from <paramref name="start"/> to <paramref name="end"/>, all equally spaced with stepsize <paramref name="step"/>.<paramref name="step"/>.</para>
            <para>The last element of the returned vector will be less than or equal to <paramref name="end"/>, if <paramref name="start"/>
            <![CDATA[<]]> <paramref name="end"/>. </para>
            <para>If <paramref name="start"/> <![CDATA[>]]> <paramref name="end"/> elements in the vector will linearly <i>decrease</i> from 
            <paramref name="start"/> to <paramref name="end"/>. In this case, <paramref name="step"/> must be negative.</para>
            <para>Values are computed in the precision of the datatype <typeparamref name="T"/>. For integer <typeparamref name="T"/> this may imply rounding issues.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vec``1(``0,``0,``0)"/> can not create empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/> or the like to create empty arrays.</para>
            <para>This function is provided for compatibility with older versions only. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)"/> instead!</para>
            </remarks>
            <exception cref="T:System.ArgumentException"> if either of <paramref name="start"/>, <paramref name="end"/>, or
            <paramref name="step"/> is null, non-numeric, or non-scalar, if <paramref name="step"/> is 0 or the sign 
            of <paramref name="step"/> does not match the sign of 'end - start'.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange(System.Double,System.Double)">
            <summary>
            Creates vector of evenly spaced values over a closed interval, elements of <see cref="T:System.Double"/>.
            </summary>
            <param name="start">Start value, inclusive.</param>
            <param name="end">End value, inclusive.</param>
            <returns>Vector with n equally spaced elements from <paramref name="start"/> to <paramref name="end"/>, all with interval 1.</returns>
            <remarks>
            <para>The last element of the returned vector is less than or equal to <paramref name="end"/>.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange(System.Double,System.Double)"/> can not create empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/> or the like to create empty arrays.</para>
            </remarks>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/><![CDATA[>]]> <paramref name="end"/>.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange(System.Double,System.Double,System.Double)">
            <summary>
            Creates vector of evenly spaced values over a closed interval, elements of <see cref="T:System.Double"/>.
            </summary>
            <param name="start">Start value, inclusive.</param>
            <param name="end">End value, inclusive.</param>
            <param name="step">Step value.</param>
            <returns>Vector with n equally spaced elements from <paramref name="start"/> to <paramref name="end"/>, all with interval 1.</returns>
            <remarks>
            <para>The last element of the returned vector is less than or equal to <paramref name="end"/>.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange(System.Double,System.Double)"/> can not create empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/> or the like to create empty arrays.</para>
            </remarks>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/><![CDATA[>]]> <paramref name="end"/>.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``1(``0,``0)">
            <summary>
            Creates vector of evenly spaced values over a closed interval, elements of type <typeparamref name="T"/>.
            </summary>
            <param name="start">Start value, inclusive.</param>
            <param name="end">End value, inclusive.</param>
            <returns>Vector with n equally spaced elements from <paramref name="start"/> to <paramref name="end"/>, all with interval 1.</returns>
            <remarks><para>The last element of the returned vector is less than or equal to <paramref name="end"/>.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``1(``0,``0)"/> can not create empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/> or the like to create empty arrays.</para>
            </remarks>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/><![CDATA[>]]> <paramref name="end"/>, 
            if <typeparamref name="T"/> is not a supported numeric value type, if <paramref name="start"/> or <paramref name="end"/> is 
            not scalar, is null or is not of a supported numeric, convertible element type.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)">
            <summary>
            Creates vector of N evenly spaced values of given step size over a closed interval, numeric, real elements of type <typeparamref name="T"/>.
            </summary>
            <param name="start">Start value.</param>
            <param name="step">Step size.</param>
            <param name="end">End value.</param>
            <returns>(Column) vector of length N.</returns>
            <remarks>
            <para>The function creates N values from <paramref name="start"/> to <paramref name="end"/>, all equally spaced with stepsize <paramref name="step"/>.<paramref name="step"/>.</para>
            <para>The last element of the returned vector will be less than or equal to <paramref name="end"/>, if <paramref name="start"/>
            <![CDATA[<]]> <paramref name="end"/>. </para>
            <para>If <paramref name="start"/> <![CDATA[>]]> <paramref name="end"/> elements in the vector will linearly <i>decrease</i> from 
            <paramref name="start"/> to <paramref name="end"/>. In this case, <paramref name="step"/> must be negative.</para>
            <para>Values are computed in the precision of the datatype <typeparamref name="T"/>. For integer <typeparamref name="T"/> this may imply rounding issues.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)"/> can not create empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/> or the like to create empty arrays.</para>
            </remarks>
            <exception cref="T:System.ArgumentException"> if either of <paramref name="start"/>, <paramref name="end"/>, or
            <paramref name="step"/> is null, non-numeric, or non-scalar, if <paramref name="step"/> is 0 or the sign 
            of <paramref name="step"/> does not match the sign of 'end - start'.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array, all elements initialized with the given value.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="val">The value for the new elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with <paramref name="val"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array, all elements initialized with the given value.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="val">The value for the new elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with <paramref name="val"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array, all elements initialized with the given value.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="val">The value for the new elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with <paramref name="val"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array, all elements initialized with the given value.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="val">The value for the new elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with <paramref name="val"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array, all elements initialized with the given value.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="val">The value for the new elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with <paramref name="val"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array, all elements initialized with the given value.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="val">The value for the new elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with <paramref name="val"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array, all elements initialized with the given value.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="val">The value for the new elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <param name="dim6">Length of dimension #6.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with <paramref name="val"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,ILNumerics.Size,ILNumerics.StorageOrders)">
            <summary>
            Create new array, fill elements with constant value
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="value">Constant value for all elements.</param>
            <param name="size">Size of new array</param>
            <param name="order">[Optional] storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"></see>.</param>
            <returns>New array according to size with all elements set to 'value'</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
            <summary>
            Creates new array of dimension lengths, with all elements having the same value <paramref name="val"/>. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="val">The target element value.</param>
            <param name="size">Vector with dimension lengths, as created by Math.size().</param>
            <param name="order">[Optional] storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"></see>.</param>
            <returns>New array as specified.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0[],ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array from the values provided in <paramref name="values"/> with the shape given by <paramref name="size"/>.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="values">Values to be copied to the new ILNumerics array.</param>
            <param name="size">The size of the new ILNumerics array. Number of elements must correspond to the number of values in <paramref name="values"/>.</param>
            <param name="order">[Optional] Storage order for the new ILNumerics array. Default: (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</param>
            <returns>A new ILNumerics array with copies of the given values and the given shape.</returns>
            <remarks>A copy is made from <paramref name="values"/>. The array <paramref name="values"/> is not referenced 
            by ILNumerics after the function returns.
            <para>Make sure that the number of elements configured by the dimension lengths in <paramref name="size"/>
            match the number of values of <paramref name="values"/>.</para>
            <para>This function is a convenience alias for 'vector(<paramref name="values"/>).Reshape(<paramref name="size"/>,<paramref name="order"/>)'.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0[0:,0:])">
            <summary>
            Creates a new ILNumerics array from a 2D System.Array <paramref name="values"/> with the shape of <paramref name="values"/> in <see cref="F:ILNumerics.StorageOrders.RowMajor"/> order.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="values">Values to be copied to the new ILNumerics array.</param>
            <returns>A new ILNumerics array with copies of the given values and the given shape.</returns>
            <remarks>A copy is made from <paramref name="values"/>. The array <paramref name="values"/> is not referenced 
            by ILNumerics after the function returns.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0[0:,0:,0:])">
            <summary>
            Creates a new ILNumerics array from a 3D System.Array <paramref name="values"/> with the shape of <paramref name="values"/> in <see cref="F:ILNumerics.StorageOrders.RowMajor"/> order.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="values">Values to be copied to the new ILNumerics array.</param>
            <returns>A new ILNumerics array with copies of the given values and the given shape.</returns>
            <remarks>A copy is made from <paramref name="values"/>. The array <paramref name="values"/> is not referenced 
            by ILNumerics after the function returns.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0[0:,0:,0:,0:])">
            <summary>
            Creates a new ILNumerics array from a 4D System.Array <paramref name="values"/> with the shape of <paramref name="values"/> in <see cref="F:ILNumerics.StorageOrders.RowMajor"/> order.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="values">Values to be copied to the new ILNumerics array.</param>
            <returns>A new ILNumerics array with copies of the given values and the given shape.</returns>
            <remarks>A copy is made from <paramref name="values"/>. The array <paramref name="values"/> is not referenced 
            by ILNumerics after the function returns.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int32[])">
            <summary>
            Create new array, fill element with constant value
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="value">Constant value for all elements</param>
            <param name="size">Size of new array</param>
            <returns>New array according to size with all elements set to 'value'</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0[])">
            <summary>
            Creates a vector from <paramref name="values"/>. Column major storage.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="values">Variable number of values for the new vector.</param>
            <returns>A vector of <typeparamref name="T"/> elements, 1D in numpy array style, a column vector otherwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(ILNumerics.Size,``0[])">
            <summary>
            Creates an array from <paramref name="values"/> and <paramref name="size"/>. Column major storage.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="size">Source size descriptor providing the dimension lengths for the new array.</param>
            <param name="values">Values for the new array.</param>
            <returns>Array of <typeparamref name="T"/> elements and a size according to <paramref name="size"/>.</returns>
            <exception cref="T:System.ArgumentException">if the size given by <paramref name="size"/> does not match the number of <paramref name="values"/> provided.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0[],System.Int32[])">
            <summary>
            Creates an array from <paramref name="values"/> and <paramref name="size"/>. Column major storage.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="size">Size descriptor providing the dimension lengths for the new array.</param>
            <param name="values">Values for the new array will be copied from this System.Array.</param>
            <returns>Array of <typeparamref name="T"/> elements and a size according to <paramref name="size"/>.</returns>
            <exception cref="T:System.ArgumentException">if the size given by <paramref name="size"/> does not match the number of <paramref name="values"/> provided.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0[],ILNumerics.Size)">
            <summary>
            Creates an array from <paramref name="values"/>. Column major storage.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="size">Source size descriptor providing the dimension lengths for the new array.</param>
            <param name="values">Values for the new array.</param>
            <returns>Array of <typeparamref name="T"/> elements and a size according to <paramref name="size"/>.</returns>
            <exception cref="T:System.ArgumentException">if the size given by <paramref name="size"/> does not match the number of <paramref name="values"/> provided.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(ILNumerics.InArray{System.Int64},System.Collections.Generic.IEnumerable{``0},ILNumerics.StorageOrders)">
            <summary>
            Creates an ILNumerics array from <see cref="T:System.Collections.Generic.IEnumerable`1"/>. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="values">Enumerable with values for the new array.</param>
            <param name="size">[Optional] size for the new array. Default: (null) creates a vector according to the number of given values.</param>
            <param name="order">[Optional] Storage order for the new cell. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>ILNumerics array with shallow copy of the values taken from <paramref name="values"/>.</returns>
            <remarks><para>If <paramref name="size"/> is provided the number of elements as determined by the number and lengths of 
            dimensions in <paramref name="size"/> must match the actual number of elements found in <paramref name="values"/>.</para>
            <para><paramref name="values"/> is iterated exactly once.</para>
            <para>If <typeparamref name="T"/> is a reference type and/or <see cref="T:System.IDisposable"/> a shallow copy 
            of the reference value is made only. No interface methods are called on the elements of <paramref name="values"/>.</para>
            <para>If both, <paramref name="size"/> and <paramref name="values"/> are null, an empty array is returned.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cell(ILNumerics.InArray{System.Int64},System.Collections.Generic.IEnumerable{ILNumerics.BaseArray},ILNumerics.StorageOrders)">
             <summary>
             Creates new cell, initialize size and provide arrays for cell elements.
             </summary>
             <param name="size">[Optional] Size hint for the new cell array. Default: (null) Derive the size from <paramref name="arrays"/>.</param>
             <param name="arrays">[Optional] Enumerable of arrays for the cell elements, column major order. Default: (null) creates cell with all 'null' elements.</param>
             <param name="order">[Optional] Storage order for the new cell. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
             <returns>Cell of specified size, initialized with given arrays.</returns>
             <remarks><para>If number of arrays given is smaller than the number of elements given by 
             <paramref name="size"/> then trailing elements in the cell returned are set to null.</para>
             <para>If <paramref name="size"/> is null a cell vector is produced with a length corresponding to the number of elements in <paramref name="arrays"/>.
             Performance wise it is recommended to specify the <paramref name="size"/> explicitly, though.</para>
             <para>If <paramref name="arrays"/> contains more elements than expected by <paramref name="size"/> an error is generated.</para>
             <para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.size(System.Int64,System.Int64,System.Int64,System.Int64)"/> function or one of its overloads are
             convenient for the specification of dimensional size arguments.</para>
             <para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="Main">online documentation</a> for cell.</para>
             <para>Note that when <paramref name="arrays"/> is an ILNumerics array (as in the example where <paramref name="arrays"/> 
             was created by the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0)"/> function) memory management 
             is performed accordingly: arrays stored in the <paramref name="arrays"/> object are released and the associated 
             memory is released to the pool after the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.cell(ILNumerics.InArray{System.Int64},System.Collections.Generic.IEnumerable{ILNumerics.BaseArray},ILNumerics.StorageOrders)"/> function returns. 
             However, for <paramref name="arrays"/> of other (non-ILNumerics) types proper memory management is not guaranteed. For 
             example, when providing the target cell element values in a <see cref="T:System.Array"/> of <see cref="T:ILNumerics.BaseArray"/> a copy 
             of individual elements is made by the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.cell(ILNumerics.InArray{System.Int64},System.Collections.Generic.IEnumerable{ILNumerics.BaseArray},ILNumerics.StorageOrders)"/> function before storing 
             the new element into the cell object. The source object remains an element of the system array and is not released! </para>
             <para>Therefore, in situations where performance is critical and inside loops use one of the ILNumerics array intialization 
             functions for providing the <paramref name="arrays"/> argument. Otherwise, temporary objects in the <see cref="T:System.Collections.Generic.IEnumerable`1"/> 
             may remain live and are left for the GC to clean up (which is fine, except for high performance demands).</para>
             </remarks>
             <example><![CDATA[
             <code>
             Array<double> A = rand(10,20,30); 
             Cell C = cell(size(3,2),vector<BaseArray>(A, A+1, zeros<float>(2,3), "4th element")); 
             //Alternatives: 
             //Cell C = cell(size(3,2),new [] { A, A+1, zeros(2,3) }); 
             //Cell C = cell(size(3,2),row(A, A+1, zeros(2,3))); 
             C
            >Cell [3,2]
            >    [0]:         
            >    [1]:     {<Double> [10,20,30]}         {<String> [1,1]}
            >    [2]:     {<Double> [10,20,30]}                   {null}
            >    [3]:          {<Single> [2,3]}                   {null}
             </code>]]>
             </example>
             <exception cref="T:System.ArgumentException"> if <paramref name="size"/> is not null and the number of elements found in <paramref name="arrays"/> exceeds 
             the expected number of elements as specified by <paramref name="size"/>.</exception>
             <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.cellv(ILNumerics.BaseArray[])"/>
             <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0)"/>
             <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape``1(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cell(ILNumerics.BaseArray[],System.Int32[])">
            <summary>
            Create cell, initialize with arrays and size.
            </summary>
            <param name="values">Predefined system array with ILNumerics arrays as elements to be stored into the new cell.</param>
            <param name="size">Size of the new cell array.</param>
            <returns>Cell with size of <paramref name="size"/> and elements from <paramref name="values"/></returns>
            <remarks><para>The arrays given in <paramref name="values"/> are stored into the new cell as 
            individual cell elements. As for all cell elements, a (lazy) clone is made prior to 
            storing the arrays into the cell. Therefore, the arrays are properly protected from 
            changes from outside the cell.</para>
            <para>This function is deprecated and will be removed in a future version. Consider 
            using <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.cell(ILNumerics.InArray{System.Int64},System.Collections.Generic.IEnumerable{ILNumerics.BaseArray},ILNumerics.StorageOrders)"/> instead which does not
            rely on <c>params</c> arguments.</para>
            <para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="Main">online documentation</a> for cell.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.cell(ILNumerics.InArray{System.Int64},System.Collections.Generic.IEnumerable{ILNumerics.BaseArray},ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.row``1(``0[])">
            <summary>
            Creates a row vector. This function is deprecated. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0[])"/> and <see cref="!:reshape&lt;T&gt;(InArray&lt;T&gt;, long, StorageOrders?)"/> instead.
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="elements">Elements of the row vector.</param>
            <returns>New row vector.</returns>
            <remarks><para>The same effect is achieved by: <![CDATA[<c>vector<T>(elements).Reshape(1, Equals(elements, null) ? 0 : elements.Length)</c>]]>.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.column``1(``0[])">
            <summary>
            Creates a column vector. This function is deprecated. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0[])"/> instead.
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="elements">Elements of the column vector.</param>
            <returns>New column vector.</returns>
            <remarks><para>The same effect is achieved by: <![CDATA[<c>vector<T>(elements).Reshape(Equals(elements, null) ? 0 : elements.Length, 1)</c>]]>.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)">
            <summary>
            Create new array with the elements of <paramref name="A"/> and <paramref name="B"/> concatenated along dimension <paramref name="dim"/>.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The other array.</param>
            <param name="dim">Dimension index to align both arrays elements along.</param>
            <returns>New array with elements of <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>The size of both arrays must match. This means that all but the dimension #<paramref name="dim"/>
            must have the same lengths.</para></remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="dim"/> is not within the range of dimensions of the arrays or if the sizes of <paramref name="A"/> and <paramref name="B"/> do not match.</exception>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> or <paramref name="B"/> are null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter(System.Double,System.Double,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array with regularly spaced element values in double precision.
            </summary>
            <param name="start">The start value for the new elements.</param>
            <param name="step">The step size value for the new elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter(System.Double,System.Double,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array with regularly spaced element values, double precision.
            </summary>
            <param name="start">The start value for the new elements.</param>
            <param name="step">The step size value for the new elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter(System.Double,System.Double,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array with regularly spaced element values, double precision.
            </summary>
            <param name="start">The start value for the new elements.</param>
            <param name="step">The step size value for the new elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter(System.Double,System.Double,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array with regularly spaced element values, double precision.
            </summary>
            <param name="start">The start value for the new elements.</param>
            <param name="step">The step size value for the new elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter(System.Double,System.Double,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array with regularly spaced element values, double precision.
            </summary>
            <param name="start">The start value for the new elements.</param>
            <param name="step">The step size value for the new elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter(System.Double,System.Double,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array with regularly spaced element values, double precision.
            </summary>
            <param name="start">The start value for the new elements.</param>
            <param name="step">The step size value for the new elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter(System.Double,System.Double,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array with regularly spaced element values, double precision.
            </summary>
            <param name="start">The start value for the new elements.</param>
            <param name="step">The step size value for the new elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <param name="dim6">Length of dimension #6.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter(System.Int32[])">
            <summary>
            Create an array with regularly (stepsize 1) spaced elements in multiple dimensions of provided lenghts. 
            </summary>
            <param name="sizes">Dimension lengths.</param>
            <returns>New ILNumerics array, initialized with elements starting at 1, increasing by 1 for each next element along the columns.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
             <summary>
             Creates a new ILNumerics array with regularly spaced element values.
             </summary>
             <typeparam name="T">Element type.</typeparam>
             <param name="start">The start value for the new elements.</param>
             <param name="step">The step size value for the new elements.</param>
             <param name="size">Dimension lengths as vector.</param>
             <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
             <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
             <remarks><para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> function and the corresponding
             overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)"/>,... 
             create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start"/> value and a <paramref name="step"/> value. 
             The size of the new array is determined by the <paramref name="size"/> parameter(s). The firsts element value is assigned 
             the <paramref name="start"/> value. Subsequent values are computed by adding the value of <paramref name="step"/> to each elements predecessor.</para>
             <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1, 
             where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
             <para>The storage order is determined by <paramref name="order"/>. By default, elements are lined up in memory 
             in column major storage order. <paramref name="order"/> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> 
             or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>. Note, how the storage order affects the order of values in the new array.</para></remarks>
             <example>
             <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
             <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
             //<Double> [4,3] 1...12 |
             //    [0]:           1          5          9
             //    [1]:           2          6         10
             //    [2]:           3          7         11
             //    [3]:           4          8         12]]>
            </code> 
            <para>Creating a new array of size [4,3,2] of ushort values: </para>
            <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
             //<SByte> [4,3] 1...12 |
             //    [0]: (:,:,0)
             //    [1]:    10  -30  -70
             //    [2]:     0  -40  -80
             //    [3]:   -10  -50  -90
             //    [4]:   -20  -60 -100
             //    [5]: (:,:,1)
             //    [6]:  -110  106   66
             //    [7]:  -120   96   56
             //    [8]:   126   86   46
             //    [9]:   116   76   36]]></code> 
             <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte' 
             without notice!</para>
            <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
            <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
             //<Single> [4,3] 1...12 -
             //    [0]:           1          2          3
             //    [1]:           4          5          6
             //    [2]:           7          8          9
             //    [3]:          10         11         12
             //]]></code> 
             </example>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)">
             <summary>
             Creates a new ILNumerics array with regularly spaced element values.
             </summary>
             <typeparam name="T">Element type.</typeparam>
             <param name="start">The start value for the new elements.</param>
             <param name="step">The step size value for the new elements.</param>
             <param name="dim0">Length of dimension #0.</param>
             <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
             <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
             <remarks><para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> function and the corresponding
             overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)"/>,... 
             create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start"/> value and a <paramref name="step"/> value. 
             The size of the new array is determined by the 'size' parameter(s). The firsts element value is assigned 
             the <paramref name="start"/> value. Subsequent values are computed by adding the value of <paramref name="step"/> to each elements predecessor.</para>
             <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1, 
             where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
             <para>The storage order is determined by <paramref name="order"/>. By default, elements are lined up in memory 
             in column major storage order. <paramref name="order"/> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> 
             or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>. Note, how the storage order affects the order of values in the new array.</para></remarks>
             <example>
             <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
             <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
             //<Double> [4,3] 1...12 |
             //    [0]:           1          5          9
             //    [1]:           2          6         10
             //    [2]:           3          7         11
             //    [3]:           4          8         12]]>
            </code> 
            <para>Creating a new array of size [4,3,2] of ushort values: </para>
            <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
             //<SByte> [4,3] 1...12 |
             //    [0]: (:,:,0)
             //    [1]:    10  -30  -70
             //    [2]:     0  -40  -80
             //    [3]:   -10  -50  -90
             //    [4]:   -20  -60 -100
             //    [5]: (:,:,1)
             //    [6]:  -110  106   66
             //    [7]:  -120   96   56
             //    [8]:   126   86   46
             //    [9]:   116   76   36]]></code> 
             <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte' 
             without notice!</para>
            <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
            <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
             //<Single> [4,3] 1...12 -
             //    [0]:           1          2          3
             //    [1]:           4          5          6
             //    [2]:           7          8          9
             //    [3]:          10         11         12
             //]]></code> 
             </example>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)">
             <summary>
             Creates a new ILNumerics array with regularly spaced element values.
             </summary>
             <typeparam name="T">Element type.</typeparam>
             <param name="start">The start value for the new elements.</param>
             <param name="step">The step size value for the new elements.</param>
             <param name="dim0">Length of dimension #0.</param>
             <param name="dim1">Length of dimension #1.</param>
             <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
             <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
             <remarks><para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> function and the corresponding
             overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)"/>,... 
             create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start"/> value and a <paramref name="step"/> value. 
             The size of the new array is determined by the 'size' parameter(s). The firsts element value is assigned 
             the <paramref name="start"/> value. Subsequent values are computed by adding the value of <paramref name="step"/> to each elements predecessor.</para>
             <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1, 
             where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
             <para>The storage order is determined by <paramref name="order"/>. By default, elements are lined up in memory 
             in column major storage order. <paramref name="order"/> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> 
             or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>. Note, how the storage order affects the order of values in the new array.</para></remarks>
             <example>
             <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
             <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
             //<Double> [4,3] 1...12 |
             //    [0]:           1          5          9
             //    [1]:           2          6         10
             //    [2]:           3          7         11
             //    [3]:           4          8         12]]>
            </code> 
            <para>Creating a new array of size [4,3,2] of ushort values: </para>
            <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
             //<SByte> [4,3] 1...12 |
             //    [0]: (:,:,0)
             //    [1]:    10  -30  -70
             //    [2]:     0  -40  -80
             //    [3]:   -10  -50  -90
             //    [4]:   -20  -60 -100
             //    [5]: (:,:,1)
             //    [6]:  -110  106   66
             //    [7]:  -120   96   56
             //    [8]:   126   86   46
             //    [9]:   116   76   36]]></code> 
             <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte' 
             without notice!</para>
            <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
            <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
             //<Single> [4,3] 1...12 -
             //    [0]:           1          2          3
             //    [1]:           4          5          6
             //    [2]:           7          8          9
             //    [3]:          10         11         12
             //]]></code> 
             </example>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
             <summary>
             Creates a new ILNumerics array with regularly spaced element values.
             </summary>
             <typeparam name="T">Element type.</typeparam>
             <param name="start">The start value for the new elements.</param>
             <param name="step">The step size value for the new elements.</param>
             <param name="dim0">Length of dimension #0.</param>
             <param name="dim1">Length of dimension #1.</param>
             <param name="dim2">Length of dimension #2.</param>
             <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
             <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
             <remarks><para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> function and the corresponding
             overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)"/>,... 
             create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start"/> value and a <paramref name="step"/> value. 
             The size of the new array is determined by the 'size' parameter(s). The firsts element value is assigned 
             the <paramref name="start"/> value. Subsequent values are computed by adding the value of <paramref name="step"/> to each elements predecessor.</para>
             <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1, 
             where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
             <para>The storage order is determined by <paramref name="order"/>. By default, elements are lined up in memory 
             in column major storage order. <paramref name="order"/> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> 
             or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>. Note, how the storage order affects the order of values in the new array.</para></remarks>
             <example>
             <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
             <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
             //<Double> [4,3] 1...12 |
             //    [0]:           1          5          9
             //    [1]:           2          6         10
             //    [2]:           3          7         11
             //    [3]:           4          8         12]]>
            </code> 
            <para>Creating a new array of size [4,3,2] of ushort values: </para>
            <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
             //<SByte> [4,3] 1...12 |
             //    [0]: (:,:,0)
             //    [1]:    10  -30  -70
             //    [2]:     0  -40  -80
             //    [3]:   -10  -50  -90
             //    [4]:   -20  -60 -100
             //    [5]: (:,:,1)
             //    [6]:  -110  106   66
             //    [7]:  -120   96   56
             //    [8]:   126   86   46
             //    [9]:   116   76   36]]></code> 
             <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte' 
             without notice!</para>
            <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
            <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
             //<Single> [4,3] 1...12 -
             //    [0]:           1          2          3
             //    [1]:           4          5          6
             //    [2]:           7          8          9
             //    [3]:          10         11         12
             //]]></code> 
             </example>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
             <summary>
             Creates a new ILNumerics array with regularly spaced element values.
             </summary>
             <typeparam name="T">Element type.</typeparam>
             <param name="start">The start value for the new elements.</param>
             <param name="step">The step size value for the new elements.</param>
             <param name="dim0">Length of dimension #0.</param>
             <param name="dim1">Length of dimension #1.</param>
             <param name="dim2">Length of dimension #2.</param>
             <param name="dim3">Length of dimension #3.</param>
             <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
             <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
             <remarks><para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> function and the corresponding
             overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)"/>,... 
             create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start"/> value and a <paramref name="step"/> value. 
             The size of the new array is determined by the 'size' parameter(s). The firsts element value is assigned 
             the <paramref name="start"/> value. Subsequent values are computed by adding the value of <paramref name="step"/> to each elements predecessor.</para>
             <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1, 
             where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
             <para>The storage order is determined by <paramref name="order"/>. By default, elements are lined up in memory 
             in column major storage order. <paramref name="order"/> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> 
             or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>. Note, how the storage order affects the order of values in the new array.</para></remarks>
             <example>
             <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
             <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
             //<Double> [4,3] 1...12 |
             //    [0]:           1          5          9
             //    [1]:           2          6         10
             //    [2]:           3          7         11
             //    [3]:           4          8         12]]>
            </code> 
            <para>Creating a new array of size [4,3,2] of ushort values: </para>
            <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
             //<SByte> [4,3] 1...12 |
             //    [0]: (:,:,0)
             //    [1]:    10  -30  -70
             //    [2]:     0  -40  -80
             //    [3]:   -10  -50  -90
             //    [4]:   -20  -60 -100
             //    [5]: (:,:,1)
             //    [6]:  -110  106   66
             //    [7]:  -120   96   56
             //    [8]:   126   86   46
             //    [9]:   116   76   36]]></code> 
             <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte' 
             without notice!</para>
            <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
            <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
             //<Single> [4,3] 1...12 -
             //    [0]:           1          2          3
             //    [1]:           4          5          6
             //    [2]:           7          8          9
             //    [3]:          10         11         12
             //]]></code> 
             </example>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
             <summary>
             Creates a new ILNumerics array with regularly spaced element values.
             </summary>
             <typeparam name="T">Element type.</typeparam>
             <param name="start">The start value for the new elements.</param>
             <param name="step">The step size value for the new elements.</param>
             <param name="dim0">Length of dimension #0.</param>
             <param name="dim1">Length of dimension #1.</param>
             <param name="dim2">Length of dimension #2.</param>
             <param name="dim3">Length of dimension #3.</param>
             <param name="dim4">Length of dimension #4.</param>
             <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
             <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
             <remarks><para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> function and the corresponding
             overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)"/>,... 
             create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start"/> value and a <paramref name="step"/> value. 
             The size of the new array is determined by the 'size' parameter(s). The firsts element value is assigned 
             the <paramref name="start"/> value. Subsequent values are computed by adding the value of <paramref name="step"/> to each elements predecessor.</para>
             <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1, 
             where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
             <para>The storage order is determined by <paramref name="order"/>. By default, elements are lined up in memory 
             in column major storage order. <paramref name="order"/> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> 
             or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>. Note, how the storage order affects the order of values in the new array.</para></remarks>
             <example>
             <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
             <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
             //<Double> [4,3] 1...12 |
             //    [0]:           1          5          9
             //    [1]:           2          6         10
             //    [2]:           3          7         11
             //    [3]:           4          8         12]]>
            </code> 
            <para>Creating a new array of size [4,3,2] of ushort values: </para>
            <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
             //<SByte> [4,3] 1...12 |
             //    [0]: (:,:,0)
             //    [1]:    10  -30  -70
             //    [2]:     0  -40  -80
             //    [3]:   -10  -50  -90
             //    [4]:   -20  -60 -100
             //    [5]: (:,:,1)
             //    [6]:  -110  106   66
             //    [7]:  -120   96   56
             //    [8]:   126   86   46
             //    [9]:   116   76   36]]></code> 
             <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte' 
             without notice!</para>
            <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
            <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
             //<Single> [4,3] 1...12 -
             //    [0]:           1          2          3
             //    [1]:           4          5          6
             //    [2]:           7          8          9
             //    [3]:          10         11         12
             //]]></code> 
             </example>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
             <summary>
             Creates a new ILNumerics array with regularly spaced element values.
             </summary>
             <typeparam name="T">Element type.</typeparam>
             <param name="start">The start value for the new elements.</param>
             <param name="step">The step size value for the new elements.</param>
             <param name="dim0">Length of dimension #0.</param>
             <param name="dim1">Length of dimension #1.</param>
             <param name="dim2">Length of dimension #2.</param>
             <param name="dim3">Length of dimension #3.</param>
             <param name="dim4">Length of dimension #4.</param>
             <param name="dim5">Length of dimension #5.</param>
             <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
             <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
             <remarks><para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> function and the corresponding
             overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)"/>,... 
             create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start"/> value and a <paramref name="step"/> value. 
             The size of the new array is determined by the 'size' parameter(s). The firsts element value is assigned 
             the <paramref name="start"/> value. Subsequent values are computed by adding the value of <paramref name="step"/> to each elements predecessor.</para>
             <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1, 
             where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
             <para>The storage order is determined by <paramref name="order"/>. By default, elements are lined up in memory 
             in column major storage order. <paramref name="order"/> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> 
             or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>. Note, how the storage order affects the order of values in the new array.</para></remarks>
             <example>
             <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
             <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
             //<Double> [4,3] 1...12 |
             //    [0]:           1          5          9
             //    [1]:           2          6         10
             //    [2]:           3          7         11
             //    [3]:           4          8         12]]>
            </code> 
            <para>Creating a new array of size [4,3,2] of ushort values: </para>
            <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
             //<SByte> [4,3] 1...12 |
             //    [0]: (:,:,0)
             //    [1]:    10  -30  -70
             //    [2]:     0  -40  -80
             //    [3]:   -10  -50  -90
             //    [4]:   -20  -60 -100
             //    [5]: (:,:,1)
             //    [6]:  -110  106   66
             //    [7]:  -120   96   56
             //    [8]:   126   86   46
             //    [9]:   116   76   36]]></code> 
             <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte' 
             without notice!</para>
            <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
            <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
             //<Single> [4,3] 1...12 -
             //    [0]:           1          2          3
             //    [1]:           4          5          6
             //    [2]:           7          8          9
             //    [3]:          10         11         12
             //]]></code> 
             </example>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
             <summary>
             Creates a new ILNumerics array with regularly spaced element values.
             </summary>
             <typeparam name="T">Element type.</typeparam>
             <param name="start">The start value for the new elements.</param>
             <param name="step">The step size value for the new elements.</param>
             <param name="dim0">Length of dimension #0.</param>
             <param name="dim1">Length of dimension #1.</param>
             <param name="dim2">Length of dimension #2.</param>
             <param name="dim3">Length of dimension #3.</param>
             <param name="dim4">Length of dimension #4.</param>
             <param name="dim5">Length of dimension #5.</param>
             <param name="dim6">Length of dimension #6.</param>
             <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
             <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start"/> and counting up/downwards by <paramref name="step"/> along the storage order.</returns>
             <remarks><para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> function and the corresponding
             overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)"/>,... 
             create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start"/> value and a <paramref name="step"/> value. 
             The size of the new array is determined by the 'size' parameter(s). The firsts element value is assigned 
             the <paramref name="start"/> value. Subsequent values are computed by adding the value of <paramref name="step"/> to each elements predecessor.</para>
             <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1, 
             where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
             <para>The storage order is determined by <paramref name="order"/>. By default, elements are lined up in memory 
             in column major storage order. <paramref name="order"/> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> 
             or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>. Note, how the storage order affects the order of values in the new array.</para></remarks>
             <example>
             <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
             <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
             //<Double> [4,3] 1...12 |
             //    [0]:           1          5          9
             //    [1]:           2          6         10
             //    [2]:           3          7         11
             //    [3]:           4          8         12]]>
            </code> 
            <para>Creating a new array of size [4,3,2] of ushort values: </para>
            <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
             //<SByte> [4,3] 1...12 |
             //    [0]: (:,:,0)
             //    [1]:    10  -30  -70
             //    [2]:     0  -40  -80
             //    [3]:   -10  -50  -90
             //    [4]:   -20  -60 -100
             //    [5]: (:,:,1)
             //    [6]:  -110  106   66
             //    [7]:  -120   96   56
             //    [8]:   126   86   46
             //    [9]:   116   76   36]]></code> 
             <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte' 
             without notice!</para>
            <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
            <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
             //<Single> [4,3] 1...12 -
             //    [0]:           1          2          3
             //    [1]:           4          5          6
             //    [2]:           7          8          9
             //    [3]:          10         11         12
             //]]></code> 
             </example>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1">
            <summary>
            Create empty array with 0 elements of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Element type of the array returned.</typeparam>
            <returns>Empty array with smallest possible number of dimensions and 0 elements.</returns>
            <remarks><para>If the current array style is <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> (default)
            the array returned will have the size [0,1].</para></remarks>
            <seealso cref="P:ILNumerics.Settings.ArrayStyle"/>
            <seealso cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,ILNumerics.StorageOrders)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Create 1D array of arbitrary size without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="order">[Optional] Storage order. Default: (null) means <see cref = "F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
            <returns>Array as specified.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Create 1D array of arbitrary size without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array as specified.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Create 1D array of arbitrary size without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array as specified.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Create 1D array of arbitrary size without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array as specified.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Create 1D array of arbitrary size without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array as specified.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Create 1D array of arbitrary size without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array as specified.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Create 1D array of arbitrary size without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <param name="dim6">Length of dimension #6.</param>
            <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array as specified.</returns> 
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
            <summary>
            Create 1D array of arbitrary size without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="size">Length of dimensions.</param>
            <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array as specified.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.Size,ILNumerics.StorageOrders)">
            <summary>
            Create an empty array of the same size (shape) as another array without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="size">Size descriptor of the other array A, as acquired by A.S.</param>
            <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>. This setting overrides the storage order of <paramref name="size"/>.</param>
            <returns>Array as specified.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty">
            <summary>
            Create empty array with 0 elements of type <see cref="T:System.Double"/>.
            </summary>
            <returns>Empty array with smallest possible number of dimensions and 0 elements.</returns>
            <seealso cref="P:ILNumerics.Settings.ArrayStyle"/>
            <seealso cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,ILNumerics.StorageOrders)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty(System.Int32[])">
            <summary>
            Create array with a size determined by <paramref name="dims"/> and uninitialized elements of type <see cref="T:System.Double"/>.
            </summary>
            <returns>New array, having the number and lengths of dimensions as specified by <paramref name="dims"/> and and all uninitialized elements.</returns>
            <seealso cref="P:ILNumerics.Settings.ArrayStyle"/>
            <seealso cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,ILNumerics.StorageOrders)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64[])">
            <summary>
            Creates a new array of uninitialized values with a size determined by <paramref name="size"/>. 
            </summary>
            <typeparam name="T">Element type for the new array.</typeparam>
            <param name="size">Variable length <see cref="T:System.Array"/> or comma separated list with lengths of the dimensions of the new array.</param>
            <returns>New array of the specified size and <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> storage order, uninitialized values.</returns>
            <remarks>
            <para><paramref name="size"/> cannot be <c>null</c>. Its lengths determines the number of dimensions of the new array. The elements  
            determine the lengths of corresponding dimensions and cannot contain negative values.</para>
            <para>This overload creates uninitialized arrays in <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> only. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> for 
            determining the storage order explicitly.</para>
            <para>Since the variable length parameter list and the 'params' keyword (C#) implicitly allocates new storage under the control of the 
            GC consider using one of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0)"/> overloads and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> instead to provide the dimension lengths. 
            This is recommended when high-performance is important.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/>
            <seealso cref="F:ILNumerics.Size.MaxNumberOfDimensions"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
            <exception cref="T:System.ArgumentException">if <typeparamref name="T"/> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double"/>, float, int, ...), 
            <see cref="T:ILNumerics.complex"/> or <see cref="T:ILNumerics.fcomplex"/>.</exception>
            <exception cref="T:System.ArgumentException">if <paramref name="size"/> is null, has more elements than <see cref="F:ILNumerics.Size.MaxNumberOfDimensions"/> or contains negative values.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eye(System.Int32,System.Int32)">
            <summary>
            Creates a new matrix with element type <see cref="T:System.Double"/> having diagonal values of 1.0.  
            </summary>
            <param name="rows">Number of rows to create.</param>
            <param name="columns">Number of columns to create.</param>
            <returns>Unity matrix (diagonal matrix) of type double, column major storage.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eye``1(System.Int32,System.Int32)">
            <summary>
            Create unity matrix, arbitrary numeric type.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
            <returns>Unity matrix (diagonal matrix) of element type T.</returns>
            <typeparam name="T">Element type, must derive from <see cref="T:System.ValueType"/> and <see cref="T:System.IConvertible"/>.</typeparam>
            <exception cref="T:System.ArgumentException">If the type specified is not supported. Supported types are: double, float, complex, fcomplex, int, long, short, byte</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eye``1(``0,System.Int32,System.Int32,ILNumerics.StorageOrders)">
            <summary>
            Creates a diagonal matrix, arbitrary value type, diagonal value and storage order.
            </summary>
            <param name="diagVal">The value to be assigned to all diagonal elements of the returned matrix.</param>
            <param name="rows">Number of rows to create.</param>
            <param name="columns">Number of columns to create.</param>
            <param name="order">[Optional] The storage order for the matrix returned. Default: ColumnMajor.</param>
            <returns>Matrix of element type <typeparamref name="T"/> having the element <paramref name="diagVal"/> on the main diagonal.</returns>
            <typeparam name="T">Element type, must be a value type.</typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eye(System.Int64,System.Int64)">
            <summary>
            Creates a new matrix with element type <see cref="T:System.Double"/> having diagonal values of 1.0.  
            </summary>
            <param name="rows">Number of rows to create.</param>
            <param name="columns">Number of columns to create.</param>
            <returns>Unity matrix (diagonal matrix) of type double, column major storage.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eye``1(System.Int64,System.Int64)">
            <summary>
            Create unity matrix, arbitrary numeric type.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
            <returns>Unity matrix (diagonal matrix) of element type T.</returns>
            <typeparam name="T">Element type, must derive from <see cref="T:System.ValueType"/> and <see cref="T:System.IConvertible"/>.</typeparam>
            <exception cref="T:System.ArgumentException">If the type specified is not supported. Supported types are: double, float, complex, fcomplex, int, long, short, byte</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eye``1(``0,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a diagonal matrix, arbitrary value type, diagonal value and storage order.
            </summary>
            <param name="diagVal">The value to be assigned to all diagonal elements of the returned matrix.</param>
            <param name="rows">Number of rows to create.</param>
            <param name="columns">Number of columns to create.</param>
            <param name="order">[Optional] The storage order for the matrix returned. Default: ColumnMajor.</param>
            <returns>Matrix of element type <typeparamref name="T"/> having the element <paramref name="diagVal"/> on the main diagonal.</returns>
            <typeparam name="T">Element type, must be a value type.</typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
            <summary>
            Create new array with the rows of <paramref name="A"/> extended by the rows of <paramref name="B"/>.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>New array with elements of <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>The size of both arrays must match. This means that all but the dimension #1 must have the same lengths.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> or <paramref name="B"/> are null.</exception>
            <exception cref="T:System.ArgumentException"> if the sizes of <paramref name="A"/> and <paramref name="B"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
            <summary>
            Create new array with the rows of <paramref name="A"/> extended by the rows of <paramref name="B"/> and <paramref name="C"/>.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <param name="C">The third array.</param>
            <returns>New array with elements of <paramref name="A"/> and <paramref name="B"/> and <paramref name="C"/>.</returns>
            <remarks><para>The size of all arrays must match. This means that all but the dimension #1 must have the same lengths.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"> if any of <paramref name="A"/> or <paramref name="B"/>  or <paramref name="C"/> is null.</exception>
            <exception cref="T:System.ArgumentException"> if the sizes of <paramref name="A"/> and/or <paramref name="B"/> and/or <paramref name="C"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
            <summary>
            Create new array with the rows of <paramref name="A"/> extended by the rows of <paramref name="B"/> and <paramref name="C"/> and <paramref name="D"/>.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <param name="C">The third array.</param>
            <param name="D">The fourth array.</param>
            <returns>New array with elements of <paramref name="A"/> and <paramref name="B"/> and <paramref name="C"/> and <paramref name="D"/>.</returns>
            <remarks><para>The size of all arrays must match. This means that all but the dimension #1 must have the same lengths.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"> if any of <paramref name="A"/> or <paramref name="B"/>  or <paramref name="C"/> or <paramref name="D"/> is null.</exception>
            <exception cref="T:System.ArgumentException"> if the sizes of <paramref name="A"/> and/or <paramref name="B"/> and/or <paramref name="C"/> and/or <paramref name="D"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0})">
            <summary>
            Create linearly spaced row vector of 100 elements 
            </summary>
            <param name="start">First value</param>
            <param name="end">Last value</param>
            <returns>Row vector with 100 elements linearly spaced between start and end</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})">
            <summary>
            Create linearly spaced row vector, generic element type.
            </summary>
            <param name="start">First value, scalar, numeric</param>
            <param name="end">Last value, scalar, numeric</param>
            <param name="length">Number of elements to create, scalar, numeric</param>
            <returns>Row vector with 'length' elements linearly spaced between start and end</returns>
            <remarks>
            <para><see cref="F:linspace{T}(InArray{T}, InArray{T}, InArray{T})"/> returns an empty array if <paramref name="length"/> is 0.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})"/> returns a scalar array with the value of <paramref name="end"/> if <paramref name="length"/> is 1.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
            <summary>
            Create linearly spaced row vector, double precision.
            </summary>
            <param name="start">The first value.</param>
            <param name="end">The last value.</param>
            <param name="length">Number of elements to create.</param>
            <returns>Vector with 'length' elements linearly spaced between start and end.</returns>
            <remarks>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/> returns an empty array if <paramref name="length"/> is 0.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/> returns a scalar array with the value of <paramref name="end"/> if <paramref name="length"/> is 1.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.logical(System.Boolean[],ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
            <summary>
            Creates a new logical array from the values provided in <paramref name="values"/> with the shape given by <paramref name="size"/>.
            </summary>
            <param name="values">Values to be copied to the new ILNumerics array.</param>
            <param name="size">The size of the new ILNumerics array. Number of elements must correspond to the number of values in <paramref name="values"/>.</param>
            <param name="order">[Optional] Storage order for the new ILNumerics array. Default: (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</param>
            <returns>A new ILNumerics array with copies of the given values and the given shape.</returns>
            <remarks>A copy is made from <paramref name="values"/>. The array <paramref name="values"/> is not referenced 
            by ILNumerics after the function returns.
            <para>Make sure that the number of elements configured by the dimension lengths in <paramref name="size"/>
            matches the number of elements in <paramref name="values"/>.</para>
            </remarks>
            <example>
            <code><![CDATA[Assert.IsTrue(logical(new[] { true }, size(1)) == true);]]></code></example>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.logical(ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders},System.Boolean)">
            <summary>
            Creates a new logical array with given shape and optional storage order.
            </summary>
            <param name="size">The size of the new array.</param>
            <param name="order">[Optional] Storage order for the new ILNumerics array. Default: (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>).</param>
            <param name="clear">[Optional] True: initialize the elements of the new logical with value 'False'. Default: true.</param>
            <returns>A new ILNumerics array with copies of the given values and the given shape.</returns>
            <remarks><para>Use this function to create and optionally initialize (large) logicals from scratch, outside of a binary operation and without 
            converting from a .NET array of booleans.</para></remarks>
            <example>
            <code><![CDATA[Logical L = logical(size(1000,2000), StorageOrders.RowMajor);]]></code></example>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.logspace(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
            <summary>
            Create logarithmically spaced row vector of 50 elements. 
            </summary>
            <param name="start">First exponent value.</param>
            <param name="end">Last exponent value.</param>
            <returns>Row vector with 50 elements logarithmically spaced between 10<sup>start</sup> and 10<sup>end</sup>.</returns>
            <remarks><para>If <paramref name="end"/> equals <see cref="P:ILNumerics.Globals.pi"/> than the upper interval for the 
            values returned is  and the range is: [10^start...]</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.logspace(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
            <summary>
            Create logarithmically spaced row vector
            </summary>
            <param name="start">First exponent value</param>
            <param name="end">Last exponent value</param>
            <param name="length">Number of elements to create</param>
            <returns>Row vector with 'length' elements logarithmically spaced between 10<sup>start</sup> and 10<sup>end</sup>.</returns>
            <remarks><para>If <paramref name="end"/> equals <see cref="P:ILNumerics.Globals.pi"/> than the upper interval for the 
            values returned is  and the range is: [10^start...]</para>
            <para>If <paramref name="length"/> is 1 than a single value of 10<sup>end</sup> is returned.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.New``1(System.UInt64,System.UInt32,System.Boolean)">
            <summary>
            Provides memory / T[] / a <see cref="!:Segments.OpenCL.CLDevice"/>device buffer for the current thread. This is for expert users and rare low-level scenarios only. Use the common array creation functions instead! 
            </summary>
            <typeparam name="T">Element type, specifies the type and size of elements.</typeparam>
            <param name="elementCount">Number of elements which must at least fit into the memory region.</param>
            <param name="deviceIndex">[Optional] Index of the device owning the memory. Default: 0 is the host device.</param>
            <param name="clear">[Optional] Flag determining whether the memory should be initialized to zero. Default: do not clear.</param>
            <returns>The <see cref="T:ILNumerics.Core.MemoryLayer.MemoryHandle"/> returned will be a <see cref="T:ILNumerics.Core.MemoryLayer.NativeHostHandle"/> to a region on the main (virtual) memory,
            a <see cref="T:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1"/> to the managed heap or a <see cref="T:System.Buffer"/> on an OpenCL device.</returns>
            <remarks>
            <para>This function attempts to acquire the requested chunk of memory from the memory pool of the specified device. Only if no matching region was found, memory is allocated from the low level 
            allocation functions offered by the device.</para>
            <para>This function supports the utilization of memory regions in a C style manner: user have to manage memory explicitly and manually. 
            Instead of using this function it is recommended to use the common ILNumerics array creation functions to create and work with ILNumerics arrays. 
            which do not require to create, clean up or to pool memory manually. ILNumerics <see href="/FunctionRules.html">function rules</see> do all this automatically. Thus, 
            manual memory management is left to a few, very specific situations only.</para>
            <para>Depending on the type category the memory handle returned references one of the following memory types:
            <list type="number">
            <item>T is struct / ValueType: memory is allocated on the unmanaged heap. There is no inherent size limitation. Access to the memory is done 
            by means of the <see cref="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Pointer"/> property. Users are responsible to correctly deal with such pointers. All risks of unsafe code apply.</item>
            <item>T is class / reference type: the function allocates an .NET <see cref="T:System.Array"/> on the managed heap. Access is done by first casting the memory handle 
            returned to the concrete type of <see cref="T:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1"/> and then using the <see cref="F:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.HostArray"/> property to acquire the T[] array.</item>
            <item>if <paramref name="deviceIndex"/> is greater than 0 the handle returned will be a <see cref="!:ILNumerics.Core.Segments.OpenCL.Buffer"/> to an OpenCL device. For shared 
            virtual memory devices (SVM), however, such buffers will be backed with a corresponding region of memory on the native virtual memory manager managed heap. It is this complexity
            which leads to the suggestion to not use this method of manual memory management ('New' and 'free') unless really necessary and unless you know what you are doing.</item>
            </list></para>
            <para>Attempting to access the <see cref="F:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.HostArray"/> on a native handle generates an exception.</para>
            <para>Attempting to access the <see cref="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Pointer"/> on a ManagedHostHandle{T} generates an exception.</para>
            <para>MemoryHandles are critical handles. Disposal is guaranteed by critical execution regions and the GC. However, users should 
            dispose the handle to free the memory region immediately after use. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.free``1(ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt32,System.Boolean)"/> for disposing memory handles.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.free``1(ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.DeviceManagement.DeviceManager.GetDevices"/>
            <exception cref="T:System.OutOfMemoryException"> on failed attempts to allocate a memory region on the specified device.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.New``1(System.Int64,System.UInt32,System.Boolean)">
            <summary>
            Provides memory / T[] / a <see cref="!:Segments.OpenCL.CLDevice"/>device buffer for the current thread. This is for expert users and rare low-level scenarios only. Use the common array creation functions instead! 
            </summary>
            <typeparam name="T">Element type, specifies the type and size of elements.</typeparam>
            <param name="elementCount">Number of elements which must at least fit into the memory region.</param>
            <param name="deviceIndex">[Optional] Index of the device owning the memory. Default: 0 is the host device.</param>
            <param name="clear">[Optional] Flag determining whether the memory should be initialized to zero. Default: do not clear.</param>
            <returns>The <see cref="T:ILNumerics.Core.MemoryLayer.MemoryHandle"/> returned will be a <see cref="T:ILNumerics.Core.MemoryLayer.NativeHostHandle"/> to a region on the main (virtual) memory,
            a <see cref="T:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1"/> to the managed heap or a <see cref="T:System.Buffer"/> on an OpenCL device.</returns>
            <remarks>
            <para>This function attempts to acquire the requested chunk of memory from the memory pool of the specified device. Only if no matching region was found, memory is allocated from the low level 
            allocation functions offered by the device.</para>
            <para>This function supports the utilization of memory regions in a C style manner: user have to manage memory explicitly and manually. 
            Instead of using this function it is recommended to use the common ILNumerics array creation functions to create and work with ILNumerics arrays. 
            which do not require to create, clean up or to pool memory manually. ILNumerics <see href="/FunctionRules.html">function rules</see> do all this automatically. Thus, 
            manual memory management is left to a few, very specific situations only.</para>
            <para>Depending on the type category the memory handle returned references one of the following memory types:
            <list type="number">
            <item>T is struct / ValueType: memory is allocated on the unmanaged heap. There is no inherent size limitation. Access to the memory is done 
            by means of the <see cref="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Pointer"/> property. Users are responsible to correctly deal with such pointers. All risks of unsafe code apply.</item>
            <item>T is class / reference type: the function allocates an .NET <see cref="T:System.Array"/> on the managed heap. Access is done by first casting the memory handle 
            returned to the concrete type of <see cref="T:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1"/> and then using the <see cref="F:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.HostArray"/> property to acquire the T[] array.</item>
            <item>if <paramref name="deviceIndex"/> is greater than 0 the handle returned will be a <see cref="!:ILNumerics.Core.Segments.OpenCL.Buffer"/> to an OpenCL device. For shared 
            virtual memory devices (SVM), however, such buffers will be backed with a corresponding region of memory on the native virtual memory manager managed heap. It is this complexity
            which leads to the suggestion to not use this method of manual memory management ('New' and 'free') unless really necessary and unless you know what you are doing.</item>
            </list></para>
            <para>Attempting to access the <see cref="F:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.HostArray"/> on a native handle generates an exception.</para>
            <para>Attempting to access the <see cref="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Pointer"/> on a ManagedHostHandle{T} generates an exception.</para>
            <para>MemoryHandles are critical handles. Disposal is guaranteed by critical execution regions and the GC. However, users should 
            dispose the handle to free the memory region immediately after use. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.free``1(ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt32,System.Boolean)"/> for disposing memory handles.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.free``1(ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.DeviceManagement.DeviceManager.GetDevices"/>
            <exception cref="T:System.OutOfMemoryException"> on failed attempts to allocate a memory region on the specified device.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.free``1(ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt32,System.Boolean)">
            <summary>
            Frees the handle for a memory region after use. This is for expert users in rare low-level scenarios only. Use the common array creation functions instead!
            </summary>
            <typeparam name="T">Element type used to acquire the handle.</typeparam>
            <param name="handle">The handle pointing to the allocated memory region.</param>
            <param name="nocache">[Optional] Determines whether the memory is being returned to the OS. Default: false - the memory is cached into a pool for quick reusing.</param>
            <param name="deviceIndex">The index of the device where the handles memory lives on. This must be the same device as the one used during allocation.</param>
            <remarks><para>After having acquired the handle of a memory region on a device and having finished working with the memory make sure to release the memory 
            back to the ILNumerics memory manager.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.New``1(System.UInt64,System.UInt32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones(System.Int64)">
            <summary>
            Creates a square matrix of 1.0-valued <see cref="T:System.Double"/> elements, size [dim0, dim0].
            </summary>
            <param name="rows_columns">Length of dimension #0 and dimension #1.</param>
            <returns>New ILNumerics array initialized with 1.0 values.</returns>
            <remarks>This creates a square matrix with the same number of rows and columns. The elements 
            are ordered in <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> order.
            <para>This function always creates a matrix, hence the array returned will always have 
            two dimensions. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0)"/> or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/> 
            for creating arrays with less than two dimension if your setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/> allows it.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones(System.Int64,System.Int64)">
            <summary>
            Creates a new ILNumerics array of 1.0 <see cref="T:System.Double"/> elements.
            </summary>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <returns>New ILNumerics array initialized with 1.0.</returns>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones(System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates a new ILNumerics array of 1.0 <see cref="T:System.Double"/> elements.
            </summary>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <returns>New ILNumerics array initialized with 1.0.</returns>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates a new ILNumerics array of 1.0 <see cref="T:System.Double"/> elements.
            </summary>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <returns>New ILNumerics array initialized with 1.0.</returns>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates a new ILNumerics array of 1.0 <see cref="T:System.Double"/> elements.
            </summary>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <returns>New ILNumerics array initialized with 1.0.</returns>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates a new ILNumerics array of 1.0 <see cref="T:System.Double"/> elements.
            </summary>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <returns>New ILNumerics array initialized with 1.0.</returns>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates a new ILNumerics array of 1.0 <see cref="T:System.Double"/> elements.
            </summary>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <param name="dim6">Length of dimension #6.</param>
            <returns>New ILNumerics array initialized with 1.0.</returns>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a square matrix of 1-valued elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="rows_columns">Length of dimension #0 and dimension #1 (the number of rows and columns).</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with 1s.</returns>
            <remarks>This creates a square matrix with the same number of rows and columns. The elements 
            are ordered in <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> order.
            <para>This function always creates a matrix, hence the array returned will always have 
            two dimensions. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0)"/> or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/> 
            for creating arrays with less than two dimension if your setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/> allows it.</para>
            <para>Supported element types are all predefined, scalar numeric value types.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
            <exception cref="T:System.ArgumentException">if <typeparamref name="T"/> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double"/>, float, int, ...), 
            <see cref="T:ILNumerics.complex"/> or <see cref="T:ILNumerics.fcomplex"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array of ones for numeric element types <typeparamref name="T"/>.
            </summary>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with ones.</returns>
            <remarks><para>Supported element types are all predefined, scalar numeric value types.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
            <exception cref="T:System.ArgumentException">if <typeparamref name="T"/> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double"/>, float, int, ...), 
            <see cref="T:ILNumerics.complex"/> or <see cref="T:ILNumerics.fcomplex"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array of ones for numeric element types <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with ones.</returns>
            <remarks><para>Supported element types are all predefined, scalar numeric value types.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
            <exception cref="T:System.ArgumentException">if <typeparamref name="T"/> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double"/>, float, int, ...), 
            <see cref="T:ILNumerics.complex"/> or <see cref="T:ILNumerics.fcomplex"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array of ones for numeric element types <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with ones.</returns>
            <remarks><para>Supported element types are all predefined, scalar numeric value types.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
            <exception cref="T:System.ArgumentException">if <typeparamref name="T"/> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double"/>, float, int, ...), 
            <see cref="T:ILNumerics.complex"/> or <see cref="T:ILNumerics.fcomplex"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array of ones for numeric element types <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with ones.</returns>
            <remarks><para>Supported element types are all predefined, scalar numeric value types.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
            <exception cref="T:System.ArgumentException">if <typeparamref name="T"/> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double"/>, float, int, ...), 
            <see cref="T:ILNumerics.complex"/> or <see cref="T:ILNumerics.fcomplex"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array of ones for numeric element types <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with ones.</returns>
            <remarks><para>Supported element types are all predefined, scalar numeric value types.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
            <exception cref="T:System.ArgumentException">if <typeparamref name="T"/> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double"/>, float, int, ...), 
            <see cref="T:ILNumerics.complex"/> or <see cref="T:ILNumerics.fcomplex"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array of ones for numeric element types <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <param name="dim6">Length of dimension #6.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with ones.</returns>
            <remarks><para>Supported element types are all predefined, scalar numeric value types.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
            <exception cref="T:System.ArgumentException">if <typeparamref name="T"/> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double"/>, float, int, ...), 
            <see cref="T:ILNumerics.complex"/> or <see cref="T:ILNumerics.fcomplex"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(ILNumerics.Size,ILNumerics.StorageOrders)">
            <summary>
            Creates a new array of ones '1' with the same size as <paramref name="size"/>. 
            </summary>
            <typeparam name="T">Element type for the new array.</typeparam>
            <param name="size">Number and lengths of the dimensions for the new array.</param>
            <param name="order">[Optional] Storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New array of the specified size and storage order, initialized with '1'.</returns>
            <remarks><para>Supported element types are all predefined, scalar numeric value types.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
            <exception cref="T:System.ArgumentException">if <typeparamref name="T"/> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double"/>, float, int, ...), 
            <see cref="T:ILNumerics.complex"/> or <see cref="T:ILNumerics.fcomplex"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
            <summary>
            Creates a new array of ones '1' with a size determined by <paramref name="size"/>. 
            </summary>
            <typeparam name="T">Element type for the new array.</typeparam>
            <param name="size">Vector with lengths of the dimensions of the new array.</param>
            <param name="order">[Optional] Storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New array of the specified size and storage order, initialized with '1'.</returns>
            <remarks><para>Supported element types are all predefined, scalar numeric value types.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
            <exception cref="T:System.ArgumentException">if <typeparamref name="T"/> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double"/>, float, int, ...), 
            <see cref="T:ILNumerics.complex"/> or <see cref="T:ILNumerics.fcomplex"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64[])">
            <summary> 
            Creates a new array of ones '1' with a size determined by <paramref name="size"/>. 
            </summary>
            <typeparam name="T">Element type for the new array. This must be a value type.</typeparam>
            <param name="size">Variable length <see cref="T:System.Array"/> or comma separated list with lengths of the dimensions of the new array.</param>
            <returns>New array of the specified size and <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> storage order, initialized with '1'.</returns>
            <remarks><para>Supported element types are all predefined, scalar numeric value types.</para>
            <para><paramref name="size"/> must be not null. Its lengths determines the number of dimensions of the new array. Negative element values are not allowed.</para>
            <para>Arrays returned from this overload are in <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> storage order. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> for 
            determining the storage order explicitly.</para>
            <para>Since the variable length parameter list and the 'params' keyword (C#) implicitly allocates new storage under the control of the 
            GC consider using one of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0)"/> overloads and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> instead to provide the dimension lengths. 
            This is recommended when high-performance is important.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="F:ILNumerics.Size.MaxNumberOfDimensions"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
            <exception cref="T:System.ArgumentException">if <typeparamref name="T"/> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double"/>, float, int, ...), 
            <see cref="T:ILNumerics.complex"/> or <see cref="T:ILNumerics.fcomplex"/>.</exception>
            <exception cref="T:System.ArgumentException">if <paramref name="size"/> is null, has more elements than <see cref="F:ILNumerics.Size.MaxNumberOfDimensions"/> or contains negative values.</exception>
        </member>
        <member name="P:ILNumerics.Core.Functions.Builtin.MathInternal.RandomGenerator">
            <summary>
            Random number generator used for any generation of random numbers.
            </summary>
            <remarks>This property is thread safe (by using the [ThreadStatic] attribute).</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a symmetric matrix with uniformly distributed, pseudo random values.
            </summary>
            <param name="d0">Number of columns and number of rows.</param>
            <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Square matrix filled with random numbers.</returns>
            <remarks><para>Values range from 0.0 to 1.0, uniformly distributed.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates an array with uniformly distributed, pseudo random values.
            </summary>
            <param name="d0">Length of dimension 0.</param>
            <param name="d1">Length of dimension 1.</param>
            <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Matrix filled with random numbers.</returns>
            <remarks><para>Values range from 0.0 to 1.0, uniformly distributed.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates an array with uniformly distributed, pseudo random values.
            </summary>
            <param name="d0">Length of dimension 0.</param>
            <param name="d1">Length of dimension 1.</param>
            <param name="d2">Length of dimension 2.</param>
            <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array filled with random numbers.</returns>
            <remarks><para>Values range from 0.0 to 1.0, uniformly distributed.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates an array with uniformly distributed, pseudo random values.
            </summary>
            <param name="d0">Length of dimension 0.</param>
            <param name="d1">Length of dimension 1.</param>
            <param name="d2">Length of dimension 2.</param>
            <param name="d3">Length of dimension 3.</param>
            <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array filled with random numbers.</returns>
            <remarks><para>Values range from 0.0 to 1.0, uniformly distributed.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates an array with uniformly distributed, pseudo random values.
            </summary>
            <param name="d0">Length of dimension 0.</param>
            <param name="d1">Length of dimension 1.</param>
            <param name="d2">Length of dimension 2.</param>
            <param name="d3">Length of dimension 3.</param>
            <param name="d4">Length of dimension 4.</param>
            <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array filled with random numbers.</returns>
            <remarks><para>Values range from 0.0 to 1.0, uniformly distributed.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates an array with uniformly distributed, pseudo random values.
            </summary>
            <param name="d0">Length of dimension 0.</param>
            <param name="d1">Length of dimension 1.</param>
            <param name="d2">Length of dimension 2.</param>
            <param name="d3">Length of dimension 3.</param>
            <param name="d4">Length of dimension 4.</param>
            <param name="d5">Length of dimension 5.</param>
            <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array filled with random numbers.</returns>
            <remarks><para>Values range from 0.0 to 1.0, uniformly distributed.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates an array with uniformly distributed, pseudo random values.
            </summary>
            <param name="d0">Length of dimension 0.</param>
            <param name="d1">Length of dimension 1.</param>
            <param name="d2">Length of dimension 2.</param>
            <param name="d3">Length of dimension 3.</param>
            <param name="d4">Length of dimension 4.</param>
            <param name="d5">Length of dimension 5.</param>
            <param name="d6">Length of dimension 6.</param>
            <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array filled with random numbers.</returns>
            <remarks><para>Values range from 0.0 to 1.0, uniformly distributed.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
            <summary>
            Creates an array with uniformly distributed, pseudo random values.
            </summary>
            <param name="size">Array with target dimension lengths.</param>
            <param name="order">[Optional] Target arrays storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New array with random numbers and shape as determined.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(System.Int64[])">
            <summary>
            Creates a new array of uniformly distributed, pseudo random values and a size determined by <paramref name="size"/>.
            </summary>
            <param name="size">Variable length <see cref="T:System.Array"/> or comma separated list with lengths of the dimensions of the new array.</param>
            <returns>New array of the specified size and <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> storage order, random values.</returns>
            <remarks>
            <para><paramref name="size"/> cannot be <c>null</c>. Its length determines the number of dimensions of the new array. The elements  
            determine the lengths of corresponding dimensions and cannot contain negative values.</para>
            <para>Arrays returned from this overload are in <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> storage order. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> for 
            determining the storage order explicitly.</para>
            <para>Since the variable length parameter list and the 'params' keyword (C#) implicitly allocates new storage under the control of the 
            GC consider using one of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0)"/> overloads and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> instead to provide the dimension lengths. 
            This method is recommended when high-performance is important.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/>
            <seealso cref="F:ILNumerics.Size.MaxNumberOfDimensions"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
            <exception cref="T:System.ArgumentException">if <paramref name="size"/> is null, has more elements than <see cref="F:ILNumerics.Size.MaxNumberOfDimensions"/> or contains negative values.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.randImplace(ILNumerics.BaseArray{System.Double})">
            <summary>Random numbers, uniform, parallelized.</summary>
            <param name="A">Input array.</param>
            <returns>Fills the array with random numbers.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a square matrix with normally distributed, pseudo random values.
            </summary>
            <param name="d0">Number of columns and rows.</param>
            <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Square matrix filled with random numbers.</returns>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates an array with uniformly distributed, pseudo randnom values.
            </summary>
            <param name="d0">Length of dimension 0.</param>
            <param name="d1">Length of dimension 1.</param>
            <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Matrix filled with randnom numbers.</returns>
            <remarks><para>Values range from 0.0 to 1.0, uniformly distributed.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates an array with uniformly distributed, pseudo randnom values.
            </summary>
            <param name="d0">Length of dimension 0.</param>
            <param name="d1">Length of dimension 1.</param>
            <param name="d2">Length of dimension 2.</param>
            <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array filled with randnom numbers.</returns>
            <remarks><para>Values range from 0.0 to 1.0, uniformly distributed.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates an array with uniformly distributed, pseudo randnom values.
            </summary>
            <param name="d0">Length of dimension 0.</param>
            <param name="d1">Length of dimension 1.</param>
            <param name="d2">Length of dimension 2.</param>
            <param name="d3">Length of dimension 3.</param>
            <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array filled with randnom numbers.</returns>
            <remarks><para>Values range from 0.0 to 1.0, uniformly distributed.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates an array with uniformly distributed, pseudo randnom values.
            </summary>
            <param name="d0">Length of dimension 0.</param>
            <param name="d1">Length of dimension 1.</param>
            <param name="d2">Length of dimension 2.</param>
            <param name="d3">Length of dimension 3.</param>
            <param name="d4">Length of dimension 4.</param>
            <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array filled with randnom numbers.</returns>
            <remarks><para>Values range from 0.0 to 1.0, uniformly distributed.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates an array with uniformly distributed, pseudo randnom values.
            </summary>
            <param name="d0">Length of dimension 0.</param>
            <param name="d1">Length of dimension 1.</param>
            <param name="d2">Length of dimension 2.</param>
            <param name="d3">Length of dimension 3.</param>
            <param name="d4">Length of dimension 4.</param>
            <param name="d5">Length of dimension 5.</param>
            <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array filled with randnom numbers.</returns>
            <remarks><para>Values range from 0.0 to 1.0, uniformly distributed.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates an array with uniformly distributed, pseudo randnom values.
            </summary>
            <param name="d0">Length of dimension 0.</param>
            <param name="d1">Length of dimension 1.</param>
            <param name="d2">Length of dimension 2.</param>
            <param name="d3">Length of dimension 3.</param>
            <param name="d4">Length of dimension 4.</param>
            <param name="d5">Length of dimension 5.</param>
            <param name="d6">Length of dimension 6.</param>
            <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array filled with randnom numbers.</returns>
            <remarks><para>Values range from 0.0 to 1.0, uniformly distributed.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
            <summary>
            Creates an array with normally distributed, pseudo random values.
            </summary>
            <param name="size">Array with target dimension lengths.</param>
            <param name="order">[Optional] Target arrays storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New array with random numbers and shape as determined.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(System.Int64[])">
            <summary>
            Creates a new array of normally distributed, pseudo random values and a size determined by <paramref name="size"/>.
            </summary>
            <param name="size">Variable length <see cref="T:System.Array"/> or comma separated list with lengths of the dimensions of the new array.</param>
            <returns>New array of the specified size and <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> storage order, random values.</returns>
            <remarks>
            <para><paramref name="size"/> cannot be <c>null</c>. Its length determines the number of dimensions of the new array. The elements  
            determine the lengths of corresponding dimensions and cannot contain negative values.</para>
            <para>Arrays returned from this overload are in <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> storage order. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> for 
            determining the storage order explicitly.</para>
            <para>Since the variable length parameter list and the 'params' keyword (C#) implicitly allocates new storage under the control of the 
            GC consider using one of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0)"/> overloads and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> instead to provide the dimension lengths. 
            This method is recommended when high-performance is important.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/>
            <seealso cref="F:ILNumerics.Size.MaxNumberOfDimensions"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
            <exception cref="T:System.ArgumentException">if <paramref name="size"/> is null, has more elements than <see cref="F:ILNumerics.Size.MaxNumberOfDimensions"/> or contains negative values.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.randnInplace_internal(ILNumerics.BaseArray{System.Double})">
            <summary>Random numbers, uniform, parallelized. </summary>
            <param name="A">Input array.</param>
            <returns>Fills the array with randnom numbers.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.real(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Creates array with real parts of complex elements from <paramref name="A"/>.
            </summary>
            <param name="A">Complex input array.</param>
            <returns>Array of the same shape and size as <paramref name="A"/> with only the real parts.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.real(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Creates array with real parts of complex elements from <paramref name="A"/>.
            </summary>
            <param name="A">Complex input array.</param>
            <returns>Array of the same shape and size as <paramref name="A"/> with only the real parts.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.imag(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Creates array with imaginary parts of complex elements from <paramref name="A"/>.
            </summary>
            <param name="A">Complex input array.</param>
            <returns>Array of the same shape and size as <paramref name="A"/> with only the imaginary parts.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.imag(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Creates array with imaginary parts of complex elements from <paramref name="A"/>.
            </summary>
            <param name="A">Complex input array.</param>
            <returns>Array of the same shape and size as <paramref name="A"/> with only the imaginary parts.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(System.Int64,System.Func{System.Int64,``0})">
            <summary>
            Generator function, creates vector of specified length, compute values by index.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="length">The number of elements for the new vector.</param>
            <param name="func">Generator function, transforms the 0-based index into a value.</param>
            <returns>Vector of given <paramref name="length"/> with values computed based on their index.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cellv(ILNumerics.BaseArray[])">
            <summary>
            Create a cell vector from provided <paramref name="arrays"/>. 
            </summary>
            <param name="arrays">ILNumerics arrays to be stored into the cell.</param>
            <returns>Cell array with number and values of elements as given by <paramref name="arrays"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0[])">
            <summary>
            Creates a vector from provided 1-D <see cref="T:System.Array"/>. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="values">.Net array with values for the new vector.</param>
            <returns>New ILNumerics array with number and values of elements as given by <paramref name="values"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0)">
            <summary>
            Creates a new scalar ILNumerics 1-D array with the given value. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">The single value for the target array.</param>
            <returns>ILNumerics scalar of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">First value.</param>
            <param name="v1">Second value.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">First value.</param>
            <param name="v1">Second value.</param>
            <param name="v2">Third value.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <param name="v6">Value #6.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <param name="v6">Value #6.</param>
            <param name="v7">Value #7.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <param name="v6">Value #6.</param>
            <param name="v7">Value #7.</param>
            <param name="v8">Value #8.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <param name="v6">Value #6.</param>
            <param name="v7">Value #7.</param>
            <param name="v8">Value #8.</param>
            <param name="v9">Value #9.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <param name="v6">Value #6.</param>
            <param name="v7">Value #7.</param>
            <param name="v8">Value #8.</param>
            <param name="v9">Value #9.</param>
            <param name="v10">Value #10.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <param name="v6">Value #6.</param>
            <param name="v7">Value #7.</param>
            <param name="v8">Value #8.</param>
            <param name="v9">Value #9.</param>
            <param name="v10">Value #10.</param>
            <param name="v11">Value #11.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <param name="v6">Value #6.</param>
            <param name="v7">Value #7.</param>
            <param name="v8">Value #8.</param>
            <param name="v9">Value #9.</param>
            <param name="v10">Value #10.</param>
            <param name="v11">Value #11.</param>
            <param name="v12">Value #12.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <param name="v6">Value #6.</param>
            <param name="v7">Value #7.</param>
            <param name="v8">Value #8.</param>
            <param name="v9">Value #9.</param>
            <param name="v10">Value #10.</param>
            <param name="v11">Value #11.</param>
            <param name="v12">Value #12.</param>
            <param name="v13">Value #13.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <param name="v6">Value #6.</param>
            <param name="v7">Value #7.</param>
            <param name="v8">Value #8.</param>
            <param name="v9">Value #9.</param>
            <param name="v10">Value #10.</param>
            <param name="v11">Value #11.</param>
            <param name="v12">Value #12.</param>
            <param name="v13">Value #13.</param>
            <param name="v14">Value #14.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <param name="v6">Value #6.</param>
            <param name="v7">Value #7.</param>
            <param name="v8">Value #8.</param>
            <param name="v9">Value #9.</param>
            <param name="v10">Value #10.</param>
            <param name="v11">Value #11.</param>
            <param name="v12">Value #12.</param>
            <param name="v13">Value #13.</param>
            <param name="v14">Value #14.</param>
            <param name="v15">Value #15.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <param name="v6">Value #6.</param>
            <param name="v7">Value #7.</param>
            <param name="v8">Value #8.</param>
            <param name="v9">Value #9.</param>
            <param name="v10">Value #10.</param>
            <param name="v11">Value #11.</param>
            <param name="v12">Value #12.</param>
            <param name="v13">Value #13.</param>
            <param name="v14">Value #14.</param>
            <param name="v15">Value #15.</param>
            <param name="v16">Value #16.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <param name="v6">Value #6.</param>
            <param name="v7">Value #7.</param>
            <param name="v8">Value #8.</param>
            <param name="v9">Value #9.</param>
            <param name="v10">Value #10.</param>
            <param name="v11">Value #11.</param>
            <param name="v12">Value #12.</param>
            <param name="v13">Value #13.</param>
            <param name="v14">Value #14.</param>
            <param name="v15">Value #15.</param>
            <param name="v16">Value #16.</param>
            <param name="v17">Value #17.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <param name="v6">Value #6.</param>
            <param name="v7">Value #7.</param>
            <param name="v8">Value #8.</param>
            <param name="v9">Value #9.</param>
            <param name="v10">Value #10.</param>
            <param name="v11">Value #11.</param>
            <param name="v12">Value #12.</param>
            <param name="v13">Value #13.</param>
            <param name="v14">Value #14.</param>
            <param name="v15">Value #15.</param>
            <param name="v16">Value #16.</param>
            <param name="v17">Value #17.</param>
            <param name="v18">Value #18.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            Initializes a new ILNumerics vector with given values. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="v0">Value #0.</param>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <param name="v3">Value #3.</param>
            <param name="v4">Value #4.</param>
            <param name="v5">Value #5.</param>
            <param name="v6">Value #6.</param>
            <param name="v7">Value #7.</param>
            <param name="v8">Value #8.</param>
            <param name="v9">Value #9.</param>
            <param name="v10">Value #10.</param>
            <param name="v11">Value #11.</param>
            <param name="v12">Value #12.</param>
            <param name="v13">Value #13.</param>
            <param name="v14">Value #14.</param>
            <param name="v15">Value #15.</param>
            <param name="v16">Value #16.</param>
            <param name="v17">Value #17.</param>
            <param name="v18">Value #18.</param>
            <param name="v19">Value #19.</param>
            <returns>ILNumerics vector with given values.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros(ILNumerics.InArray{System.Int64})">
            <summary>
            Creates a new array of 0.0-valued <see cref="T:System.Double"/> elements of given <paramref name="size"/>.
            </summary>
            <param name="size">Length of dimensions as array.</param>
            <returns>New ILNumerics array according to <paramref name="size"/>, initialized with 0.</returns>
            <remarks><para>This creates and initializes a new array in <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> order. 
            The size of the new array corresponds to <paramref name="size"/>. Each entry in <paramref name="size"/> 
            provides the lengths of the corresponding dimension in the new array. Note, that this overload does 
            not create a square matrix  even if <paramref name="size"/> contains a single element only.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros(System.Int64)">
            <summary>
            Creates a square matrix of 0.0-valued <see cref="T:System.Double"/> elements, size [dim0, dim0].
            </summary>
            <param name="rows_columns">Length of dimension #0 and dimension #1.</param>
            <returns>New ILNumerics array initialized with default(T).</returns>
            <remarks>This creates a square matrix with the same number of rows and columns. The elements 
            are ordered in <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> order.
            <para>This function always creates a matrix, hence the array returned will always have 
            two dimensions. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0)"/> or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/> 
            for creating arrays with less than two dimension if your setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/> allows it.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros(System.Int64,System.Int64)">
            <summary>
            Creates a matrix of 0.0-valued <see cref="T:System.Double"/> elements. Storage order: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>. 
            </summary>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <returns>New ILNumerics array initialized with default(T).</returns>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros(System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates a new ILNumerics array of 0.0-valued <see cref="T:System.Double"/> elements. Storage order: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>. 
            </summary>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <returns>New ILNumerics array initialized with default(T).</returns>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates a new ILNumerics array of 0.0-valued <see cref="T:System.Double"/> elements. Storage order: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>. 
            </summary>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <returns>New ILNumerics array initialized with default(T).</returns>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates a new ILNumerics array of 0.0-valued <see cref="T:System.Double"/> elements. Storage order: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>. 
            </summary>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <returns>New ILNumerics array initialized with default(T).</returns>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates a new ILNumerics array of 0.0-valued <see cref="T:System.Double"/> elements. Storage order: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>. 
            </summary>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <returns>New ILNumerics array initialized with default(T).</returns>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates a new ILNumerics array of 0.0-valued <see cref="T:System.Double"/> elements. Storage order: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>. 
            </summary>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <param name="dim6">Length of dimension #6.</param>
            <returns>New ILNumerics array initialized with default(T).</returns>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a square matrix of 0-valued elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="rows_columns">Length of dimension #0 and dimension #1 (the number of rows and columns).</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with default(T).</returns>
            <remarks>This creates a square matrix with the same number of rows and columns. The elements 
            are ordered in <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> order.
            <para>This function always creates a matrix, hence the array returned will always have 
            two dimensions. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0)"/> or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/> 
            for creating arrays with less than two dimension if your setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/> allows it.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array of 0 elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with default(T).</returns>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array of 0 elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with default(T).</returns>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array of 0 elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with default(T).</returns>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array of 0 elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with default(T).</returns>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array of 0 elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with default(T).</returns>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Creates a new ILNumerics array of 0 elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <param name="dim6">Length of dimension #6.</param>
            <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New ILNumerics array initialized with default(T).</returns>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(ILNumerics.Size,ILNumerics.StorageOrders)">
            <summary>
            Create a new array of zeros '0' with the same size as <paramref name="size"/>. 
            </summary>
            <typeparam name="T">Element type for the new array.</typeparam>
            <param name="size">Number and lengths of the dimensions for the new array.</param>
            <param name="order">[Optional] Storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New array of the specified size and storage order, initialized with '0'.</returns>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
            <summary>
            Create a new array of zeros '0' with dimensions number and lengths as determined by <paramref name="size"/>. 
            </summary>
            <typeparam name="T">Element type for the new array.</typeparam>
            <param name="size">Number and lengths of the dimensions for the new array.</param>
            <param name="order">[Optional] Storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>New array of the specified size and storage order, initialized with '0'.</returns>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64[])">
            <summary>
            Creates a new array of zeros '0' with a size determined by <paramref name="size"/>. 
            </summary>
            <typeparam name="T">Element type for the new array. This must be a value type.</typeparam>
            <param name="size">Variable length <see cref="T:System.Array"/> or comma separated list with lengths of the dimensions of the new array.</param>
            <returns>New array of the specified size and <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> storage order, initialized with '0'.</returns>
            <remarks>
            <para><paramref name="size"/> cannot be <c>null</c>. Its lengths determines the number of dimensions of the new array. The elements  
            determine the lengths of corresponding dimensions and cannot contain negative values.</para>
            <para>Arrays returned from this overload are in <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> storage order. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> for 
            determining the storage order explicitly.</para>
            <para>Since the variable length parameter list and the 'params' keyword (C#) implicitly allocates new storage under the control of the 
            GC consider using one of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0)"/> overloads and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/> instead to provide the dimension lengths. 
            This is recommended when high-performance is important.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)"/>
            <seealso cref="F:ILNumerics.Size.MaxNumberOfDimensions"/>
            <seealso href="https://ilnumerics.net/ArrayCreation3.html"/>
            <exception cref="T:System.ArgumentException">if <typeparamref name="T"/> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double"/>, float, int, ...), 
            <see cref="T:ILNumerics.complex"/> or <see cref="T:ILNumerics.fcomplex"/>.</exception>
            <exception cref="T:System.ArgumentException">if <paramref name="size"/> is null, has more elements than <see cref="F:ILNumerics.Size.MaxNumberOfDimensions"/> or contains negative values.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cart2pol(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})">
            <summary>
            Transform scalar coordinates into polar (cylindrical) coordinates
            </summary>
            <param name="X">X coordinates</param>
            <param name="Y">Y coordinates</param>
            <param name="Z">Z coordinates (height). Can be null if <paramref name="outZ"/> is not requested.</param>
            <param name="Radius">[Optional] Output: radius. Default: (null) do not compute.</param>
            <param name="outZ">[Optional] Output: Copy of Z. Default: (null) do not return.</param>
            <returns>Angles. Radius and Z values are returned as output parameters if requested on entry (i.e.: not null).</returns>
            <remarks><paramref name="X"/>, <paramref name="Y"/>, and <paramref name="Z"/> must be the 
            same size or broadcastable to each other. Polar coordinate arrays returned are of the same 
            size as the broadcasted size of the input arrays.
            <para>If <paramref name="outZ"/> is requested it will have the same values as <paramref name="Z"/> and 
            the same broadcasted size of the output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cart2pol(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})">
            <summary>
            Transforms scalar coordinates into polar (cylindrical) coordinates.
            </summary>
            <param name="X">X coordinates.</param>
            <param name="Y">Y coordinates.</param>
            <param name="Z">Z coordinates (height).</param>
            <param name="Radius">[Optional] Output: radius. Default: (null) do not compute.</param>
            <param name="outZ">[Optional] Output: Copy of Z. Default: (null) do not return.</param>
            <returns>Angles. Radius and Z values are returned as output parameters if requested on entry (i.e.: not null).</returns>
            <remarks><paramref name="X"/>, <paramref name="Y"/>, and <paramref name="Z"/> must be the 
            same size or broadcastable to each other. Polar coordinate arrays returned are of the same 
            size as the broadcasted size of the input arrays.
            <para>If <paramref name="outZ"/> is requested it will have the same values as <paramref name="Z"/> and 
            the same broadcasted size of the output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cart2sphere(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})">
            <summary>
            Transforms cartesian coordinates into spherical coordinates.
            </summary>
            <param name="X">X coordinate.</param>
            <param name="Y">Y coordinate.</param>
            <param name="Z">Z coordinate.</param>
            <param name="Theta">[Optional] Output: polar angle. Default: (null) do not compute.</param>
            <param name="Phi">[Optional] Output: Azimuthal angle. Default: (null) do not compute.</param>
            <returns>Array with the radius values.<paramref name="Theta"/> and <paramref name="Phi"/> are returned on request 
            (i.e.: if not null on entry). </returns>
            <remarks> The input parameters <paramref name="X"/>, <paramref name="Y"/> and <paramref name="Z"/>
            must be of the same size or broadcasting compatible. All arrays returned are of the broadcasted size </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cart2sphere(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})">
            <summary>
            Transforms cartesian coordinates into spherical coordinates.
            </summary>
            <param name="X">X coordinate.</param>
            <param name="Y">Y coordinate.</param>
            <param name="Z">Z coordinate.</param>
            <param name="Theta">[Optional] Output: polar angle. Default: (null) do not compute.</param>
            <param name="Phi">[Optional] Output: Azimuthal angle. Default: (null) do not compute.</param>
            <returns>Array with the radius values.<paramref name="Theta"/> and <paramref name="Phi"/> are returned on request 
            (i.e.: if not null on entry). </returns>
            <remarks> The input parameters <paramref name="X"/>, <paramref name="Y"/> and <paramref name="Z"/>
            must be of the same size or broadcasting compatible. All arrays returned are of the broadcasted size </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.checknull``1(ILNumerics.InArray{``0},System.Func{ILNumerics.RetArray{``0}})">
            <summary>
            Checks if <paramref name="A"/> is valid, assign default if null. 
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="A">Input array.</param>
            <param name="onNull">Provides default value when <paramref name="A"/> is null. This is only evaluated when <paramref name="A"/> is null.</param>
            <returns><paramref name="A"/> or the result returned from <paramref name="onNull"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.check``1(ILNumerics.InArray{``0},System.Func{ILNumerics.InArray{``0},ILNumerics.RetArray{``0}},System.Boolean,System.String,ILNumerics.InArray{``0})">
            <summary>
            Checks if <paramref name="A"/> is a valid parameter.
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="A">Input array.</param>
            <param name="ErrorMessage">[Optional] Exception message.</param>
            <param name="evaluation">[Optional] Evaluation function, checks input parameter and transforms it into result, gets only called for <paramref name="A"/> other than null</param>
            <param name="allowNullInput">[optional] Only if <paramref name="A"/> is null -> for true: returns null, false: throws exception. If <paramref name="Default"/> was defined, this parameter is ignored.</param>
            <param name="Default">[optional] If <paramref name="A"/> is null on input, this value is returned. If no default is given (i.e: null), <paramref name="allowNullInput"/> is evaluated.</param>
            <returns>Result of calling <paramref name="evaluation"/>(<paramref name="A"/>) or <paramref name="A"/>.</returns>
            <exception cref="T:System.ArgumentException">If A was null on entry and <paramref name="allowNullInput"/> is false</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.check(ILNumerics.InLogical,System.Func{ILNumerics.InLogical,ILNumerics.RetLogical},System.Boolean,System.String)">
            <summary>
            Checks if <paramref name="A"/> is a valid parameter.
            </summary>
            <param name="A">Input array.</param>
            <param name="ErrorMessage">[Optional] Exception message. Default: empty string.</param>
            <param name="evaluation">[Optional] Evaluation function, checks input parameter and transforms it into result, gets only called for <paramref name="A"/> other than null.</param>
            <param name="allowNullInput">[Optional] Only if <paramref name="A"/> is null -> for true: returns null, false: throws exception.</param>
            <returns>Result of calling <paramref name="evaluation"/>(<paramref name="A"/>) or <paramref name="A"/>.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> was null on entry and <paramref name="allowNullInput"/> is false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.check(ILNumerics.InCell,System.Func{ILNumerics.InCell,ILNumerics.RetCell},System.Boolean,System.String)">
            <summary>
            Check if <paramref name="A"/> is a valid parameter.
            </summary>
            <param name="A">Input array.</param>
            <param name="ErrorMessage">[Optional] Exception message</param>
            <param name="evaluation">[Optional] Evaluation function, checks <paramref name="A"/> and transforms it into result, gets only called for <paramref name="A"/> other than null.</param>
            <param name="allowNullInput">[Optional] Only if <paramref name="A"/> is null -> true: returns null, false: throws exception.</param>
            <returns>Result of calling <paramref name="evaluation"/>(<paramref name="A"/>) or <paramref name="A"/>.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> was null on entry and <paramref name="allowNullInput"/> is false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.csvread``1(System.String,System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Func{System.String,``0},System.String,System.Globalization.CultureInfo)">
            <summary>
            Reads comma separated values from lines in a string, optionally using custom separators, element and number formats.
            </summary>
            <typeparam name="T">Element type to return.</typeparam>
            <param name="csvData">String with CSV data in lines.</param>
            <param name="startRow">[Optional] Start reading the values from that row. Default: 0.</param>
            <param name="startCol">[Optional] Start reading values from that column. Default: 0.</param>
            <param name="endRow">[Optional] Index of the last row to take into account. Default: last row in <paramref name="csvData"/>.</param>
            <param name="endCol">[Optional] Index of the last column to take into account. Default: last column in <paramref name="csvData"/>.</param>
            <param name="elementConverter">[Optional] Custom function to convert each element from its string representation. Default: parse as <see cref="T:System.Double"/>.</param>
            <param name="elementSeparator">[Optional] String separating individual elements. Default: , (comma)</param>
            <param name="culture">[Optional] Number format used while parsing individual elements. Default: invariant culture (not current thread culture!)</param>
            <returns>Matrix with elements read from <paramref name="csvData"/>.</returns>
            <remarks><para>The data lines in <paramref name="csvData"/> is parsed using <paramref name="elementSeparator"/> as element 
            separator. Arbitrary element types <typeparamref name="T"/> can be parsed by providing a customized function 
            <paramref name="elementConverter"/> for parsing individual elements. The current threads culture is temporarily changed to use the 
            <see href="System.Globalization.NumberFormatInfo">number format info</see> provided in <paramref name="culture"/>. The number 
            format provides the parser with info about decimal separators among others used to determine number formats for parsing.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.csvread``1(System.IO.Stream,System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Func{System.String,``0},System.String,System.Globalization.CultureInfo,System.Text.Encoding,System.Boolean)">
            <summary>
            Reads comma separated values from stream, optionally using custom separators, element and number formats.
            </summary>
            <typeparam name="T">Element type to return.</typeparam>
            <param name="stream">Stream with CSV data in lines.</param>
            <param name="startRow">[Optional] Start reading the values from that row. Default: 0.</param>
            <param name="startCol">[Optional] Start reading values from that column. Default: 0.</param>
            <param name="endRow">[Optional] Index of the last row to take into account. Default: last row in <paramref name="stream"/>.</param>
            <param name="endCol">[Optional] Index of the last column to take into account. Default: last column in <paramref name="stream"/>.</param>
            <param name="elementConverter">[Optional] Custom function to convert each element from its string representation. Default: parse as <see cref="T:System.Double"/>.</param>
            <param name="elementSeparator">[Optional] String separating individual elements. Default: , (comma)</param>
            <param name="culture">[Optional] Number format used while parsing individual elements. Default: invariant culture (not current thread culture!)</param>
            <param name="encoding">[Optional] Encoding used to read bytes from stream. Default: ASCII encoding.</param>
            <param name="leaveStreamOpen">[Optional] If set to true <paramref name="stream"/> will not be closed by this method. Default: false.</param>
            <returns>Matrix with elements read from <paramref name="stream"/>.</returns>
            <remarks><para>The data lines in <paramref name="stream"/> are parsed using <paramref name="elementSeparator"/> as element 
            separator. Arbitrary element types <typeparamref name="T"/> can be parsed by providing a customized function 
            <paramref name="elementConverter"/> for parsing individual elements. The current threads culture is temporarily changed to use the 
            <see href="System.Globalization.CultureInfo">number format info</see> provided in <paramref name="culture"/>. The number 
            format of the given culture provides the parser with info about decimal separators among others used to determine number formats for parsing.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.CSVParseDoubleAs``1(System.String)">
            <summary>
            Parses an input string to double first, than converts it if the given type <typeparamref name="T"/> is not <see cref="T:System.Double"/>.
            </summary>
            <typeparam name="T">Type of array elements to return.</typeparam>
            <param name="element">CSV element to parse.</param>
            <returns>Parsed CSV element with a type of <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.csvreadinternal``1(ILNumerics.Core.Misc.CSVLinesProvider{``0},System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Func{System.String,``0},System.String)">
            <summary>
            Private generalization of reading CSV files. 
            The method hides stream/string input with CsvHelper class. 
            It allows the user to specify special functions to convert their special data.
            </summary>
            <typeparam name="T">Element type to return.</typeparam>
            <param name="helper">CsvHelper to hide stream/string inputs.</param>
            <param name="startRow">[Optional] Start reading the values from that row. Default: 0.</param>
            <param name="startCol">[Optional] Start reading values from that column. Default: 0.</param>
            <param name="endRow">[Optional] Index of the last row to take into account. Default: last row in <paramref name="helper"/>.</param>
            <param name="endCol">[Optional] Index of the last column to take into account. Default: last column in <paramref name="helper"/>.</param>
            <param name="elementParser">[Optional] Element parser funtion.</param>
            <param name="elementSeparator">[Optional] String separating individual elements. Default: , (comma)</param>
            <returns>Matrix with elements read from source wrapped by helper.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.csvwrite``1(ILNumerics.InArray{``0},System.IO.Stream,System.Func{``0,System.String},System.String,System.Globalization.CultureInfo,System.Text.Encoding,System.Boolean)">
            <summary>
            Write ILNumerics array as separated strings to stream
            </summary>
            <typeparam name="T">Element type of input array A</typeparam>
            <param name="A">ILNumerics array to write as CSV. This is expected to be a matrix.</param>
            <param name="stream">Stream to write values to.</param>
            <param name="elementConverter">[optional] Custom function used to convert elements of A to string. Default: [T].ToString()</param>
            <param name="elementSeparator">[optional] Character chain used to separate individual elements. Default: ',' (comma).</param>
            <param name="culture">[optional] Number format info used to acquire formatting information for converting numbers to string. Default: invariant culture (not current thread culture!)</param>
            <param name="encoding">[optional] Encoding used to write the string representation of individual elements to the bytes of the stream.</param>
            <param name="leaveStreamOpen">[Optional] If set to true <paramref name="stream"/> will not be closed by this method. Default: false.</param>
            <remarks><para>A is expected to be a matrix. If A has more than 2 dimensions trailing dimensions will be joined to the second dimension. This corresponds to: A[":;:"].</para>
            <para>The optional parameters <paramref name="elementConverter"/>, <paramref name="elementSeparator"/> and <paramref name="culture"/>
            are used to control the format of the resulting CSV result.<paramref name="elementConverter"/> is used to convert a single element of <paramref name="A"/> into its string representation, using the current cultures number format or the <see cref="T:System.Globalization.CultureInfo"/> provided by <paramref name="culture"/>.</para>
            <para>Individual elements will be separated in the CSV result by ',' (comma) or by the character chain provided by <paramref name="elementSeparator"/>.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.csvwrite``1(ILNumerics.InArray{``0},System.String,System.Func{``0,System.String},System.String,System.Globalization.CultureInfo,System.Text.Encoding)">
            <summary>
            Write ILNumerics array as separated strings to file
            </summary>
            <typeparam name="T">Element type of input array A</typeparam>
            <param name="A">ILNumerics array to write as CSV. This is expected to be a matrix.</param>
            <param name="filename">Name of the file to write values to.</param>
            <param name="elementConverter">[optional] Custom function used to convert elements of A to string. Default: [T].ToString()</param>
            <param name="elementSeparator">[optional] Character chain used to separate individual elements. Default: ',' (comma).</param>
            <param name="culture">[optional] Number format info used to acquire formatting information for converting numbers to string. Default: invariant culture (not current thread culture!)</param>
            <param name="encoding">[optional] Encoding used to write the string representation of individual elements to the bytes of the file.</param>
            <remarks><para>A is expected to be a matrix. If A has more than 2 dimensions trailing dimensions will be joined to the second dimension. This corresponds to: A[":;:"].</para>
            <para>The optional parameters <paramref name="elementConverter"/>, <paramref name="elementSeparator"/> and <paramref name="culture"/>
            are used to control the format of the resulting CSV result.<paramref name="elementConverter"/> is used to convert a single element of <paramref name="A"/> into its string representation, using the current cultures number format or the <see cref="T:System.Globalization.CultureInfo"/> provided by <paramref name="culture"/>.</para>
            <para>Individual elements will be separated in the CSV result by ',' (comma) or by the character chain provided by <paramref name="elementSeparator"/>.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.distL1(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
            <summary>
            Pairwise L1 distance. Aka: Manhattan distance. 
            </summary>
            <param name="A">Input points (matrix).</param>
            <param name="B">Input point (vector).</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is commutative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.distL1(ILNumerics.InArray{System.Int64},ILNumerics.InArray{System.Int64})">
            <summary>
            Pairwise L1 distance. Aka: Manhattan distance. 
            </summary>
            <param name="A">Input points (matrix).</param>
            <param name="B">Input point (vector).</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is commutative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.distL1(ILNumerics.InArray{System.Int32},ILNumerics.InArray{System.Int32})">
            <summary>
            Pairwise L1 distance. Aka: Manhattan distance. 
            </summary>
            <param name="A">Input points (matrix).</param>
            <param name="B">Input point (vector).</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is commutative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.distL1(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})">
            <summary>
            Pairwise L1 distance. Aka: Manhattan distance. 
            </summary>
            <param name="A">Input points (matrix).</param>
            <param name="B">Input point (vector).</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is commutative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.distL1(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})">
            <summary>
            Pairwise L1 distance. Aka: Manhattan distance. 
            </summary>
            <param name="A">Input points (matrix).</param>
            <param name="B">Input point (vector).</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is commutative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.distL1(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})">
            <summary>
            Pairwise L1 distance. Aka: Manhattan distance. 
            </summary>
            <param name="A">Input points (matrix).</param>
            <param name="B">Input point (vector).</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is commutative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Double})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Double},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Double})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Double},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Double})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Double},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Double})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt64})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt64})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt64})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int64})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int64})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int64})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt32})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt32})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt32})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int32})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int32})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int32})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int32})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt16})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt16})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt16})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int16})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int16})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int16})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int16})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Byte})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Byte})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Byte})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Byte})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.SByte})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.SByte})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.SByte})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.SByte})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{ILNumerics.complex})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Single})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Single})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Single})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Single})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Double})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Double})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Double})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Double})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt64},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt64})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt64},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt64})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt64},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt64})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int64})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int64},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int64})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int64},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int64})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int64},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int64})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt32},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt32})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt32},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt32})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt32},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt32})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int32})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int32},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int32})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int32},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int32})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int32},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int32})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt16},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt16})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt16},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt16})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt16},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt16})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int16})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int16},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int16})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int16},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int16})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int16},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int16})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Byte})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Byte},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Byte})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Byte},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Byte})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Byte},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Byte})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.SByte})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.SByte},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.SByte})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.SByte},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.SByte})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.SByte},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.SByte})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{ILNumerics.fcomplex})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{ILNumerics.complex},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{ILNumerics.complex})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{ILNumerics.complex},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{ILNumerics.complex})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{ILNumerics.complex},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{ILNumerics.complex})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Single})">
            <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <returns>Sequential indices of the non-zero-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Single},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Single})">
            <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
            <param name="V">[Optional] Return the found non-zero element values in <paramref name="V"/>. Default: (null) don't return the values.</param>
            <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> or <paramref name="V"/> are not null on entry they are filled with the requested respective 
            info as column vectors. If <paramref name="C"/> is not null it contains the column indices of non-zero values. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices of <paramref name="A"/> (column major order). </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Single},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Single})"/>
            corresponds to the indices of the rows of non-zero values if <paramref name="C"/> is not null and to sequential indices of those 
            non-zero values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Single},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Single})"/>
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            non-zero elements were found, whatever comes first.</para>
            <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64"/>. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32"/>
            values. Such functions are decorated with the suffix '32' in their names.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Boolean})">
            <summary>
            Find true elements in n-d array and give their sequential index (column major order).
            </summary>
            <param name="A">Source logical array.</param>
            <returns>Sequential indices of the true-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Boolean})">
            <summary>
            Find true elements in n-d array and give their sequential index (column major order). Assumes <![CDATA[<paramref name="A"/>.S.NumberOfElements < uint.MaxValue]]>.
            </summary>
            <param name="A">Source logical array.</param>
            <returns>Sequential indices of the true-valued elements in <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Boolean},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64})">
            <summary>
            Find sequential indices of <c>true</c> elements in n-d array, searches from start to end in column major order.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of <c>true</c> elements to find. Default: (0) find all <c>true</c> elements.</param>
            <returns>Sequential, column major ordered indices of the <c>true</c>-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> is not null on entry it contains the column indices of <c>true</c> values when the function returns. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices. </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Double},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Double})"/>
            corresponds to the indices of the rows of <c>true</c> values if <paramref name="C"/> is not null and to sequential indices of those 
            <c>true</c> values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Double},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Double})"/>
            starts searching for <c>true</c> values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            <c>true</c> elements were found, if more than <paramref name="n"/> <c>true</c> elements are contained in <paramref name="A"/>.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Boolean},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int32})">
            <summary>
            Find sequential indices of <c>true</c> elements in n-d array, searches from start to end in column major order. Assumes <![CDATA[<paramref name="A"/>.S.NumberOfElements < uint.MaxValue]]>.
            </summary>
            <param name="A">Source array.</param>
            <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A"/>.</param>
            <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C"/>. Default: (null) the function returns the sequential indices of elements found only.</param>
            <param name="n">[Optional] Maximum number of <c>true</c> elements to find. Default: (0) find all <c>true</c> elements.</param>
            <returns>Sequential, column major ordered indices of the <c>true</c>-valued elements in <paramref name="A"/> or row indices if <paramref name="C"/> is not null.</returns>
            <remarks><para>If <paramref name="C"/> is not null on entry it is filled with the column indices of <c>true</c> values as column vector. If <paramref name="A"/> 
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C"/> 
            are considered sequential indices. </para>
            <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Double},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Double})"/>
            corresponds to the indices of the rows of <c>true</c> values if <paramref name="C"/> is not null and to sequential indices of those 
            <c>true</c> values if <paramref name="C"/> is null. </para>
            <para>Negative values of <paramref name="n"/> are considered as abs(n).</para>
            <para>If <paramref name="backwards"/> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Double},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Double})"/>
            starts searching for <c>true</c> values from the last element and proceeds in column major order to the first element or until <paramref name="n"/> 
            <c>true</c> elements were found, if more than <paramref name="n"/> <c>true</c> elements are contained in <paramref name="A"/>.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)">
            <summary>
            Computes dimensional indices from squential indices. 
            </summary>
            <param name="A">The input array providing the size, strides and element type to compute subscript indices for.</param>
            <param name="indices">Sequential ('linear') indices into <paramref name="A"/>. n elements of arbitrary shape.</param>
            <param name="nrOutDims">[Optional] Number of subscript dimensions. Default: (-1) <paramref name="A"/>.S.NumberOfDimensions.</param>
            <returns>A matrix [m, n], where m = <c><paramref name="indices"/>.S.NumberOfElements</c> and n = <c>A.S.NumberOfDimensions</c>. Indices 
            for each dimension are stored in columns.</returns>
            <remarks><para>This function converts sequential element indices into subscript indices. Subscript indices specify the position of an 
            element in <paramref name="A"/> by giving the position of the element in each dimension individually. Hence, n subscript indices are 
            required to describe the element position in <paramref name="A"/>. In contrast to that, sequential indices specify the position of an 
            element in <paramref name="A"/> by a single sequential index, where all elements are considered to be 'lined-up'. The sequential index 
            is than simply the index of the element in the line.</para>
            <para>The (virtual) lining-up of the elements in <paramref name="A"/> is performed in column major order. Note, 
            that the order considered by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)"/> is not related to the actual order
            of the elements as they are stored in memory.</para>
            <para>If <paramref name="indices"/> is not a vector its elements are read in column major order.</para>
            <para>If the optional parameter <paramref name="nrOutDims"/> is positive it specifies the number of output subscript dimensions to compute. 
            This number can differ from the actual number of dimensions in <paramref name="A"/>. If <paramref name="nrOutDims"/> is smaller than the 
            number of dimensions in <paramref name="A"/> unspecified trailing dimensions of <paramref name="A"/> are virtually merged and the last 
            column of subscript indices holds the indices into those merged dimension. Note, that in order to use these indices to address elements 
            of <paramref name="A"/> subarray indexing must be performed in <see cref="P:ILNumerics.Settings.ArrayStyle"/> = <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>.</para>
            <para>If <paramref name="nrOutDims"/> is larger than <c><paramref name="A"/>.S.NumberOfDimensions</c> then subscripts in columns 
            corresponding to virtual dimensions of <paramref name="A"/> will be '0'.</para>
            <para>The matrix returned gives the subscripts for each element index in <paramref name="indices"/> in rows. The matrix stores m rows of 
            subscripts, corresponding to m elements in <paramref name="indices"/>.</para>
            <para><paramref name="indices"/> can contain values addressing non-existing elements in <paramref name="A"/> (indices out-of-range). 
            These indices will produce out-of-range subscript indices also. In <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> they may be used to grow the 
            size of an array in a left-side index expression. <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)"/>
            does not give an error for out-of-range elements nor for negative values in <paramref name="indices"/>! The special meaning of latter (i.e.: 
            counting from the end) is not considered here.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})"/>
            and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)"/>
            are equivalent operations, inverting the results of the respective other function. Combining both functions creates a roundtrip and gives 
            the original data.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> has less than 1 dimension.</exception>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> or <paramref name="indices"/> are null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.UInt32},System.Int32)">
            <summary>
            Computes dimensional indices from squential indices. 
            </summary>
            <param name="A">The input array providing the size, strides and element type to compute subscript indices for.</param>
            <param name="indices">Sequential ('linear') indices into <paramref name="A"/>. n elements of arbitrary shape.</param>
            <param name="nrOutDims">[Optional] Number of subscript dimensions. Default: (-1) <paramref name="A"/>.S.NumberOfDimensions.</param>
            <returns>A matrix [m, n], where m = <c><paramref name="indices"/>.S.NumberOfElements</c> and n = <c>A.S.NumberOfDimensions</c>. Indices 
            for each dimension are stored in columns.</returns>
            <remarks><para>This function converts sequential element indices into subscript indices. Subscript indices specify the position of an 
            element in <paramref name="A"/> by giving the position of the element in each dimension individually. Hence, n subscript indices are 
            required to describe the element position in <paramref name="A"/>. In contrast to that, sequential indices specify the position of an 
            element in <paramref name="A"/> by a single sequential index, where all elements are considered to be 'lined-up'. The sequential index 
            is than simply the index of the element in the line.</para>
            <para>The (virtual) lining-up of the elements in <paramref name="A"/> is performed in column major order. Note, 
            that the order considered by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)"/> is not related to the actual order
            of the elements as they are stored in memory.</para>
            <para>If <paramref name="indices"/> is not a vector its elements are read in column major order.</para>
            <para>If the optional parameter <paramref name="nrOutDims"/> is positive it specifies the number of output subscript dimensions to compute. 
            This number can differ from the actual number of dimensions in <paramref name="A"/>. If <paramref name="nrOutDims"/> is smaller than the 
            number of dimensions in <paramref name="A"/> unspecified trailing dimensions of <paramref name="A"/> are virtually merged and the last 
            column of subscript indices holds the indices into those merged dimension. Note, that in order to use these indices to address elements 
            of <paramref name="A"/> subarray indexing must be performed in <see cref="P:ILNumerics.Settings.ArrayStyle"/> = <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>.</para>
            <para>If <paramref name="nrOutDims"/> is larger than <c><paramref name="A"/>.S.NumberOfDimensions</c> then subscripts in columns 
            corresponding to virtual dimensions of <paramref name="A"/> will be '0'.</para>
            <para>The matrix returned gives the subscripts for each element index in <paramref name="indices"/> in rows. The matrix stores m rows of 
            subscripts, corresponding to m elements in <paramref name="indices"/>.</para>
            <para><paramref name="indices"/> can contain values addressing non-existing elements in <paramref name="A"/> (indices out-of-range). 
            These indices will produce out-of-range subscript indices also. In <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> they may be used to grow the 
            size of an array in a left-side index expression. <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)"/>
            does not give an error for out-of-range elements nor for negative values in <paramref name="indices"/>! The special meaning of latter (i.e.: 
            counting from the end) is not considered here.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})"/>
            and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)"/>
            are equivalent operations, inverting the results of the respective other function. Combining both functions creates a roundtrip and gives 
            the original data.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> has less than 1 dimension.</exception>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> or <paramref name="indices"/> are null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isempty(ILNumerics.BaseArray)">
            <summary>
            Tests if <paramref name="A"/> has no elements.
            </summary>
            <param name="A">Input array.</param>
            <returns>True if <paramref name="A"/> has no elements, false otherwise.</returns>
            <remarks>
            <para>This function is an alias for <see cref="P:ILNumerics.BaseArray.IsEmpty"/>.</para>
            </remarks>
            <seealso cref="P:ILNumerics.BaseArray.IsEmpty"/>
            <seealso cref="P:ILNumerics.Size.NumberOfElements"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isnullorempty(ILNumerics.BaseArray)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isequal(ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Compares the number, shape, and type of elements of <paramref name="A"/> and <paramref name="B"/> and returns true if both are the same. 
            </summary>
            <param name="A">First input array.</param>
            <param name="B">Second input array.</param>
            <returns>True, if all elements and sizes of both arrays match; false otherwise.</returns>
            <remarks><para>Binary comparison is used on the elements. For floating point elements slight round-off 
            errors will cause the comparison to fail! Use <![CDATA['allall(abs(A - B) &lt; tol)']]> or similar for floating point 
            arrays instead. The same is recommended when performance is a critical factor: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isequal(ILNumerics.BaseArray,ILNumerics.BaseArray)"/> 
            (just like the underlying function <see cref="M:ILNumerics.BaseArray.Equals(System.Object)"/>) does not parallelize automatically and is recommended 
            for simple, non-performance critical comparisons only.</para>
            <para>If both arrays differ only in singleton dimensions but the types and (binary) values of all corresponding 
            elements are equal the comparison can still succeed. Consider using <see cref="M:ILNumerics.Size.IsSameShape(ILNumerics.Size)"/> additionally 
            for a stricter comparisons including singleton dimensions.</para>
            <para>This function is an alias for <see cref="M:ILNumerics.BaseArray.Equals(System.Object)"/> which overrides <see cref="M:System.Object.Equals(System.Object)"/>. 
            In difference to latter the function does not perform reference comparison but the type and value of the elements are 
            compared too.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BaseArray.Equals(System.Object)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{System.Boolean})"/>
            <seealso cref="M:ILNumerics.Size.IsSameShape(ILNumerics.Size)"/>
            <seealso cref="M:ILNumerics.Size.IsSameSize(ILNumerics.Size)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isequalwithequalnans(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
            <summary>
            Checks if all elements of two arrays are equal, comparing NaN and +/- infinity like regular values. 
            </summary>
            <param name="A">Input array</param>
            <param name="B">Input array</param>
            <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isequalwithequalnans(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})">
            <summary>
            Checks if all elements of two arrays are equal, comparing NaN and +/- infinity like regular values. 
            </summary>
            <param name="A">Input array</param>
            <param name="B">Input array</param>
            <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isequalwithequalnans(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})">
            <summary>
            Checks if all elements of two arrays are equal, comparing NaN and +/- infinity like regular values. 
            </summary>
            <param name="A">Input array</param>
            <param name="B">Input array</param>
            <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isequalwithequalnans(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})">
            <summary>
            Checks if all elements of two arrays are equal, comparing NaN and +/- infinity like regular values. 
            </summary>
            <param name="A">Input array</param>
            <param name="B">Input array</param>
            <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isnull(ILNumerics.BaseArray)">
            <summary>
            Determine, if the array A is null (NULL, not assigned).
            </summary>
            <param name="A">Input array.</param>
            <returns>True, if the array is null, false otherwise</returns>
            <remarks>This function is similar to <see cref="M:System.Object.Equals(System.Object)"/>. The difference is that memory management is performed on A.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isnullorempty(ILNumerics.BaseArray)">
            <summary>
            Tests if <paramref name="A"/> is null (NULL or not assigned) or has no elements.
            </summary>
            <param name="A">Input array.</param>
            <returns>True if <paramref name="A"/> is null or empty, false otherwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.istrilow(ILNumerics.InArray{System.Double})">
            <summary>
            Determines if matrix <paramref name="A"/> is a lower triangular matrix.
            </summary>
            <param name="A">Matrix of numeric element type.</param>
            <returns>true if <paramref name="A"/> is a lower triangular matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null or not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.istriup(ILNumerics.InArray{System.Double})">
            <summary>
            Determines if matrix <paramref name="A"/> is an upper triangular matrix.
            </summary>
            <param name="A">Matrix or scalar array <paramref name="A"/>, numeric element type.</param>
            <returns>true if <paramref name="A"/> is an upper triangular matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null or not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishesslow(ILNumerics.InArray{System.Double})">
            <summary>
            Determines if matrix <paramref name="A"/> is a lower Hessenberg matrix. 
            </summary>
            <param name="A">Matrix or scalar of numeric element type.</param>
            <returns>true if <paramref name="A"/> is a lower Hessenberg matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishessup(ILNumerics.InArray{System.Double})">
            <summary>
            Determines if matrix <paramref name="A"/> is an upper Hessenberg matrix.
            </summary>
            <param name="A">Matrix or scalar array, numeric element type.</param>
            <returns>true if <paramref name="A"/> is an upper Hessenberg matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishermitian(ILNumerics.InArray{System.Double})">
            <summary>
            Determines if matrix <paramref name="A"/> is a hermitian matrix.
            </summary>
            <param name="A">Matrix or scalar array, numeric element type.</param>
            <returns>true if A is a hermitian matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if A was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.istrilow(ILNumerics.InArray{ILNumerics.fcomplex})">
            <summary>
            Determines if matrix <paramref name="A"/> is a lower triangular matrix.
            </summary>
            <param name="A">Matrix of numeric element type.</param>
            <returns>true if <paramref name="A"/> is a lower triangular matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null or not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.istriup(ILNumerics.InArray{ILNumerics.fcomplex})">
            <summary>
            Determines if matrix <paramref name="A"/> is an upper triangular matrix.
            </summary>
            <param name="A">Matrix or scalar array <paramref name="A"/>, numeric element type.</param>
            <returns>true if <paramref name="A"/> is an upper triangular matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null or not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishesslow(ILNumerics.InArray{ILNumerics.fcomplex})">
            <summary>
            Determines if matrix <paramref name="A"/> is a lower Hessenberg matrix. 
            </summary>
            <param name="A">Matrix or scalar of numeric element type.</param>
            <returns>true if <paramref name="A"/> is a lower Hessenberg matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishessup(ILNumerics.InArray{ILNumerics.fcomplex})">
            <summary>
            Determines if matrix <paramref name="A"/> is an upper Hessenberg matrix.
            </summary>
            <param name="A">Matrix or scalar array, numeric element type.</param>
            <returns>true if <paramref name="A"/> is an upper Hessenberg matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishermitian(ILNumerics.InArray{ILNumerics.fcomplex})">
            <summary>
            Determines if matrix <paramref name="A"/> is a hermitian matrix.
            </summary>
            <param name="A">Matrix or scalar array, numeric element type.</param>
            <returns>true if A is a hermitian matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if A was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.istrilow(ILNumerics.InArray{ILNumerics.complex})">
            <summary>
            Determines if matrix <paramref name="A"/> is a lower triangular matrix.
            </summary>
            <param name="A">Matrix of numeric element type.</param>
            <returns>true if <paramref name="A"/> is a lower triangular matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null or not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.istriup(ILNumerics.InArray{ILNumerics.complex})">
            <summary>
            Determines if matrix <paramref name="A"/> is an upper triangular matrix.
            </summary>
            <param name="A">Matrix or scalar array <paramref name="A"/>, numeric element type.</param>
            <returns>true if <paramref name="A"/> is an upper triangular matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null or not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishesslow(ILNumerics.InArray{ILNumerics.complex})">
            <summary>
            Determines if matrix <paramref name="A"/> is a lower Hessenberg matrix. 
            </summary>
            <param name="A">Matrix or scalar of numeric element type.</param>
            <returns>true if <paramref name="A"/> is a lower Hessenberg matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishessup(ILNumerics.InArray{ILNumerics.complex})">
            <summary>
            Determines if matrix <paramref name="A"/> is an upper Hessenberg matrix.
            </summary>
            <param name="A">Matrix or scalar array, numeric element type.</param>
            <returns>true if <paramref name="A"/> is an upper Hessenberg matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishermitian(ILNumerics.InArray{ILNumerics.complex})">
            <summary>
            Determines if matrix <paramref name="A"/> is a hermitian matrix.
            </summary>
            <param name="A">Matrix or scalar array, numeric element type.</param>
            <returns>true if A is a hermitian matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if A was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.istrilow(ILNumerics.InArray{System.Byte})">
            <summary>
            Determines if matrix <paramref name="A"/> is a lower triangular matrix.
            </summary>
            <param name="A">Matrix of numeric element type.</param>
            <returns>true if <paramref name="A"/> is a lower triangular matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null or not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.istriup(ILNumerics.InArray{System.Byte})">
            <summary>
            Determines if matrix <paramref name="A"/> is an upper triangular matrix.
            </summary>
            <param name="A">Matrix or scalar array <paramref name="A"/>, numeric element type.</param>
            <returns>true if <paramref name="A"/> is an upper triangular matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null or not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishesslow(ILNumerics.InArray{System.Byte})">
            <summary>
            Determines if matrix <paramref name="A"/> is a lower Hessenberg matrix. 
            </summary>
            <param name="A">Matrix or scalar of numeric element type.</param>
            <returns>true if <paramref name="A"/> is a lower Hessenberg matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishessup(ILNumerics.InArray{System.Byte})">
            <summary>
            Determines if matrix <paramref name="A"/> is an upper Hessenberg matrix.
            </summary>
            <param name="A">Matrix or scalar array, numeric element type.</param>
            <returns>true if <paramref name="A"/> is an upper Hessenberg matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishermitian(ILNumerics.InArray{System.Byte})">
            <summary>
            Determines if matrix <paramref name="A"/> is a hermitian matrix.
            </summary>
            <param name="A">Matrix or scalar array, numeric element type.</param>
            <returns>true if A is a hermitian matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if A was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.istrilow(ILNumerics.InArray{System.Int64})">
            <summary>
            Determines if matrix <paramref name="A"/> is a lower triangular matrix.
            </summary>
            <param name="A">Matrix of numeric element type.</param>
            <returns>true if <paramref name="A"/> is a lower triangular matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null or not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.istriup(ILNumerics.InArray{System.Int64})">
            <summary>
            Determines if matrix <paramref name="A"/> is an upper triangular matrix.
            </summary>
            <param name="A">Matrix or scalar array <paramref name="A"/>, numeric element type.</param>
            <returns>true if <paramref name="A"/> is an upper triangular matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null or not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishesslow(ILNumerics.InArray{System.Int64})">
            <summary>
            Determines if matrix <paramref name="A"/> is a lower Hessenberg matrix. 
            </summary>
            <param name="A">Matrix or scalar of numeric element type.</param>
            <returns>true if <paramref name="A"/> is a lower Hessenberg matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishessup(ILNumerics.InArray{System.Int64})">
            <summary>
            Determines if matrix <paramref name="A"/> is an upper Hessenberg matrix.
            </summary>
            <param name="A">Matrix or scalar array, numeric element type.</param>
            <returns>true if <paramref name="A"/> is an upper Hessenberg matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishermitian(ILNumerics.InArray{System.Int64})">
            <summary>
            Determines if matrix <paramref name="A"/> is a hermitian matrix.
            </summary>
            <param name="A">Matrix or scalar array, numeric element type.</param>
            <returns>true if A is a hermitian matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if A was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.istrilow(ILNumerics.InArray{System.Int32})">
            <summary>
            Determines if matrix <paramref name="A"/> is a lower triangular matrix.
            </summary>
            <param name="A">Matrix of numeric element type.</param>
            <returns>true if <paramref name="A"/> is a lower triangular matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null or not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.istriup(ILNumerics.InArray{System.Int32})">
            <summary>
            Determines if matrix <paramref name="A"/> is an upper triangular matrix.
            </summary>
            <param name="A">Matrix or scalar array <paramref name="A"/>, numeric element type.</param>
            <returns>true if <paramref name="A"/> is an upper triangular matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null or not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishesslow(ILNumerics.InArray{System.Int32})">
            <summary>
            Determines if matrix <paramref name="A"/> is a lower Hessenberg matrix. 
            </summary>
            <param name="A">Matrix or scalar of numeric element type.</param>
            <returns>true if <paramref name="A"/> is a lower Hessenberg matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishessup(ILNumerics.InArray{System.Int32})">
            <summary>
            Determines if matrix <paramref name="A"/> is an upper Hessenberg matrix.
            </summary>
            <param name="A">Matrix or scalar array, numeric element type.</param>
            <returns>true if <paramref name="A"/> is an upper Hessenberg matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishermitian(ILNumerics.InArray{System.Int32})">
            <summary>
            Determines if matrix <paramref name="A"/> is a hermitian matrix.
            </summary>
            <param name="A">Matrix or scalar array, numeric element type.</param>
            <returns>true if A is a hermitian matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if A was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.istrilow(ILNumerics.InArray{System.Single})">
            <summary>
            Determines if matrix <paramref name="A"/> is a lower triangular matrix.
            </summary>
            <param name="A">Matrix of numeric element type.</param>
            <returns>true if <paramref name="A"/> is a lower triangular matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null or not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.istriup(ILNumerics.InArray{System.Single})">
            <summary>
            Determines if matrix <paramref name="A"/> is an upper triangular matrix.
            </summary>
            <param name="A">Matrix or scalar array <paramref name="A"/>, numeric element type.</param>
            <returns>true if <paramref name="A"/> is an upper triangular matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null or not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishesslow(ILNumerics.InArray{System.Single})">
            <summary>
            Determines if matrix <paramref name="A"/> is a lower Hessenberg matrix. 
            </summary>
            <param name="A">Matrix or scalar of numeric element type.</param>
            <returns>true if <paramref name="A"/> is a lower Hessenberg matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishessup(ILNumerics.InArray{System.Single})">
            <summary>
            Determines if matrix <paramref name="A"/> is an upper Hessenberg matrix.
            </summary>
            <param name="A">Matrix or scalar array, numeric element type.</param>
            <returns>true if <paramref name="A"/> is an upper Hessenberg matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ishermitian(ILNumerics.InArray{System.Single})">
            <summary>
            Determines if matrix <paramref name="A"/> is a hermitian matrix.
            </summary>
            <param name="A">Matrix or scalar array, numeric element type.</param>
            <returns>true if A is a hermitian matrix, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">if A was null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.length(ILNumerics.BaseArray)">
            <summary>
            Gives the length of the longest dimension of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>The lengths of the longest dimension as system scalar type.</returns>
            <remarks>This function is the same as <see cref="P:ILNumerics.Size.Longest"/>. Memory management is performed on <paramref name="A"/>.
            <para>For numpy scalars (0 dimensions) 1 is returned.</para></remarks>
            <seealso cref="P:ILNumerics.Size.Longest"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.loadArray``1(System.String,System.String)">
            <summary>
            Load single array from matfile file.
            </summary>
            <typeparam name="T">Element type of the array to read.</typeparam>
            <param name="filename">Path to the matfile.</param>
            <param name="arrayname">[Optional] name of the requested array in the matfile. Default: (empty) load the first array found.</param>
            <returns>The array read from matfile.</returns>
            <remarks><para>If <paramref name="arrayname"/> is ommited, the first array is returned.</para>
            <para>This function is based on <see cref="T:ILNumerics.MatFile"/> which works with Matlab mat files version 6 only. 
            In order to access Matlab mat files of a newer version, use the <see cref="N:ILNumerics.IO.HDF5"/> API.</para>
            <para>The typeparameter <typeparamref name="T"/> must match the type of elements stored in the mat file.</para></remarks>
            <seealso cref="T:ILNumerics.MatFile"/>
            <seealso cref="N:ILNumerics.IO.HDF5"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.loadImage(System.String,System.Nullable{System.Drawing.Rectangle})">
            <summary>
            Load pixel data from image file.
            </summary>
            <param name="filename">Image filename.</param>
            <param name="rect">[Optional] Rectangular area in the image to read data from. Default: the whole image is read.</param>
            <returns>Image pixel data as Int32 elements</returns>
            <remarks><para>Each pixel in the image is converted to a single element in the array returned. All channels are 
            accumulated in the single element. Each channel is represented by 8 bits in the 32 bits of each Int32 element.</para>
            The image data are considered as <see cref="F:System.Drawing.Imaging.PixelFormat.Format32bppArgb"/>. If you get unexpected results, 
            make sure that the image is provided in a compatible format.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.loadImage(System.IO.Stream,System.Nullable{System.Drawing.Rectangle})">
            <summary>
            Load pixel data from image stream.
            </summary>
            <param name="inputStream">Image data as stream.</param>
            <param name="rect">[Optional] Rectangular area in the image to read data from. Default: the whole image is read.</param>
            <returns>Image pixel data as Int32 elements</returns>
            <remarks><para>Each pixel in the image is converted to a single element in the array returned. 
            All channels are accumulated in the single element. Each channel is represented by 8 bits in the 
            32 bits of each Int32 element.</para>
            The image data are considered as PixelFormat.Format32bppArgb. If you get unexpected results, make 
            sure, the image is provided in a compatible format.</remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.loadImage(System.Drawing.Image,System.Nullable{System.Drawing.Rectangle})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.loadArray``1(System.String,System.String)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.loadImage(System.Drawing.Image,System.Nullable{System.Drawing.Rectangle})">
            <summary>
            Load pixel data from image.
            </summary>
            <param name="image">The image.</param>
            <param name="rect">[Optional] Rectangular area in the image to read data from. Default: the whole image is read.</param>
            <returns>Image pixel data as Int32 elements</returns>
            <remarks><para>Each pixel in the image is converted to a single element in the array returned. All channels are accumulated in the single element. Each channel 
            is represented by 8 bits in the 32 bits of each Int32 element.</para>
            The image data are considered as PixelFormat.Format32bppArgb. If you get unexpected results, make sure, the image is provided in a compatible format.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.loadChannels(System.String,System.Nullable{System.Drawing.Rectangle})">
            <summary>
            Load ARGB pixel data from image, provide indiviudal channel data.
            </summary>
            <param name="filename">Path to image file to read pixels from.</param>
            <param name="rect">[Optional] Rectangular area to read. Default: full image size.</param>
            <returns>Array of element type byte, of image size height x width x 4. Channel data are distributed along the 3rd dimension in ARGB order.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.loadChannels(System.IO.Stream,System.Nullable{System.Drawing.Rectangle})">
            <summary>
            Load ARGB pixel data from image, provide indiviudal channel data.
            </summary>
            <param name="inputStream">Image stream with image data to read pixels from.</param>
            <param name="rect">[Optional] Rectangular area to read. Default: full image size.</param>
            <returns>Array of element type byte, of image size height x width x 4. Channel data are distributed along the 3rd dimension in ARGB order.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.loadChannels(System.Drawing.Image,System.Nullable{System.Drawing.Rectangle})">
            <summary>
            Load ARGB pixel data from image, provide indiviudal channel data.
            </summary>
            <param name="image">Image to read pixels from.</param>
            <param name="rect">[Optional] Rectangular area to read. Default: full image size.</param>
            <returns>Array of element type byte, of image size height x width x 4. Channel data are distributed along the 3rd dimension in ARGB order.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.loadBinary``1(System.IO.Stream,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Action{System.IntPtr,System.IntPtr,System.Int64})">
            <summary>
            Load binary data from stream.
            </summary>
            <typeparam name="T">Element type for the new array.</typeparam>
            <param name="stream">Input stream to read from.</param>
            <param name="leadDimLen">Length of the 'leading dimension', how many elements of T fit into one scanline?</param>
            <param name="height">Height of the area to read.</param>
            <param name="width">Widht of the area to read.</param>
            <param name="offsetWidth">[Optional] Skip that many columns. Default: 0.</param>
            <param name="offsetHeight">[Optional] Skip that many rows. Default: 0.</param>
            <param name="convertScanLine">[Optional] Function used for copying individual scanlines. Default: null (Buffer.BlockCopy). Parameters: dest*, src*, nrBytes.</param>
            <returns>Array with element type <typeparamref name="T"/> and given size with a binary copy of the region as read from <paramref name="stream"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.localMember``1">
            <summary>
            Initialize a local array variable as class attribute / field. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <returns>Empty array to be assigned to a local <see cref="T:ILNumerics.Array`1"/> variable.</returns>
            <remarks>The array returned is an empty array. Its only purpose is to serve as an initialization 
            for a local variable <see cref="T:ILNumerics.Array`1"/> as attributes in a class context. The array will not 
            be disposed after leaving the current scope or any scope above the current scope. It is useful 
            for initializing class attributes in a persistant manner. After initialization, use the 
            'Array.a = ...' property (C#) or the Array.Assign() function to assign new values to the array.</remarks>
            <seealso href="http://ilnumerics.net/ClassRules.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.localLogical">
            <summary>
            Create new empty logical array, used for logical class member (attributes) initialization.
            </summary>
            <returns>Empty logical array to be assigned to a local <see cref="T:ILNumerics.Logical"/> variable.</returns>
            <remarks>The array returned is an empty array. Its only purpose is to serve as an initialization 
            for a local variable <see cref="T:ILNumerics.Logical"/> as attributes in a class context. The array will not 
            be disposed after leaving the current scope or any scope above the current scope. It is useful 
            for initializing class attributes in a persistant manner. After initialization, use the 
            'Array.a = ...' property (C#) or the Array.Assign() function to assign new values to the array.</remarks>
            <seealso href="http://ilnumerics.net/ClassRules.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.localCell">
            <summary>
            Create new empty cell array, used for cell class member (attributes) initialization.
            </summary>
            <returns>Empty logical cell array to be assigned to a local <see cref="T:ILNumerics.Cell"/> variable.</returns>
            <remarks>The array returned is an empty cell array. Its only purpose is to serve as an initialization 
            for a local variable <see cref="T:ILNumerics.Cell"/> as attributes in a class context. The array will not 
            be disposed after leaving the current scope or any scope above the current scope. It is useful 
            for initializing class attributes in a persistant manner. After initialization, use the 
            'Array.a = ...' property (C#) or the Array.Assign() function to assign new values to the array.</remarks>
            <seealso href="http://ilnumerics.net/ClassRules.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the maximum for. This is not altered.</param>
            <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the maximum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the maximum values along a specific dimension. </para>
            <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the maximum for. This is not altered.</param>
            <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the maximum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the maximum values along a specific dimension. </para>
            <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the maximum for. This is not altered.</param>
            <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the maximum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the maximum values along a specific dimension. </para>
            <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the maximum for. This is not altered.</param>
            <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the maximum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the maximum values along a specific dimension. </para>
            <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the maximum for. This is not altered.</param>
            <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the maximum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the maximum values along a specific dimension. </para>
            <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the maximum for. This is not altered.</param>
            <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the maximum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the maximum values along a specific dimension. </para>
            <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the maximum for. This is not altered.</param>
            <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the maximum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the maximum values along a specific dimension. </para>
            <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the maximum for. This is not altered.</param>
            <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the maximum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the maximum values along a specific dimension. </para>
            <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the maximum for. This is not altered.</param>
            <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the maximum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the maximum values along a specific dimension. </para>
            <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the maximum for. This is not altered.</param>
            <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the maximum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the maximum values along a specific dimension. </para>
            <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the maximum for. This is not altered.</param>
            <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the maximum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the maximum values along a specific dimension. </para>
            <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the maximum for. This is not altered.</param>
            <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the maximum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the maximum values along a specific dimension. </para>
            <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mean(ILNumerics.InArray{System.Double},System.Int32)">
            <summary>
            Mean of <paramref name="A"/> along dimension <paramref name="dim"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If <paramref name="dim"/> 
            is omitted <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.mean(ILNumerics.InArray{System.Double},System.Int32)"/> operates along the first non singleton 
            dimension.</param>
            <returns>Mean of elements along specified or first non singleton dimension.</returns>
            <remarks>The return array has the same shape as <paramref name="A"/>, except that the 
            working dimension is reduced/expanded to length 1.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mean(ILNumerics.InArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Mean of <paramref name="A"/> along dimension <paramref name="dim"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If <paramref name="dim"/> 
            is omitted <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.mean(ILNumerics.InArray{ILNumerics.fcomplex},System.Int32)"/> operates along the first non singleton 
            dimension.</param>
            <returns>Mean of elements along specified or first non singleton dimension.</returns>
            <remarks>The return array has the same shape as <paramref name="A"/>, except that the 
            working dimension is reduced/expanded to length 1.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mean(ILNumerics.InArray{System.Single},System.Int32)">
            <summary>
            Mean of <paramref name="A"/> along dimension <paramref name="dim"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If <paramref name="dim"/> 
            is omitted <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.mean(ILNumerics.InArray{System.Single},System.Int32)"/> operates along the first non singleton 
            dimension.</param>
            <returns>Mean of elements along specified or first non singleton dimension.</returns>
            <remarks>The return array has the same shape as <paramref name="A"/>, except that the 
            working dimension is reduced/expanded to length 1.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mean(ILNumerics.InArray{ILNumerics.complex},System.Int32)">
            <summary>
            Mean of <paramref name="A"/> along dimension <paramref name="dim"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If <paramref name="dim"/> 
            is omitted <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.mean(ILNumerics.InArray{ILNumerics.complex},System.Int32)"/> operates along the first non singleton 
            dimension.</param>
            <returns>Mean of elements along specified or first non singleton dimension.</returns>
            <remarks>The return array has the same shape as <paramref name="A"/>, except that the 
            working dimension is reduced/expanded to length 1.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double})">
            <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions over a 2d grid.
            </summary>
            <param name="X">Vector of x values.</param>
            <param name="Y">Vector of y values.</param>
            <param name="outY">[Output, Optional]: if on entry <paramref name="outY"/> is not null it holds the values for the Y dimension on return.</param>
            <returns>X values matrix along the values of <paramref name="X"/>. Corresponding values for Y are returned in <paramref name="outY"/>.</returns>
            <remarks><para>The matrices returned can conveniently be used to evaluate and visualize functions of 2 variables over a grid of (X Y) positions.</para>
            <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the 
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows). 
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para></remarks>
            <exception cref="T:System.ArgumentNullException">If <paramref name="X"/> or <paramref name="Y"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})">
            <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions.
            </summary>
            <param name="X">Vector of x values.</param>
            <param name="Y">Vector of y values.</param>
            <param name="Z">Vector of z values.</param>
            <param name="outY">[Output, Optional] If on entry <paramref name="outY"/> is not null it holds the values for the y dimension on return.</param>
            <param name="outZ">[Output, Optional] If on entry <paramref name="outZ"/> is not null it holds the values for the z dimension on return.</param>
            <returns>X value array along the values of <paramref name="X"/>, arrays for y and z dimensions are returned in <paramref name="outY"/> and <paramref name="outZ"/> respectively.</returns>
            <remarks><para>The arrays returned can conveniently be used to evaluate and visualize functions of 3 variables X, Y and Z. Coordinates build 
            a 3 dimensional grid with edges at all permutations of <paramref name="X"/>, <paramref name="Y"/> and <paramref name="Z"/>.</para>
            <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the 
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows). 
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para></remarks>
            <exception cref="T:System.ArgumentNullException">If <paramref name="X"/> or <paramref name="Y"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})">
            <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions over a 2d grid.
            </summary>
            <param name="X">Vector of x values.</param>
            <param name="Y">Vector of y values.</param>
            <param name="outY">[Output, Optional]: if on entry <paramref name="outY"/> is not null it holds the values for the Y dimension on return.</param>
            <returns>X values matrix along the values of <paramref name="X"/>. Corresponding values for Y are returned in <paramref name="outY"/>.</returns>
            <remarks><para>The matrices returned can conveniently be used to evaluate and visualize functions of 2 variables over a grid of (X Y) positions.</para>
            <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the 
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows). 
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para></remarks>
            <exception cref="T:System.ArgumentNullException">If <paramref name="X"/> or <paramref name="Y"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})">
            <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions.
            </summary>
            <param name="X">Vector of x values.</param>
            <param name="Y">Vector of y values.</param>
            <param name="Z">Vector of z values.</param>
            <param name="outY">[Output, Optional] If on entry <paramref name="outY"/> is not null it holds the values for the y dimension on return.</param>
            <param name="outZ">[Output, Optional] If on entry <paramref name="outZ"/> is not null it holds the values for the z dimension on return.</param>
            <returns>X value array along the values of <paramref name="X"/>, arrays for y and z dimensions are returned in <paramref name="outY"/> and <paramref name="outZ"/> respectively.</returns>
            <remarks><para>The arrays returned can conveniently be used to evaluate and visualize functions of 3 variables X, Y and Z. Coordinates build 
            a 3 dimensional grid with edges at all permutations of <paramref name="X"/>, <paramref name="Y"/> and <paramref name="Z"/>.</para>
            <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the 
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows). 
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para></remarks>
            <exception cref="T:System.ArgumentNullException">If <paramref name="X"/> or <paramref name="Y"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single})">
            <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions over a 2d grid.
            </summary>
            <param name="X">Vector of x values.</param>
            <param name="Y">Vector of y values.</param>
            <param name="outY">[Output, Optional]: if on entry <paramref name="outY"/> is not null it holds the values for the Y dimension on return.</param>
            <returns>X values matrix along the values of <paramref name="X"/>. Corresponding values for Y are returned in <paramref name="outY"/>.</returns>
            <remarks><para>The matrices returned can conveniently be used to evaluate and visualize functions of 2 variables over a grid of (X Y) positions.</para>
            <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the 
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows). 
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para></remarks>
            <exception cref="T:System.ArgumentNullException">If <paramref name="X"/> or <paramref name="Y"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})">
            <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions.
            </summary>
            <param name="X">Vector of x values.</param>
            <param name="Y">Vector of y values.</param>
            <param name="Z">Vector of z values.</param>
            <param name="outY">[Output, Optional] If on entry <paramref name="outY"/> is not null it holds the values for the y dimension on return.</param>
            <param name="outZ">[Output, Optional] If on entry <paramref name="outZ"/> is not null it holds the values for the z dimension on return.</param>
            <returns>X value array along the values of <paramref name="X"/>, arrays for y and z dimensions are returned in <paramref name="outY"/> and <paramref name="outZ"/> respectively.</returns>
            <remarks><para>The arrays returned can conveniently be used to evaluate and visualize functions of 3 variables X, Y and Z. Coordinates build 
            a 3 dimensional grid with edges at all permutations of <paramref name="X"/>, <paramref name="Y"/> and <paramref name="Z"/>.</para>
            <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the 
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows). 
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para></remarks>
            <exception cref="T:System.ArgumentNullException">If <paramref name="X"/> or <paramref name="Y"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})">
            <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions over a 2d grid.
            </summary>
            <param name="X">Vector of x values.</param>
            <param name="Y">Vector of y values.</param>
            <param name="outY">[Output, Optional]: if on entry <paramref name="outY"/> is not null it holds the values for the Y dimension on return.</param>
            <returns>X values matrix along the values of <paramref name="X"/>. Corresponding values for Y are returned in <paramref name="outY"/>.</returns>
            <remarks><para>The matrices returned can conveniently be used to evaluate and visualize functions of 2 variables over a grid of (X Y) positions.</para>
            <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the 
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows). 
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para></remarks>
            <exception cref="T:System.ArgumentNullException">If <paramref name="X"/> or <paramref name="Y"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})">
            <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions.
            </summary>
            <param name="X">Vector of x values.</param>
            <param name="Y">Vector of y values.</param>
            <param name="Z">Vector of z values.</param>
            <param name="outY">[Output, Optional] If on entry <paramref name="outY"/> is not null it holds the values for the y dimension on return.</param>
            <param name="outZ">[Output, Optional] If on entry <paramref name="outZ"/> is not null it holds the values for the z dimension on return.</param>
            <returns>X value array along the values of <paramref name="X"/>, arrays for y and z dimensions are returned in <paramref name="outY"/> and <paramref name="outZ"/> respectively.</returns>
            <remarks><para>The arrays returned can conveniently be used to evaluate and visualize functions of 3 variables X, Y and Z. Coordinates build 
            a 3 dimensional grid with edges at all permutations of <paramref name="X"/>, <paramref name="Y"/> and <paramref name="Z"/>.</para>
            <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the 
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows). 
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para></remarks>
            <exception cref="T:System.ArgumentNullException">If <paramref name="X"/> or <paramref name="Y"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the minimum for. This is not altered.</param>
            <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the minimum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the minimum values along a specific dimension. </para>
            <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the minimum for. This is not altered.</param>
            <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the minimum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the minimum values along a specific dimension. </para>
            <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the minimum for. This is not altered.</param>
            <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the minimum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the minimum values along a specific dimension. </para>
            <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the minimum for. This is not altered.</param>
            <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the minimum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the minimum values along a specific dimension. </para>
            <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the minimum for. This is not altered.</param>
            <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the minimum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the minimum values along a specific dimension. </para>
            <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the minimum for. This is not altered.</param>
            <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the minimum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the minimum values along a specific dimension. </para>
            <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the minimum for. This is not altered.</param>
            <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the minimum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the minimum values along a specific dimension. </para>
            <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the minimum for. This is not altered.</param>
            <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the minimum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the minimum values along a specific dimension. </para>
            <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the minimum for. This is not altered.</param>
            <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the minimum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the minimum values along a specific dimension. </para>
            <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the minimum for. This is not altered.</param>
            <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the minimum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the minimum values along a specific dimension. </para>
            <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the minimum for. This is not altered.</param>
            <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the minimum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the minimum values along a specific dimension. </para>
            <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the minimum for. This is not altered.</param>
            <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
            <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
            <returns>Scalar array with the minimum value in A.</returns>
            <remarks><para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for 
            getting the minimum values along a specific dimension. </para>
            <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true' 
            for <paramref name="ignoreNaN"/> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if 
            all elements in <paramref name="A"/> are <see cref="F:System.Single.NaN"/> the value of the result will also be NaN. This is the default.</para>
            <para>The value of 'false' for <paramref name="ignoreNaN"/> gives the numpy behavior: NaN values take precedence over non-NaN values. If 
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as 
            [numpy API] extension methods on the array classes.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ndims(ILNumerics.BaseArray)">
            <summary>
            Number of dimensions of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>If <paramref name="A"/> is null: 0. Otherwise returns the number of dimensions of <paramref name="A"/>.</returns>
            <remarks>This is an alias for <see cref="P:ILNumerics.Size.NumberOfDimensions"/>.</remarks>
            <seealso cref="P:ILNumerics.Size.NumberOfDimensions"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.numel(ILNumerics.BaseArray)">
            <summary>
            Gives the number of elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>The number of elements of <paramref name="A"/> as system scalar type.</returns>
            <remarks>This function is the same as <see cref="P:ILNumerics.Size.NumberOfElements"/>. Memory management is performed on <paramref name="A"/>.
            <para>For numpy scalars (0 dimensions) 1 is returned.</para></remarks>
            <seealso cref="P:ILNumerics.Size.Longest"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.permute``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.UInt32})">
            <summary>
            Reorder dimensions of n-dimensional array <paramref name="A"/>.
            </summary>
            <param name="A">Input array</param>
            <param name="dim">New dimension order. The order of the zero-based indices of the original dimensions specify the target arrays shape.</param>
            <returns>Array with reordered dimensions.</returns>
            <remarks><paramref name="A"/> will not change. A new array is created, having 
            the dimensions rearranged in the order specified by <paramref name="dim"/>.
            <para>The length of <paramref name="dim"/> must match the number of dimensions in A: <c>A.S.NumberOfDimensions == dim.Length</c>.</para>
            <para>In version 5 <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.permute``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64})"/> became more efficient since no 
            elements must be copied for a permutation of the dimensions. The resulting array may not expose any common 
            storage layout, though. Thus, subsequent operations handling the result may have to perform a copy nevertheless.</para>
            </remarks>
            <exception cref="T:System.ArgumentException"> If the number of elements in <paramref name="A"/> and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> do not match or if any index of a dimension from <paramref name="A"/> is 
            missing in list of elements in <paramref name="dim"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.permute``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64})">
            <summary>
            Reorder dimensions of n-dimensional array <paramref name="A"/>.
            </summary>
            <param name="A">Input array</param>
            <param name="dim">New dimension order. The order of the zero-based indices of the original dimensions specify the target arrays shape.</param>
            <returns>Array with reordered dimensions.</returns>
            <remarks><paramref name="A"/> will not change. A new array is created, having 
            the dimensions rearranged in the order specified by <paramref name="dim"/>.
            <para>The length of <paramref name="dim"/> must match the number of dimensions in A: <c>A.S.NumberOfDimensions == dim.Length</c>.</para>
            <para>From version 5 <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.permute``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64})"/> is much more efficient since no elements must 
            be copied for a permutation of the dimensions.</para>
            </remarks>
            <exception cref="T:System.ArgumentException"> If the number of elements in <paramref name="A"/> and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> do not match or if any index of a dimension from <paramref name="A"/> is 
            missing in list of elements in <paramref name="dim"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.permute``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int32})">
            <summary>
            Reorder dimensions of n-dimensional array <paramref name="A"/>.
            </summary>
            <param name="A">Input array</param>
            <param name="dim">New dimension order. The order of the zero-based indices of the original dimensions specify the target arrays shape.</param>
            <returns>Array with reordered dimensions.</returns>
            <remarks><paramref name="A"/> will not change. A new array is created, having 
            the dimensions rearranged in the order specified by <paramref name="dim"/>.
            <para>The length of <paramref name="dim"/> must match the number of dimensions in A: <c>A.S.NumberOfDimensions == dim.Length</c>.</para>
            <para>From version 5 <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.permute``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int32})"/> is much more efficient since no elements must 
            be copied for a permutation of the dimensions.</para>
            </remarks>
            <exception cref="T:System.ArgumentException"> If the number of elements in <paramref name="A"/> and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> do not match or if any index of a dimension from <paramref name="A"/> is 
            missing in list of elements in <paramref name="dim"/>.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pol2cart(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})">
            <summary>
            Transforms polar/ cylindrical coordinates into scalar coordinates.
            </summary>
            <param name="theta">Angle values to x axis.</param>
            <param name="radius">Radius values from z axis.</param>
            <param name="Z">Height coordinates.</param>
            <param name="Y">[Optional] Output: If not null on entry the Y components are returned here.</param>
            <param name="outZ">[Optional] Output: If not null on entry, the Z components are returned here.</param>
            <returns>X component values. <paramref name="Y"/> and <paramref name="Z"/> are returned as output parameter if requested.</returns>
            <remarks><paramref name="theta"/>, <paramref name="radius"/> and <paramref name="Z"/> must be of 
            the same size or broadcastable to each other. Output arrays returned are of the same size then the broadcasted 
            size of the input arrays.
            <para><paramref name="outZ"/> corresponds to <paramref name="Z"/> but has been broadcasted to the output size.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pol2cart(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})">
            <summary>
            Transforms polar/ cylindrical coordinates into scalar coordinates.
            </summary>
            <param name="theta">Angle values to x axis.</param>
            <param name="radius">Radius values from z axis.</param>
            <param name="Z">Height coordinates.</param>
            <param name="Y">[Optional] Output: If not null on entry the Y components are returned here.</param>
            <param name="outZ">[Optional] Output: If not null on entry, the Z components are returned here.</param>
            <returns>X component values. <paramref name="Y"/> and <paramref name="Z"/> are returned as output parameter if requested.</returns>
            <remarks><paramref name="theta"/>, <paramref name="radius"/> and <paramref name="Z"/> must be of 
            the same size or broadcastable to each other. Output arrays returned are of the same size then the broadcasted 
            size of the input arrays.
            <para><paramref name="outZ"/> corresponds to <paramref name="Z"/> but has been broadcasted to the output size.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.poly(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})">
            <summary>
            Polynomial evaluation
            </summary>
            <param name="c">Vector of coefficients of the polynomial</param>
            <param name="x">Position where the polynomial is to be evaluated. The position may be either a scalar, a vector or a matrix.</param>
            <example>
            <code>
            <![CDATA[
             //Evaluation of the polynomial 1+x+2.1 x + x^2+3x^3 at (1,1,1)
             Array<float> y = Optimization.poly(ILMath.array<float>(1.0, 2.1, 1.0, 3.0),ILMath.ones<float>(3, 1));
            ]]>
            </code>
            </example>
            <returns>The value of a polynomial of degree d at position x, with d=c.lenght-1</returns>
            <remarks> If the input position is an array, the evaluation will be done elementwise</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.poly(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
            <summary>
            Polynomial evaluation
            </summary>
            <param name="c">Vector of coefficients of the polynomial</param>
            <param name="x">Position where the polynomial is to be evaluated. The position may be either a scalar, a vector or a matrix.</param>
            <example>
            <code>
            <![CDATA[
             //Evaluation of the polynomial 1+x+2.1 x + x^2+3x^3 at (1,1,1)
             Array<double> y = ILMath.poly(ILMath.array<double>(1.0, 2.1, 1.0, 3.0), ILMath.ones<double>(3, 1));
            ]]>
            </code>
            </example>
            <returns>The value of a polynomial of degree d at position x, with d=c.lenght-1</returns>
            <remarks> If the input position is an array, the evaluation will be done elementwise</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.real2complex(ILNumerics.InArray{System.Double})">
            <summary>
            Creates a complex array from a real array. This alias for ccomplex(A,0) is now deprecated.
            </summary>
            <param name="A">Real array A.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.real2complex(ILNumerics.InArray{System.Single})">
            <summary>
            Creates a complex array from a real array. This alias for ccomplex(A,0) is now deprecated.
            </summary>
            <param name="A">Real array A.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})">
            <summary>
            Replicates <paramref name="A"/> along the given dimensions.
            </summary>
            <param name="rep">Array specifying the repetition factors along each dimension.</param>
            <param name="A">Array to be replicated.</param>
            <returns>New storage with elements of <paramref name="A"/> repeatedly copied as specified by <paramref name="rep"/>.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="rep"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> or <paramref name="rep"/> are null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64)">
            <summary>
            Replicates <paramref name="A"/> along the given dimension.
            </summary>
            <param name="d0">Repetition factor along dimension #0.</param>
            <param name="A">Array to be replicated.</param>
            <returns>New array of the same type as <paramref name="A"/> with elements repeatedly copied as specified by <paramref name="d0"/>....</returns>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64)">
            <summary>
            Replicates <paramref name="A"/> along the given dimensions.
            </summary>
            <param name="d0">Repetition factor along dimension #0.</param>
            <param name="d1">Repetition factor along dimension #1.</param>
            <param name="A">Array to be replicated.</param>
            <returns>New array of the same type as <paramref name="A"/> with elements repeatedly copied as specified by <paramref name="d0"/>....</returns>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64)">
            <summary>
            Replicates <paramref name="A"/> along the given dimensions.
            </summary>
            <param name="d0">Repetition factor along dimension #0.</param>
            <param name="d1">Repetition factor along dimension #1.</param>
            <param name="d2">Repetition factor along dimension #2.</param>
            <param name="A">Array to be replicated.</param>
            <returns>New array of the same type as <paramref name="A"/> with elements repeatedly copied as specified by <paramref name="d0"/>....</returns>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Replicates <paramref name="A"/> along the given dimensions.
            </summary>
            <param name="d0">Repetition factor along dimension #0.</param>
            <param name="d1">Repetition factor along dimension #1.</param>
            <param name="d2">Repetition factor along dimension #2.</param>
            <param name="d3">Repetition factor along dimension #3.</param>
            <param name="A">Array to be replicated.</param>
            <returns>New array of the same type as <paramref name="A"/> with elements repeatedly copied as specified by <paramref name="d0"/>....</returns>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Replicates <paramref name="A"/> along the given dimensions.
            </summary>
            <param name="d0">Repetition factor along dimension #0.</param>
            <param name="d1">Repetition factor along dimension #1.</param>
            <param name="d2">Repetition factor along dimension #2.</param>
            <param name="d3">Repetition factor along dimension #3.</param>
            <param name="d4">Repetition factor along dimension #4.</param>
            <param name="A">Array to be replicated.</param>
            <returns>New array of the same type as <paramref name="A"/> with elements repeatedly copied as specified by <paramref name="d0"/>....</returns>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Replicates <paramref name="A"/> along the given dimensions.
            </summary>
            <param name="d0">Repetition factor along dimension #0.</param>
            <param name="d1">Repetition factor along dimension #1.</param>
            <param name="d2">Repetition factor along dimension #2.</param>
            <param name="d3">Repetition factor along dimension #3.</param>
            <param name="d4">Repetition factor along dimension #4.</param>
            <param name="d5">Repetition factor along dimension #5.</param>
            <param name="A">Array to be replicated.</param>
            <returns>New array of the same type as <paramref name="A"/> with elements repeatedly copied as specified by <paramref name="d0"/>....</returns>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Replicates <paramref name="A"/> along the given dimensions.
            </summary>
            <param name="d0">Repetition factor along dimension #0.</param>
            <param name="d1">Repetition factor along dimension #1.</param>
            <param name="d2">Repetition factor along dimension #2.</param>
            <param name="d3">Repetition factor along dimension #3.</param>
            <param name="d4">Repetition factor along dimension #4.</param>
            <param name="d5">Repetition factor along dimension #5.</param>
            <param name="d6">Repetition factor along dimension #6.</param>
            <param name="A">Array to be replicated.</param>
            <returns>New array of the same type as <paramref name="A"/> with elements repeatedly copied as specified by <paramref name="d0"/>....</returns>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> is null.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped, one dimensional version of <paramref name="A"/>. Flattens the array to a vector.
            </summary>
            <param name="A">Input array.</param>
            <param name="d0">Length of the vector produced. This must be equal to <see cref="P:ILNumerics.Size.NumberOfElements"/> or a negative number.</param>
            <param name="order">[Optional] Storage order for the new array. Default: null (<see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>).</param>
            <returns>A new array with the same values as this array, lined up in a 1-dimensional vector.</returns>
            <remarks><para>The (redundant) parameter <paramref name="d0"/> indicates the number of elements along the first 
            dimension for the returned array. If <paramref name="d0"/> is positive, its value must equal the number of
            elements in array <paramref name="A"/>. If <paramref name="d0"/> is negative, the correct number of elements is substituted automatically.</para>
            <para>The setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is taken into account. 
            Therefore - by default - the array returned will have 2 dimensions, since the default value for 
            <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is 2.</para>
            <para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array with a modified size descriptor.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped version of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="d0">Number of elements along dim 0.</param>
            <param name="d1">Number of elements along dim 1.</param>
            <param name="order">[Optional] Storage order for the output array. Default: 
            null (Settings.DefaultStorageOrder).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified as the values (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array and uses another size descriptor only.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            A reshaped version of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="d0">Number of elements along dim 0.</param>
            <param name="d1">Number of elements along dim 1.</param>
            <param name="d2">Number of elements along dim 2.</param>
            <param name="order">[Optional] Storage order for the output array. Default: 
            null (Settings.DefaultStorageOrder).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from <paramref name="A"/> and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array and uses another size descriptor only.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            A reshaped version of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="d0">Number of elements along dim #0.</param>
            <param name="d1">Number of elements along dim #1.</param>
            <param name="d2">Number of elements along dim #2.</param>
            <param name="d3">Number of elements along dim #3.</param>
            <param name="order">[Optional] Storage order for the output array. Default: 
            null (Settings.DefaultStorageOrder).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from <paramref name="A"/> and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array and uses another size descriptor only.</para>
            </remarks>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            A reshaped version of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="d0">Number of elements along dim #0.</param>
            <param name="d1">Number of elements along dim #1.</param>
            <param name="d2">Number of elements along dim #2.</param>
            <param name="d3">Number of elements along dim #3.</param>
            <param name="d4">Number of elements along dim #4.</param>
            <param name="order">[Optional] Storage order for the output array. Default: 
            null (Settings.DefaultStorageOrder).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from <paramref name="A"/> and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array and uses another size descriptor only.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            A reshaped version of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="d0">Number of elements along dim #0.</param>
            <param name="d1">Number of elements along dim #1.</param>
            <param name="d2">Number of elements along dim #2.</param>
            <param name="d3">Number of elements along dim #3.</param>
            <param name="d4">Number of elements along dim #4.</param>
            <param name="d5">Number of elements along dim #5.</param>
            <param name="order">[Optional] Storage order for the output array. Default: 
            null (Settings.DefaultStorageOrder).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from <paramref name="A"/> and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array and uses another size descriptor only.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            A reshaped version of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="d0">Number of elements along dim #0.</param>
            <param name="d1">Number of elements along dim #1.</param>
            <param name="d2">Number of elements along dim #2.</param>
            <param name="d3">Number of elements along dim #3.</param>
            <param name="d4">Number of elements along dim #4.</param>
            <param name="d5">Number of elements along dim #5.</param>
            <param name="d6">Number of elements along dim #6.</param>
            <param name="order">[Optional] Storage order for the output array. Default: 
            null (Settings.DefaultStorageOrder).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from <paramref name="A"/> and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array and uses another size descriptor only.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            A reshaped version of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="newdims">New dimension lengths.</param>
            <param name="order">[Optional] Storage order for the output array. Default: 
            null (Settings.DefaultStorageOrder).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from <paramref name="A"/> and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings. Otherwise the returned 
            array references the same memory as this array and uses another size descriptor only.</para>
            </remarks>
            <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.size">
            <summary>
            Provides empty dimension lengths for operations expecting a size argument.
            </summary>
            <remarks><para>This function is an alias for <c><![CDATA[empty<long>(0)]]></c> and returns a vector 
            of 0 <see cref="T:System.Int64"/> elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.size(System.Int64)">
            <summary>
            Provides dimension lengths for operations expecting a size argument. Targets 1 dimension.
            </summary>
            <remarks><para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0)"/> and returns a vector 
            of <see cref="T:System.Int64"/> elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.size(System.Int64,System.Int64)">
            <summary>
            Provides dimension lengths for operations expecting a size argument. Targets 2 dimensions.
            </summary>
            <remarks><para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0)"/> and returns a vector 
            of <see cref="T:System.Int64"/> elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.size(System.Int64,System.Int64,System.Int64)">
            <summary>
            Provides dimension lengths for operations expecting a size argument. Targets 3 dimensions.
            </summary>
            <remarks><para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0)"/> and returns a vector 
            of <see cref="T:System.Int64"/> elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.size(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Provides dimension lengths for operations expecting a size argument. Targets 4 dimensions.
            </summary>
            <remarks><para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0)"/> and returns a vector 
            of <see cref="T:System.Int64"/> elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.size(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Provides dimension lengths for operations expecting a size argument. Targets 5 dimensions.
            </summary>
            <remarks><para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0)"/> and returns a vector 
            of <see cref="T:System.Int64"/> elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.size(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Provides dimension lengths for operations expecting a size argument. Targets 6 dimensions.
            </summary>
            <remarks><para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0)"/> and returns a vector 
            of <see cref="T:System.Int64"/> elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.size(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Provides dimension lengths for operations expecting a size argument. Targets 7 dimensions.
            </summary>
            <remarks><para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0)"/> and returns a vector 
            of <see cref="T:System.Int64"/> elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.size(System.Int64[])">
            <summary>
            Provides dimension lengths for operations expecting a size argument. Targets more than 7 dimensions.
            </summary>
            <remarks><para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0[])"/> and returns a vector 
            of <see cref="T:System.Int64"/> elements.</para>
            <para>For situations requiring high-performance execution you may consider using <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0[])"/> 
            in order to create the required size vector once. Keep this size array around and reuse it. 
            This prevents one from allocating additional, GC managed memory from the managed heap and may helps 
            to increase the performance / to decrease GC activity. Otherwise, the 'params' (variable length argument) 
            may puts pressure on the GC when used frequently in tight loops.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sphere2cart(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})">
            <summary>
             Transforms spherical coordinates into cartesian coordinates.
            </summary>
            <param name="radius">Radial distance.</param>
            <param name="theta">Polar angle.</param>
            <param name="phi">Azimuthal angle.</param>
            <param name="Y">[Optional] Output: Y coordinates. Default: (null) do not compute.</param>
            <param name="Z">[Optional] Output: Z coordinates. Default: (null) do not compute.</param>
            <returns>X coordinates.<paramref name="Y"/> and <paramref name="Z"/> are returned on request.</returns>
            <remarks> The input parameters <paramref name="radius"/>, <paramref name="theta"/> and <paramref name="phi"/>
            must be of the same size or be broadcastable to each other. All arrays returned are of the broadcasted size.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sphere2cart(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})">
            <summary>
             Transforms spherical coordinates into cartesian coordinates.
            </summary>
            <param name="radius">Radial distance.</param>
            <param name="theta">Polar angle.</param>
            <param name="phi">Azimuthal angle.</param>
            <param name="Y">[Optional] Output: Y coordinates. Default: (null) do not compute.</param>
            <param name="Z">[Optional] Output: Z coordinates. Default: (null) do not compute.</param>
            <returns>X coordinates.<paramref name="Y"/> and <paramref name="Z"/> are returned on request.</returns>
            <remarks> The input parameters <paramref name="radius"/>, <paramref name="theta"/> and <paramref name="phi"/>
            must be of the same size or be broadcastable to each other. All arrays returned are of the broadcasted size.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.squeeze``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
            <summary>
            Creates an array similar to this array, having singleton dimensions removed.
            </summary>
            <param name="A">Input array, will not be altered.</param>
            <returns>New array without singleton dimension.</returns>
            <remarks>This function (as all functions in ILNumerics) respects the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. 
            Thus, commonly, the array returned may still has up to two singleton dimensions, if <see cref="P:ILNumerics.Settings.ArrayStyle"/> is <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>.
            <para>Note that removing singleton dimensions does not change the number of elements of the array. Hence, no copy is made 
            for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.squeeze``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>.</para></remarks>
            <seealso cref="!:reshape&lt;T&gt;(InArray&lt;T&gt;, long, long, long, long, StorageOrders?)"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})">
            <summary>
            Computes sequential (linear) indices from dimensional indices.
            </summary>
            <param name="A">The input array providing the size, strides and element type to compute the sequential indices for.</param>
            <param name="indices">Dimensional index tuples into <paramref name="A"/> as m elements of n rows. Matrix [m, n].</param>
            <returns>Vector [m] with sequential element indices into <paramref name="A"/> according to the subscript indices (rows) from <paramref name="indices"/>.</returns>
            <remarks><para>This function converts subscript indices into sequential element indices. Subscript indices specify the position of an 
            element in <paramref name="A"/> by giving the position of the element in each dimension individually. Hence, n subscript indices are 
            required to describe a single element position in <paramref name="A"/>. In contrast to that, sequential indices specify the position of an 
            element in <paramref name="A"/> by a single sequential index, where all elements are considered to be 'lined-up'. The sequential index 
            is than simply the index of the element in the line.</para>
            <para>The (virtual) lining-up of the elements in <paramref name="A"/> is performed in <i>column major order</i>. Note, 
            that the order considered by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)"/> 
            and by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})"/> 
            is not related to the actual order of the elements as they are stored in memory.</para>
            <para>If <paramref name="indices"/> has fewer columns as dimensions exist in <paramref name="A"/> indices into unspecified dimensions 
            are considered 0. The last column of <paramref name="indices"/> may contains values as indices into the <i>merged trailing</i> 
            dimensions of <paramref name="A"/>.</para>
            <para>The vector returned gives the sequential index for each element specified as a row in <paramref name="indices"/>. A sequential index  
            corresponds to the 0-based index of the element after lining-up all elements of <paramref name="A"/>, starting at element 0 and walking 
            along the array in column major order.</para>
            <para><paramref name="indices"/> can contain values addressing non-existing elements in <paramref name="A"/> (indices out-of-range). 
            These indices will produce invalid sequential indices and do not produce an error. Also, no error is generated for negative values 
            in <paramref name="indices"/>! The special meaning of latter (i.e.: counting from the end) is not considered here.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})"/>
            and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)"/>
            are equivalent operations, inverting the results of the respective other function. Combining both functions creates a roundtrip and gives 
            the original data.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> has less than 1 dimension.</exception>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> or <paramref name="indices"/> are null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.UInt32})">
            <summary>
            Computes sequential (linear) indices from dimensional indices.
            </summary>
            <param name="A">The input array providing the size, strides and element type to compute the sequential indices for.</param>
            <param name="indices">Dimensional index tuples into <paramref name="A"/> as m elements of n rows. Matrix [m, n].</param>
            <returns>Vector [m] with sequential element indices into <paramref name="A"/> according to the subscript indices (rows) from <paramref name="indices"/>.</returns>
            <remarks><para>This function converts subscript indices into sequential element indices. Subscript indices specify the position of an 
            element in <paramref name="A"/> by giving the position of the element in each dimension individually. Hence, n subscript indices are 
            required to describe a single element position in <paramref name="A"/>. In contrast to that, sequential indices specify the position of an 
            element in <paramref name="A"/> by a single sequential index, where all elements are considered to be 'lined-up'. The sequential index 
            is than simply the index of the element in the line.</para>
            <para>The (virtual) lining-up of the elements in <paramref name="A"/> is performed in <i>column major order</i>. Note, 
            that the order considered by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)"/> 
            and by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})"/> 
            is not related to the actual order of the elements as they are stored in memory.</para>
            <para>If <paramref name="indices"/> has fewer columns as dimensions exist in <paramref name="A"/> indices into unspecified dimensions 
            are considered 0. The last column of <paramref name="indices"/> may contains values as indices into the <i>merged trailing</i> 
            dimensions of <paramref name="A"/>.</para>
            <para>The vector returned gives the sequential index for each element specified as a row in <paramref name="indices"/>. A sequential index  
            corresponds to the 0-based index of the element after lining-up all elements of <paramref name="A"/>, starting at element 0 and walking 
            along the array in column major order.</para>
            <para><paramref name="indices"/> can contain values addressing non-existing elements in <paramref name="A"/> (indices out-of-range). 
            These indices will produce invalid sequential indices and do not produce an error. Also, no error is generated for negative values 
            in <paramref name="indices"/>! The special meaning of latter (i.e.: counting from the end) is not considered here.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})"/>
            and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)"/>
            are equivalent operations, inverting the results of the respective other function. Combining both functions creates a roundtrip and gives 
            the original data.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="A"/> has less than 1 dimension.</exception>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> or <paramref name="indices"/> are null.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.triu``1(ILNumerics.InArray{``0})">
            <summary>
            Extract upper triangular part of matrix <paramref name="A"/>.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="A">Input matrix, size [m x n].</param>
            <returns>Array of size [m x n], holding upper triangular part of <paramref name="A"/>.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> has more than 2 dimensions.</exception>
            <remarks><para>The diagonal elements of <paramref name="A"/> are included in the upper triangular matrix returned.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.tril``1(ILNumerics.InArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tril``1(ILNumerics.InArray{``0})">
            <summary>
            Extract lower triangular part of matrix <paramref name="A"/>.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="A">Input matrix, size [m x n].</param>
            <returns>Array of size [m x n], holding lower triangular part of <paramref name="A"/>.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="A"/> has more than 2 dimensions.</exception>
            <remarks><para>The diagonal elements of <paramref name="A"/> are not included in the lower triangular matrix returned.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.triu``1(ILNumerics.InArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
            <summary>
            Create new array with the columns of <paramref name="A"/> extended by the columns of <paramref name="B"/>.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>New array with elements of <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>The size of both arrays must match. This means that all but the first dimension (#0) must have the same lengths.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> or <paramref name="B"/> are null.</exception>
            <exception cref="T:System.ArgumentException"> if the sizes of <paramref name="A"/> and <paramref name="B"/> do not match.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
            <summary>
            Create new array with the columns of <paramref name="A"/> extended by the columns of <paramref name="B"/> and <paramref name="C"/>.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <param name="C">The third array.</param>
            <returns>New array with elements of <paramref name="A"/> and <paramref name="B"/> and <paramref name="C"/>.</returns>
            <remarks><para>The size of all arrays must match. This means that all but the first dimension (#0) must have the same lengths.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/>, <paramref name="B"/> or <paramref name="C"/> are null.</exception>
            <exception cref="T:System.ArgumentException"> if the sizes of <paramref name="A"/>, <paramref name="B"/> and/or <paramref name="C"/> do not match.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
            <summary>
            Create new array with the columns of <paramref name="A"/> extended by the columns of <paramref name="B"/> and <paramref name="C"/> and <paramref name="D"/>.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <param name="C">The third array.</param>
            <param name="D">The fourth array.</param>
            <returns>New array with elements of <paramref name="A"/> and <paramref name="B"/> and <paramref name="C"/>.</returns>
            <remarks><para>The size of all arrays must match. This means that all but the first dimension (#0) must have the same lengths.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/>, <paramref name="B"/> or <paramref name="C"/> are null.</exception>
            <exception cref="T:System.ArgumentException"> if the sizes of <paramref name="A"/>, <paramref name="B"/> and/or <paramref name="C"/> do not match.</exception>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.InArray{System.String})">
            <summary>
            Sort strings in A along first non singleton dimension, ascending order.
            </summary>
            <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
            <returns>Sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.InArray{System.String},System.Boolean)">
            <summary>
            Sort strings in A along first non singleton dimension
            </summary>
            <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
            <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
            <returns>Sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.InArray{System.String},System.Int32,System.Boolean)">
            <summary>
            Sort strings in A along dimension 'dim'
            </summary>
            <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
            <param name="dim">Dimension to sort along</param>
            <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
            <returns>Sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.InArray{System.String},ILNumerics.OutArray{System.Double},System.Int32,System.Boolean)">
             <summary>
             Sort data in A along dimension 'dim'
             </summary>
             <param name="A">Input array: empty, scalar, vector or matrix</param>
             <param name="descending">Specifies the direction of sorting</param>
             <param name="dim">Dimension to sort along</param>
             <param name="Indices">[Output] Returns permutation matrix also</param>
             <returns>Sorted array of the same size as A</returns>
             <remarks><para>The data in A will be sorted using the bucket sort algorithm. Data 
             along the dimension <paramref name="dim"/> will get sorted independently from data 
             in the next row/column.</para>
             <para>This overload also returns an array 'Indices' which will hold the indices into the original 
             elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort``3(ILNumerics.InArray{``0},ILNumerics.OutArray{``2},System.Int32,System.Boolean,ILNumerics.Core.Misc.KeyMapper{``0,``1})">
            <summary>
            Generic bucket sort algorithm in A along arbitrary dimension 
            </summary>
            <param name="A">Input array: empty, scalar, vector or matrix</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">Dimension to sort along</param>
            <param name="Indices">[Input/Output] The values in Indices will be returned in the same sorted order as the elements 
            in A. This can be used to derive a permutation matrix of the sorted indices.</param>
            <typeparam name="T">Element type of values of A</typeparam>
            <typeparam name="S">Subelement type. For element type of string this would be 'char'</typeparam>
            <typeparam name="I">Element type of indices</typeparam>
            <param name="keymapper">Instancce of an object of type ILKeyMapper. This object must 
            be derived from ILKeyMapper{T,SubelementType} and match the generic argument <typeparamref name="T"/>. It will be 
            used to split single elements into its subelements and map their content into bucket numbers. For all 
            reference types except those of type string you will have to write your own ILKeyMapper class for that purpose.</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks><para>The data in A will be sorted using the bucket sort algorithm. Data 
            along the dimension <paramref name="dim"/> will get sorted independently. I.e., for dim = 0, columns are sorted independently.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Therefore, the unsorted indices must be provided by the user on entry. Indices must not be null.</para>
            <para>This generic version is able to sort arbitrary element types. Even user defined reference types can be sorted 
            by specifying a user defined ILKeyMapper class instance. Also the type of Indices may be arbitrarily choosen. In difference 
            to the regular sort function overload, Indices must manually be given to the function on entry. Elements in 'Indices'
            are sorted in the same order as the elements of A.</para>
            <para>By using this overload you may use the same permutation matrix several times to reflect the 
            manipulations done to A due multiple sort processes. The Indices given will directly be used for the sorting 
            disregarding initial order.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{System.Double})">
            <summary>
            Tests if all elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.allallInternal(ILNumerics.BaseArray{System.Boolean})">
            <summary>
            Tests if all elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Tests if all elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{System.Int64})">
            <summary>
            Tests if all elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Tests if all elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{System.Int32})">
            <summary>
            Tests if all elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Tests if all elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{System.Int16})">
            <summary>
            Tests if all elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{System.Byte})">
            <summary>
            Tests if all elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{System.SByte})">
            <summary>
            Tests if all elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Tests if all elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Tests if all elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{System.Single})">
            <summary>
            Tests if all elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{System.Boolean})">
            <summary>
            Tests if all elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed and elements of the input array <paramref name="A"/> are not iterated if the number of Trues are known for the logical input.</para>
            <para>If elements must be iterated the operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.anyall(ILNumerics.BaseArray{System.Double})">
            <summary>Tests if any elements of <paramref name="A"/> are non-zero.</summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical array. True if a test for non-zero succeeded for any element of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The test operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.anyallInternal(ILNumerics.BaseArray{System.Boolean})">
            <summary>Tests if any elements of <paramref name="A"/> are non-zero.</summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The test operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.anyall(ILNumerics.BaseArray{System.UInt64})">
            <summary>Tests if any elements of <paramref name="A"/> are non-zero.</summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The test operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.anyall(ILNumerics.BaseArray{System.Int64})">
            <summary>Tests if any elements of <paramref name="A"/> are non-zero.</summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The test operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.anyall(ILNumerics.BaseArray{System.UInt32})">
            <summary>Tests if any elements of <paramref name="A"/> are non-zero.</summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The test operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.anyall(ILNumerics.BaseArray{System.Int32})">
            <summary>Tests if any elements of <paramref name="A"/> are non-zero.</summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The test operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.anyall(ILNumerics.BaseArray{System.UInt16})">
            <summary>Tests if any elements of <paramref name="A"/> are non-zero.</summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The test operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.anyall(ILNumerics.BaseArray{System.Int16})">
            <summary>Tests if any elements of <paramref name="A"/> are non-zero.</summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The test operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.anyall(ILNumerics.BaseArray{System.Byte})">
            <summary>Tests if any elements of <paramref name="A"/> are non-zero.</summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The test operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.anyall(ILNumerics.BaseArray{System.SByte})">
            <summary>Tests if any elements of <paramref name="A"/> are non-zero.</summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The test operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.anyall(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Tests if any elements of <paramref name="A"/> are non-zero.</summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The test operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.anyall(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Tests if any elements of <paramref name="A"/> are non-zero.</summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The test operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.anyall(ILNumerics.BaseArray{System.Single})">
            <summary>Tests if any elements of <paramref name="A"/> are non-zero.</summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The test operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.anyall(ILNumerics.BaseArray{System.Boolean})">
            <summary>
            Tests if any elements of <paramref name="A"/> are non-zero.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar logical. True if the test for non-zero succeeded for any element of <paramref name="A"/>. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed and elements of the input array <paramref name="A"/> are not iterated if the number of Trues are known for the logical input.</para>
            <para>If elements must be iterated the operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN"/>) and other special floating point values (Inf) are considered non-zero.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prodall(ILNumerics.BaseArray{System.Double})">
            <summary>Computes the product of all elements of <paramref name="A"/>.</summary>
            <param name="A">Input array.</param>
            <returns>Scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prodall(ILNumerics.BaseArray{System.UInt64})">
            <summary>Computes the product of all elements of <paramref name="A"/>.</summary>
            <param name="A">Input array.</param>
            <returns>Scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prodall(ILNumerics.BaseArray{System.Int64})">
            <summary>Computes the product of all elements of <paramref name="A"/>.</summary>
            <param name="A">Input array.</param>
            <returns>Scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prodall(ILNumerics.BaseArray{System.UInt32})">
            <summary>Computes the product of all elements of <paramref name="A"/>.</summary>
            <param name="A">Input array.</param>
            <returns>Scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prodall(ILNumerics.BaseArray{System.Int32})">
            <summary>Computes the product of all elements of <paramref name="A"/>.</summary>
            <param name="A">Input array.</param>
            <returns>Scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prodall(ILNumerics.BaseArray{System.UInt16})">
            <summary>Computes the product of all elements of <paramref name="A"/>.</summary>
            <param name="A">Input array.</param>
            <returns>Scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prodall(ILNumerics.BaseArray{System.Int16})">
            <summary>Computes the product of all elements of <paramref name="A"/>.</summary>
            <param name="A">Input array.</param>
            <returns>Scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prodall(ILNumerics.BaseArray{System.Byte})">
            <summary>Computes the product of all elements of <paramref name="A"/>.</summary>
            <param name="A">Input array.</param>
            <returns>Scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prodall(ILNumerics.BaseArray{System.SByte})">
            <summary>Computes the product of all elements of <paramref name="A"/>.</summary>
            <param name="A">Input array.</param>
            <returns>Scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prodall(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Computes the product of all elements of <paramref name="A"/>.</summary>
            <param name="A">Input array.</param>
            <returns>Scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prodall(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Computes the product of all elements of <paramref name="A"/>.</summary>
            <param name="A">Input array.</param>
            <returns>Scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prodall(ILNumerics.BaseArray{System.Single})">
            <summary>Computes the product of all elements of <paramref name="A"/>.</summary>
            <param name="A">Input array.</param>
            <returns>Scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sumall(ILNumerics.BaseArray{System.Double})">
            <summary>
            Computes the sum of all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar array with the sum of all elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sumall(ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Computes the sum of all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar array with the sum of all elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sumall(ILNumerics.BaseArray{System.Int64})">
            <summary>
            Computes the sum of all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar array with the sum of all elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sumall(ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Computes the sum of all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar array with the sum of all elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sumall(ILNumerics.BaseArray{System.Int32})">
            <summary>
            Computes the sum of all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar array with the sum of all elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sumall(ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Computes the sum of all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar array with the sum of all elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sumall(ILNumerics.BaseArray{System.Int16})">
            <summary>
            Computes the sum of all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar array with the sum of all elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sumall(ILNumerics.BaseArray{System.Byte})">
            <summary>
            Computes the sum of all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar array with the sum of all elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sumall(ILNumerics.BaseArray{System.SByte})">
            <summary>
            Computes the sum of all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar array with the sum of all elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sumall(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Computes the sum of all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar array with the sum of all elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sumall(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Computes the sum of all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar array with the sum of all elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sumall(ILNumerics.BaseArray{System.Single})">
            <summary>
            Computes the sum of all elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar array with the sum of all elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>This operation returns a scalar array, regardless of the shape of <paramref name="A"/>. The number of dimensions 
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. If <paramref name="A"/> 
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the 
            default value is 0. For boolean / logical elements the default is false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.all(ILNumerics.BaseArray{System.Boolean},System.Int32,System.Boolean)">
            <summary>Determines whether all elements of <paramref name="A"/> along the given dimension <paramref name="dim"/> are true.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.all(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
            <summary>Determines whether all elements of <paramref name="A"/> along the given dimension <paramref name="dim"/> are 'not zero'.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.all(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean)">
            <summary>Determines whether all elements of <paramref name="A"/> along the given dimension <paramref name="dim"/> are 'not zero'.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.all(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)">
            <summary>Determines whether all elements of <paramref name="A"/> along the given dimension <paramref name="dim"/> are 'not zero'.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.all(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Determines whether all elements of <paramref name="A"/> along the given dimension <paramref name="dim"/> are 'not zero'.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.all(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean)">
            <summary>Determines whether all elements of <paramref name="A"/> along the given dimension <paramref name="dim"/> are 'not zero'.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.all(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean)">
            <summary>Determines whether all elements of <paramref name="A"/> along the given dimension <paramref name="dim"/> are 'not zero'.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.all(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean)">
            <summary>Determines whether all elements of <paramref name="A"/> along the given dimension <paramref name="dim"/> are 'not zero'.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.all(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean)">
            <summary>Determines whether all elements of <paramref name="A"/> along the given dimension <paramref name="dim"/> are 'not zero'.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.all(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean)">
            <summary>Determines whether all elements of <paramref name="A"/> along the given dimension <paramref name="dim"/> are 'not zero'.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.all(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean)">
            <summary>Determines whether all elements of <paramref name="A"/> along the given dimension <paramref name="dim"/> are 'not zero'.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.all(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean)">
            <summary>Determines whether all elements of <paramref name="A"/> along the given dimension <paramref name="dim"/> are 'not zero'.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.all(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean)">
            <summary>Determines whether all elements of <paramref name="A"/> along the given dimension <paramref name="dim"/> are 'not zero'.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.any(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean)">
            <summary>Determines whether any element of <paramref name="A"/> along the given dimension <paramref name="dim"/> is not zero.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.any(ILNumerics.BaseArray{System.Boolean},System.Int32,System.Boolean)">
            <summary>Determines whether any element of <paramref name="A"/> along the given dimension <paramref name="dim"/> is true.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.any(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
            <summary>Determines whether any element of <paramref name="A"/> along the given dimension <paramref name="dim"/> is not zero.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.any(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean)">
            <summary>Determines whether any element of <paramref name="A"/> along the given dimension <paramref name="dim"/> is not zero.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.any(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)">
            <summary>Determines whether any element of <paramref name="A"/> along the given dimension <paramref name="dim"/> is not zero.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.any(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Determines whether any element of <paramref name="A"/> along the given dimension <paramref name="dim"/> is not zero.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.any(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean)">
            <summary>Determines whether any element of <paramref name="A"/> along the given dimension <paramref name="dim"/> is not zero.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.any(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean)">
            <summary>Determines whether any element of <paramref name="A"/> along the given dimension <paramref name="dim"/> is not zero.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.any(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean)">
            <summary>Determines whether any element of <paramref name="A"/> along the given dimension <paramref name="dim"/> is not zero.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.any(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean)">
            <summary>Determines whether any element of <paramref name="A"/> along the given dimension <paramref name="dim"/> is not zero.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.any(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean)">
            <summary>Determines whether any element of <paramref name="A"/> along the given dimension <paramref name="dim"/> is not zero.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.any(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean)">
            <summary>Determines whether any element of <paramref name="A"/> along the given dimension <paramref name="dim"/> is not zero.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.any(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean)">
            <summary>Determines whether any element of <paramref name="A"/> along the given dimension <paramref name="dim"/> is not zero.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length 1.</returns>
            <remarks><para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.PositiveInfinity"/>, etc.; being 'not zero') 
            evaluate to 'true'.</para>
            <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> or 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> dimension <paramref name="dim"/> may be of length 0, which leads to a 
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
            <para>The default value for <paramref name="dim"/> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically. 
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension"/> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. 
            For <see cref="P:ILNumerics.Settings.ArrayStyle"/> <see cref="F:ILNumerics.ArrayStyles.numpy"/>, however, the search starts with the last dimension and works its way up to the first dimension. 
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
            </remarks>
            <see cref="M:ILNumerics.Size.WorkingDimension"/>
            <see cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumprod(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)">
            <summary>Computes the product of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumprod(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)">
            <summary>Computes the product of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumprod(ILNumerics.BaseArray{System.Single},System.Int32)">
            <summary>Computes the product of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumprod(ILNumerics.BaseArray{System.Int64},System.Int32)">
            <summary>Computes the product of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumprod(ILNumerics.BaseArray{System.UInt64},System.Int32)">
            <summary>Computes the product of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumprod(ILNumerics.BaseArray{System.Int32},System.Int32)">
            <summary>Computes the product of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumprod(ILNumerics.BaseArray{System.UInt32},System.Int32)">
            <summary>Computes the product of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumprod(ILNumerics.BaseArray{System.Int16},System.Int32)">
            <summary>Computes the product of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumprod(ILNumerics.BaseArray{System.UInt16},System.Int32)">
            <summary>Computes the product of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumprod(ILNumerics.BaseArray{System.SByte},System.Int32)">
            <summary>Computes the product of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumprod(ILNumerics.BaseArray{System.Byte},System.Int32)">
            <summary>Computes the product of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumprod(ILNumerics.BaseArray{System.Double},System.Int32)">
            <summary>Computes the product of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumsum(ILNumerics.BaseArray{System.Double},System.Int32)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumsum(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumsum(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumsum(ILNumerics.BaseArray{System.Single},System.Int32)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumsum(ILNumerics.BaseArray{System.Int64},System.Int32)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumsum(ILNumerics.BaseArray{System.UInt64},System.Int32)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumsum(ILNumerics.BaseArray{System.Int32},System.Int32)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumsum(ILNumerics.BaseArray{System.UInt32},System.Int32)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumsum(ILNumerics.BaseArray{System.Int16},System.Int32)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumsum(ILNumerics.BaseArray{System.UInt16},System.Int32)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumsum(ILNumerics.BaseArray{System.SByte},System.Int32)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cumsum(ILNumerics.BaseArray{System.Byte},System.Int32)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.diff(ILNumerics.BaseArray{System.Double},System.UInt32,System.Int32)">
            <summary>
            Computes the differences between successive elements of <paramref name="A"/> along the specified dimension <paramref name="dim"/> or the n-th derivative.
            </summary>
            <param name="A">Input array.</param>
            <param name="N">[Optional] Order of difference. Default: 1.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A"/> or 0, if no such dimension exists.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced by 1 element.</returns>
            <remarks><para>If the length of the <paramref name="dim"/>s dimension in <paramref name="A"/> is lower than 2, an empty 
            array is returned, having the size of <paramref name="A"/> but the <paramref name="dim"/>s dimension reduced to max(A.S[dim]-1,0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.diff(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32,System.Int32)">
            <summary>
            Computes the differences between successive elements of <paramref name="A"/> along the specified dimension <paramref name="dim"/> or the n-th derivative.
            </summary>
            <param name="A">Input array.</param>
            <param name="N">[Optional] Order of difference. Default: 1.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A"/> or 0, if no such dimension exists.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced by 1 element.</returns>
            <remarks><para>If the length of the <paramref name="dim"/>s dimension in <paramref name="A"/> is lower than 2, an empty 
            array is returned, having the size of <paramref name="A"/> but the <paramref name="dim"/>s dimension reduced to max(A.S[dim]-1,0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.diff(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32,System.Int32)">
            <summary>
            Computes the differences between successive elements of <paramref name="A"/> along the specified dimension <paramref name="dim"/> or the n-th derivative.
            </summary>
            <param name="A">Input array.</param>
            <param name="N">[Optional] Order of difference. Default: 1.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A"/> or 0, if no such dimension exists.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced by 1 element.</returns>
            <remarks><para>If the length of the <paramref name="dim"/>s dimension in <paramref name="A"/> is lower than 2, an empty 
            array is returned, having the size of <paramref name="A"/> but the <paramref name="dim"/>s dimension reduced to max(A.S[dim]-1,0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.diff(ILNumerics.BaseArray{System.Single},System.UInt32,System.Int32)">
            <summary>
            Computes the differences between successive elements of <paramref name="A"/> along the specified dimension <paramref name="dim"/> or the n-th derivative.
            </summary>
            <param name="A">Input array.</param>
            <param name="N">[Optional] Order of difference. Default: 1.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A"/> or 0, if no such dimension exists.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced by 1 element.</returns>
            <remarks><para>If the length of the <paramref name="dim"/>s dimension in <paramref name="A"/> is lower than 2, an empty 
            array is returned, having the size of <paramref name="A"/> but the <paramref name="dim"/>s dimension reduced to max(A.S[dim]-1,0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.diff(ILNumerics.BaseArray{System.Int64},System.UInt32,System.Int32)">
            <summary>
            Computes the differences between successive elements of <paramref name="A"/> along the specified dimension <paramref name="dim"/> or the n-th derivative.
            </summary>
            <param name="A">Input array.</param>
            <param name="N">[Optional] Order of difference. Default: 1.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A"/> or 0, if no such dimension exists.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced by 1 element.</returns>
            <remarks><para>If the length of the <paramref name="dim"/>s dimension in <paramref name="A"/> is lower than 2, an empty 
            array is returned, having the size of <paramref name="A"/> but the <paramref name="dim"/>s dimension reduced to max(A.S[dim]-1,0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.diff(ILNumerics.BaseArray{System.UInt64},System.UInt32,System.Int32)">
            <summary>
            Computes the differences between successive elements of <paramref name="A"/> along the specified dimension <paramref name="dim"/> or the n-th derivative.
            </summary>
            <param name="A">Input array.</param>
            <param name="N">[Optional] Order of difference. Default: 1.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A"/> or 0, if no such dimension exists.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced by 1 element.</returns>
            <remarks><para>If the length of the <paramref name="dim"/>s dimension in <paramref name="A"/> is lower than 2, an empty 
            array is returned, having the size of <paramref name="A"/> but the <paramref name="dim"/>s dimension reduced to max(A.S[dim]-1,0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.diff(ILNumerics.BaseArray{System.Int32},System.UInt32,System.Int32)">
            <summary>
            Computes the differences between successive elements of <paramref name="A"/> along the specified dimension <paramref name="dim"/> or the n-th derivative.
            </summary>
            <param name="A">Input array.</param>
            <param name="N">[Optional] Order of difference. Default: 1.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A"/> or 0, if no such dimension exists.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced by 1 element.</returns>
            <remarks><para>If the length of the <paramref name="dim"/>s dimension in <paramref name="A"/> is lower than 2, an empty 
            array is returned, having the size of <paramref name="A"/> but the <paramref name="dim"/>s dimension reduced to max(A.S[dim]-1,0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.diff(ILNumerics.BaseArray{System.UInt32},System.UInt32,System.Int32)">
            <summary>
            Computes the differences between successive elements of <paramref name="A"/> along the specified dimension <paramref name="dim"/> or the n-th derivative.
            </summary>
            <param name="A">Input array.</param>
            <param name="N">[Optional] Order of difference. Default: 1.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A"/> or 0, if no such dimension exists.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced by 1 element.</returns>
            <remarks><para>If the length of the <paramref name="dim"/>s dimension in <paramref name="A"/> is lower than 2, an empty 
            array is returned, having the size of <paramref name="A"/> but the <paramref name="dim"/>s dimension reduced to max(A.S[dim]-1,0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.diff(ILNumerics.BaseArray{System.Int16},System.UInt32,System.Int32)">
            <summary>
            Computes the differences between successive elements of <paramref name="A"/> along the specified dimension <paramref name="dim"/> or the n-th derivative.
            </summary>
            <param name="A">Input array.</param>
            <param name="N">[Optional] Order of difference. Default: 1.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A"/> or 0, if no such dimension exists.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced by 1 element.</returns>
            <remarks><para>If the length of the <paramref name="dim"/>s dimension in <paramref name="A"/> is lower than 2, an empty 
            array is returned, having the size of <paramref name="A"/> but the <paramref name="dim"/>s dimension reduced to max(A.S[dim]-1,0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.diff(ILNumerics.BaseArray{System.UInt16},System.UInt32,System.Int32)">
            <summary>
            Computes the differences between successive elements of <paramref name="A"/> along the specified dimension <paramref name="dim"/> or the n-th derivative.
            </summary>
            <param name="A">Input array.</param>
            <param name="N">[Optional] Order of difference. Default: 1.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A"/> or 0, if no such dimension exists.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced by 1 element.</returns>
            <remarks><para>If the length of the <paramref name="dim"/>s dimension in <paramref name="A"/> is lower than 2, an empty 
            array is returned, having the size of <paramref name="A"/> but the <paramref name="dim"/>s dimension reduced to max(A.S[dim]-1,0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.diff(ILNumerics.BaseArray{System.SByte},System.UInt32,System.Int32)">
            <summary>
            Computes the differences between successive elements of <paramref name="A"/> along the specified dimension <paramref name="dim"/> or the n-th derivative.
            </summary>
            <param name="A">Input array.</param>
            <param name="N">[Optional] Order of difference. Default: 1.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A"/> or 0, if no such dimension exists.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced by 1 element.</returns>
            <remarks><para>If the length of the <paramref name="dim"/>s dimension in <paramref name="A"/> is lower than 2, an empty 
            array is returned, having the size of <paramref name="A"/> but the <paramref name="dim"/>s dimension reduced to max(A.S[dim]-1,0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.diff(ILNumerics.BaseArray{System.Byte},System.UInt32,System.Int32)">
            <summary>
            Computes the differences between successive elements of <paramref name="A"/> along the specified dimension <paramref name="dim"/> or the n-th derivative.
            </summary>
            <param name="A">Input array.</param>
            <param name="N">[Optional] Order of difference. Default: 1.</param>
            <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A"/> or 0, if no such dimension exists.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced by 1 element.</returns>
            <remarks><para>If the length of the <paramref name="dim"/>s dimension in <paramref name="A"/> is lower than 2, an empty 
            array is returned, having the size of <paramref name="A"/> but the <paramref name="dim"/>s dimension reduced to max(A.S[dim]-1,0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Double},System.Int32)">
            <summary>
            Flips elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para>
            <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex"/> and logical arrays.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Double})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Double})">
            <summary>
            Flips the order of the rows of matrix <paramref name="A"/>, i.e.: works along dimension #0.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the rows flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Double},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Double},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Double})">
            <summary>
            Flips the order of the columns of matrix <paramref name="A"/>, i.e.: works along dimension #1.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the columns flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Double},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Double},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Boolean},System.Int32)">
            <summary>
            Flips elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para>
            <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex"/> and logical arrays.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Byte})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Byte})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Boolean})">
            <summary>
            Flips the order of the rows of matrix <paramref name="A"/>, i.e.: works along dimension #0.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the rows flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Byte})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Boolean})">
            <summary>
            Flips the order of the columns of matrix <paramref name="A"/>, i.e.: works along dimension #1.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the columns flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Byte})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Flips elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para>
            <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex"/> and logical arrays.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{ILNumerics.fcomplex})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{ILNumerics.fcomplex})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Flips the order of the rows of matrix <paramref name="A"/>, i.e.: works along dimension #0.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the rows flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{ILNumerics.fcomplex})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Flips the order of the columns of matrix <paramref name="A"/>, i.e.: works along dimension #1.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the columns flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{ILNumerics.fcomplex})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)">
            <summary>
            Flips elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para>
            <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex"/> and logical arrays.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{ILNumerics.complex})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Flips the order of the rows of matrix <paramref name="A"/>, i.e.: works along dimension #0.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the rows flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{ILNumerics.complex})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Flips the order of the columns of matrix <paramref name="A"/>, i.e.: works along dimension #1.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the columns flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{ILNumerics.complex})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Single},System.Int32)">
            <summary>
            Flips elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para>
            <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex"/> and logical arrays.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Single})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Single})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Single})">
            <summary>
            Flips the order of the rows of matrix <paramref name="A"/>, i.e.: works along dimension #0.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the rows flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Single},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Single},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Single})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Single})">
            <summary>
            Flips the order of the columns of matrix <paramref name="A"/>, i.e.: works along dimension #1.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the columns flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Single},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Single},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Single})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int64},System.Int32)">
            <summary>
            Flips elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para>
            <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex"/> and logical arrays.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int64})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int64})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int64})">
            <summary>
            Flips the order of the rows of matrix <paramref name="A"/>, i.e.: works along dimension #0.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the rows flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int64},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int64},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int64})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int64})">
            <summary>
            Flips the order of the columns of matrix <paramref name="A"/>, i.e.: works along dimension #1.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the columns flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int64},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int64},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int64})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt64},System.Int32)">
            <summary>
            Flips elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para>
            <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex"/> and logical arrays.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt64})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt64})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Flips the order of the rows of matrix <paramref name="A"/>, i.e.: works along dimension #0.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the rows flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt64},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt64},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt64})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Flips the order of the columns of matrix <paramref name="A"/>, i.e.: works along dimension #1.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the columns flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt64},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt64},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt64})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int32},System.Int32)">
            <summary>
            Flips elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para>
            <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex"/> and logical arrays.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int32})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int32})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int32})">
            <summary>
            Flips the order of the rows of matrix <paramref name="A"/>, i.e.: works along dimension #0.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the rows flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int32},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int32},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int32})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int32})">
            <summary>
            Flips the order of the columns of matrix <paramref name="A"/>, i.e.: works along dimension #1.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the columns flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int32},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int32},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int32})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt32},System.Int32)">
            <summary>
            Flips elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para>
            <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex"/> and logical arrays.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt32})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt32})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Flips the order of the rows of matrix <paramref name="A"/>, i.e.: works along dimension #0.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the rows flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt32},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt32},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt32})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Flips the order of the columns of matrix <paramref name="A"/>, i.e.: works along dimension #1.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the columns flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt32},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt32},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt32})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int16},System.Int32)">
            <summary>
            Flips elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para>
            <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex"/> and logical arrays.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int16})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int16})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int16})">
            <summary>
            Flips the order of the rows of matrix <paramref name="A"/>, i.e.: works along dimension #0.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the rows flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int16},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int16},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int16})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int16})">
            <summary>
            Flips the order of the columns of matrix <paramref name="A"/>, i.e.: works along dimension #1.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the columns flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int16},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int16},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int16})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt16},System.Int32)">
            <summary>
            Flips elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para>
            <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex"/> and logical arrays.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt16})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt16})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Flips the order of the rows of matrix <paramref name="A"/>, i.e.: works along dimension #0.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the rows flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt16},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt16},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt16})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Flips the order of the columns of matrix <paramref name="A"/>, i.e.: works along dimension #1.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the columns flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt16},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt16},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt16})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.SByte},System.Int32)">
            <summary>
            Flips elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para>
            <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex"/> and logical arrays.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.SByte})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.SByte})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.SByte})">
            <summary>
            Flips the order of the rows of matrix <paramref name="A"/>, i.e.: works along dimension #0.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the rows flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.SByte},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.SByte},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.SByte})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.SByte})">
            <summary>
            Flips the order of the columns of matrix <paramref name="A"/>, i.e.: works along dimension #1.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the columns flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.SByte},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.SByte},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.SByte})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)">
            <summary>
            Flips elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para>
            <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex"/> and logical arrays.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Byte})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Byte})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Byte})">
            <summary>
            Flips the order of the rows of matrix <paramref name="A"/>, i.e.: works along dimension #0.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the rows flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Byte})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Byte})">
            <summary>
            Flips the order of the columns of matrix <paramref name="A"/>, i.e.: works along dimension #1.
            </summary>
            <param name="A">Input matrix.</param>
            <returns>Array of the same size and type as <paramref name="A"/> having the columns flipped.</returns>
            <remarks>
            <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)"/> with a <c>dim</c> argument of 0.</para>
            <para>This function may works inplace and may returns the same instance of <paramref name="A"/>.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Byte})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Computes the minimum of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Computes the minimum of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Computes the minimum of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Computes the minimum of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Computes the minimum of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Computes the minimum of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Computes the minimum of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Computes the minimum of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Computes the minimum of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Computes the minimum of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Computes the minimum of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Computes the minimum of elements of <paramref name="A"/> along the specified dimension.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
            <summary>Computes the product of elements of <paramref name="A"/> along specific dimension <paramref name="dim"/>.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean)">
            <summary>Computes the product of elements of <paramref name="A"/> along specific dimension <paramref name="dim"/>.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)">
            <summary>Computes the product of elements of <paramref name="A"/> along specific dimension <paramref name="dim"/>.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean)">
            <summary>Computes the product of elements of <paramref name="A"/> along specific dimension <paramref name="dim"/>.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean)">
            <summary>Computes the product of elements of <paramref name="A"/> along specific dimension <paramref name="dim"/>.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean)">
            <summary>Computes the product of elements of <paramref name="A"/> along specific dimension <paramref name="dim"/>.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean)">
            <summary>Computes the product of elements of <paramref name="A"/> along specific dimension <paramref name="dim"/>.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean)">
            <summary>Computes the product of elements of <paramref name="A"/> along specific dimension <paramref name="dim"/>.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean)">
            <summary>Computes the product of elements of <paramref name="A"/> along specific dimension <paramref name="dim"/>.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean)">
            <summary>Computes the product of elements of <paramref name="A"/> along specific dimension <paramref name="dim"/>.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean)">
            <summary>Computes the product of elements of <paramref name="A"/> along specific dimension <paramref name="dim"/>.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean)">
            <summary>Computes the product of elements of <paramref name="A"/> along specific dimension <paramref name="dim"/>.</summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            </summary>
            <param name="A">Input array.</param>
            <param name="Indices">[Output, optional] On return contains the indices required to sort the array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A" />.</returns>
            <remarks><para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para><para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is not null and not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para><para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            </summary>
            <param name="A">Input array.</param>
            <param name="Indices">[Output, optional] On return contains the indices required to sort the array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A" />.</returns>
            <remarks><para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para><para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is not null and not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para><para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            </summary>
            <param name="A">Input array.</param>
            <param name="Indices">[Output, optional] On return contains the indices required to sort the array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A" />.</returns>
            <remarks><para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para><para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is not null and not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para><para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            </summary>
            <param name="A">Input array.</param>
            <param name="Indices">[Output, optional] On return contains the indices required to sort the array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A" />.</returns>
            <remarks><para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para><para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is not null and not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para><para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            </summary>
            <param name="A">Input array.</param>
            <param name="Indices">[Output, optional] On return contains the indices required to sort the array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A" />.</returns>
            <remarks><para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para><para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is not null and not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para><para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            </summary>
            <param name="A">Input array.</param>
            <param name="Indices">[Output, optional] On return contains the indices required to sort the array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A" />.</returns>
            <remarks><para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para><para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is not null and not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para><para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            </summary>
            <param name="A">Input array.</param>
            <param name="Indices">[Output, optional] On return contains the indices required to sort the array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A" />.</returns>
            <remarks><para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para><para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is not null and not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para><para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            </summary>
            <param name="A">Input array.</param>
            <param name="Indices">[Output, optional] On return contains the indices required to sort the array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A" />.</returns>
            <remarks><para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para><para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is not null and not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para><para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            </summary>
            <param name="A">Input array.</param>
            <param name="Indices">[Output, optional] On return contains the indices required to sort the array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A" />.</returns>
            <remarks><para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para><para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is not null and not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para><para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            </summary>
            <param name="A">Input array.</param>
            <param name="Indices">[Output, optional] On return contains the indices required to sort the array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A" />.</returns>
            <remarks><para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para><para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is not null and not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para><para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            </summary>
            <param name="A">Input array.</param>
            <param name="Indices">[Output, optional] On return contains the indices required to sort the array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A" />.</returns>
            <remarks><para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para><para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is not null and not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para><para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The working dimension for <paramref name="dim"/> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. 
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts 
            with the first dimension (index #0).</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            </summary>
            <param name="A">Input array.</param>
            <param name="Indices">[Output, optional] On return contains the indices required to sort the array.</param>
            <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
            <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
            <returns>New array with the same shape as <paramref name="A" />.</returns>
            <remarks><para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para><para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is not null and not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para><para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean)">
            <summary>
            Compute the sum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A"/> or 0.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para></para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Binary, elementwise, broadcasting operation: Add.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add_sat(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>Binary broadcasting operation: Add, saturating.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add_sat(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>Binary broadcasting operation: Add, saturating.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add_sat(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>Binary broadcasting operation: Add, saturating.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add_sat(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>Binary broadcasting operation: Add, saturating.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add_sat(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>Binary broadcasting operation: Add, saturating.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add_sat(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>Binary broadcasting operation: Add, saturating.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add_sat(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>Binary broadcasting operation: Add, saturating.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add_sat(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>Binary broadcasting operation: Add, saturating.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>Binary broadcasting operation: Add.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>Binary broadcasting operation: Add.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>Binary broadcasting operation: Add.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>Binary broadcasting operation: Add.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>Binary broadcasting operation: Add.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>Binary broadcasting operation: Add.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>Binary broadcasting operation: Add.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>Binary broadcasting operation: Add.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Binary broadcasting operation: Add.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Binary broadcasting operation: Add.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.add(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>Binary broadcasting operation: Add.</summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.xor(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.xor(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.xor(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.xor(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.xor(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.xor(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.xor(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.xor(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.xor(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.xor(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.xor(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.xor(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.xor(ILNumerics.BaseArray{System.Boolean},ILNumerics.BaseArray{System.Boolean})">
            <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.or(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Elementwise 'Or' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.or(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Elementwise 'Or' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.or(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Elementwise 'Or' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.or(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Elementwise 'Or' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.or(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Elementwise 'Or' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.or(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Elementwise 'Or' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.or(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Elementwise 'Or' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.or(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Elementwise 'Or' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.or(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Elementwise 'Or' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.or(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Elementwise 'Or' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.or(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Elementwise 'Or' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.or(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Elementwise 'Or' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.or(ILNumerics.BaseArray{System.Boolean},ILNumerics.BaseArray{System.Boolean})">
            <summary>
            Elementwise 'Or' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.and(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Elementwise 'And' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.and(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Elementwise 'And' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.and(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Elementwise 'And' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.and(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Elementwise 'And' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.and(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Elementwise 'And' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.and(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Elementwise 'And' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.and(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Elementwise 'And' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.and(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Elementwise 'And' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.and(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Elementwise 'And' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.and(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Elementwise 'And' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.and(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Elementwise 'And' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.and(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Elementwise 'And' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.and(ILNumerics.BaseArray{System.Boolean},ILNumerics.BaseArray{System.Boolean})">
            <summary>
            Elementwise 'And' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double},System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double},System.Func{System.Double,System.Double,System.Double})"/> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements 
            of <paramref name="A"/> and <paramref name="B"/> by evaluating <paramref name="func"/> for each element of the resulting array.</para>
            <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double},System.Func{System.Double,System.Double,System.Double})"/> perform fastest where 
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
            <para>The function is efficiently parallelized and <paramref name="func"/> is evaluated from multiple threads. Make sure that <paramref name="func"/>
            is threadsafe!</para>
            <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A"/>, <paramref name="B"/> 
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64})"/> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements 
            of <paramref name="A"/> and <paramref name="B"/> by evaluating <paramref name="func"/> for each element of the resulting array.</para>
            <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64})"/> perform fastest where 
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
            <para>The function is efficiently parallelized and <paramref name="func"/> is evaluated from multiple threads. Make sure that <paramref name="func"/>
            is threadsafe!</para>
            <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A"/>, <paramref name="B"/> 
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64},System.Func{System.Int64,System.Int64,System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64},System.Func{System.Int64,System.Int64,System.Int64})"/> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements 
            of <paramref name="A"/> and <paramref name="B"/> by evaluating <paramref name="func"/> for each element of the resulting array.</para>
            <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64},System.Func{System.Int64,System.Int64,System.Int64})"/> perform fastest where 
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
            <para>The function is efficiently parallelized and <paramref name="func"/> is evaluated from multiple threads. Make sure that <paramref name="func"/>
            is threadsafe!</para>
            <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A"/>, <paramref name="B"/> 
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32})"/> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements 
            of <paramref name="A"/> and <paramref name="B"/> by evaluating <paramref name="func"/> for each element of the resulting array.</para>
            <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32})"/> perform fastest where 
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
            <para>The function is efficiently parallelized and <paramref name="func"/> is evaluated from multiple threads. Make sure that <paramref name="func"/>
            is threadsafe!</para>
            <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A"/>, <paramref name="B"/> 
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32},System.Func{System.Int32,System.Int32,System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32},System.Func{System.Int32,System.Int32,System.Int32})"/> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements 
            of <paramref name="A"/> and <paramref name="B"/> by evaluating <paramref name="func"/> for each element of the resulting array.</para>
            <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32},System.Func{System.Int32,System.Int32,System.Int32})"/> perform fastest where 
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
            <para>The function is efficiently parallelized and <paramref name="func"/> is evaluated from multiple threads. Make sure that <paramref name="func"/>
            is threadsafe!</para>
            <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A"/>, <paramref name="B"/> 
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16},System.Func{System.UInt16,System.UInt16,System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16},System.Func{System.UInt16,System.UInt16,System.UInt16})"/> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements 
            of <paramref name="A"/> and <paramref name="B"/> by evaluating <paramref name="func"/> for each element of the resulting array.</para>
            <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16},System.Func{System.UInt16,System.UInt16,System.UInt16})"/> perform fastest where 
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
            <para>The function is efficiently parallelized and <paramref name="func"/> is evaluated from multiple threads. Make sure that <paramref name="func"/>
            is threadsafe!</para>
            <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A"/>, <paramref name="B"/> 
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16},System.Func{System.Int16,System.Int16,System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16},System.Func{System.Int16,System.Int16,System.Int16})"/> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements 
            of <paramref name="A"/> and <paramref name="B"/> by evaluating <paramref name="func"/> for each element of the resulting array.</para>
            <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16},System.Func{System.Int16,System.Int16,System.Int16})"/> perform fastest where 
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
            <para>The function is efficiently parallelized and <paramref name="func"/> is evaluated from multiple threads. Make sure that <paramref name="func"/>
            is threadsafe!</para>
            <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A"/>, <paramref name="B"/> 
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte},System.Func{System.Byte,System.Byte,System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte},System.Func{System.Byte,System.Byte,System.Byte})"/> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements 
            of <paramref name="A"/> and <paramref name="B"/> by evaluating <paramref name="func"/> for each element of the resulting array.</para>
            <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte},System.Func{System.Byte,System.Byte,System.Byte})"/> perform fastest where 
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
            <para>The function is efficiently parallelized and <paramref name="func"/> is evaluated from multiple threads. Make sure that <paramref name="func"/>
            is threadsafe!</para>
            <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A"/>, <paramref name="B"/> 
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte},System.Func{System.SByte,System.SByte,System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte},System.Func{System.SByte,System.SByte,System.SByte})"/> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements 
            of <paramref name="A"/> and <paramref name="B"/> by evaluating <paramref name="func"/> for each element of the resulting array.</para>
            <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte},System.Func{System.SByte,System.SByte,System.SByte})"/> perform fastest where 
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
            <para>The function is efficiently parallelized and <paramref name="func"/> is evaluated from multiple threads. Make sure that <paramref name="func"/>
            is threadsafe!</para>
            <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A"/>, <paramref name="B"/> 
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex},System.Func{ILNumerics.fcomplex,ILNumerics.fcomplex,ILNumerics.fcomplex})">
            <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex},System.Func{ILNumerics.fcomplex,ILNumerics.fcomplex,ILNumerics.fcomplex})"/> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements 
            of <paramref name="A"/> and <paramref name="B"/> by evaluating <paramref name="func"/> for each element of the resulting array.</para>
            <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex},System.Func{ILNumerics.fcomplex,ILNumerics.fcomplex,ILNumerics.fcomplex})"/> perform fastest where 
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
            <para>The function is efficiently parallelized and <paramref name="func"/> is evaluated from multiple threads. Make sure that <paramref name="func"/>
            is threadsafe!</para>
            <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A"/>, <paramref name="B"/> 
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex},System.Func{ILNumerics.complex,ILNumerics.complex,ILNumerics.complex})">
            <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex},System.Func{ILNumerics.complex,ILNumerics.complex,ILNumerics.complex})"/> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements 
            of <paramref name="A"/> and <paramref name="B"/> by evaluating <paramref name="func"/> for each element of the resulting array.</para>
            <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex},System.Func{ILNumerics.complex,ILNumerics.complex,ILNumerics.complex})"/> perform fastest where 
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
            <para>The function is efficiently parallelized and <paramref name="func"/> is evaluated from multiple threads. Make sure that <paramref name="func"/>
            is threadsafe!</para>
            <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A"/>, <paramref name="B"/> 
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single},System.Func{System.Single,System.Single,System.Single})">
            <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single},System.Func{System.Single,System.Single,System.Single})"/> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements 
            of <paramref name="A"/> and <paramref name="B"/> by evaluating <paramref name="func"/> for each element of the resulting array.</para>
            <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single},System.Func{System.Single,System.Single,System.Single})"/> perform fastest where 
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
            <para>The function is efficiently parallelized and <paramref name="func"/> is evaluated from multiple threads. Make sure that <paramref name="func"/>
            is threadsafe!</para>
            <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A"/>, <paramref name="B"/> 
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``1(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``0},System.Func{``0,``0,``0})">
            <summary>
            Binary, elementwise, broadcasting operation: <![CDATA[Apply<T>]]>.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})">
            <summary>
            Binary, elementwise, broadcasting <![CDATA[apply<T1,T2,Tout>]]>(A,B). Maps a scalar operation from elements of <paramref name="A"/> and <paramref name="B"/> to a third array. Arbitrary types. Parallelized.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,System.Int64,``2})"/>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,System.Int64,``2})">
             <summary>
             Binary, elementwise, broadcasting <![CDATA[apply<T1,T2,long,Tout>]]>(A,B). Maps a scalar operation from elements of 
             <paramref name="A"/> and <paramref name="B"/> to a third array, provides element index. Arbitrary types. Parallelized.
             </summary>
             <param name="A">The one array.</param>
             <param name="B">The other array.</param>
             <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding 
             elements of <paramref name="A"/> and <paramref name="B"/>, utilizing respective element values and the index 
             used to locate the output array in iteration order.</param>
             <returns>New or reused array with result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
             <remarks><para>The iteration order depends on the order of input arrays: for column major 
             input <c>i</c> will run in column major order and in row major order for row major inputs. If inputs have 
             other, undefined or different storage orders the result is undefined. It is recommended to use this function on vector input(s) 
             or with a well defined storage order for inputs <paramref name="A"/> and/or <paramref name="B"/>.</para>
             <para>This function may automatically work inplace on either of both input parameters, if possible.</para>
             <para></para>
             </remarks>
             <example><para>'Merge' elements a of an vector of 0's with a scalar -1, weighting with the location index <c>i</c> by applying the function: <c>c = a + i * b</c>.</para>
             <code><![CDATA[Array<int> C = apply(zeros<int>(10,1), vector(-1), (a, b, i) => (int)(a + i * b));
             C
            <Int32> [10,1] 0...-9 |
                [0]:            0
                [1]:           -1
                [2]:           -2
                [3]:           -3
                [4]:           -4
                [5]:           -5
                [6]:           -6
                [7]:           -7
                [8]:           -8
                [9]:           -9
             ]]></code>
             <para>Efficiently overwrite/initialize the content of an uninitialized array with upwards counting values, row major storage order.</para>
             <code><![CDATA[Array<double> D = apply(empty<double>(4, 3, 2, StorageOrders.RowMajor), zeros(1), (a, b, i) => (double)i);
             D
            <Double> [4,3,2] 0...23 -
                [0]: (:,:,0)
                [1]:            0           2           4
                [2]:            6           8          10
                [3]:           12          14          16
                [4]:           18          20          22
                [5]: (:,:,1)
                [6]:            1           3           5
                [7]:            7           9          11
                [8]:           13          15          17
                [9]:           19          21          23
            ]]></code>
            <para>The last example produces the same result as the expression: <c>counter(4,3,2, StorageOrders.RowMajor);</c>. The larger flexibility 
            in the generator function <paramref name="func"/> comes with a slight computational overhead, though.</para>
             </example>
             <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``1(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``0},System.Func{``0,``0,``0})"/>
             <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})"/>
             <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros(ILNumerics.InArray{System.Int64})"/>
             <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)"/>
             <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.atan2(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Binary, elementwise, broadcasting operation: Atan2.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.atan2(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Binary, elementwise, broadcasting operation: Atan2.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitand(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitand(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitand(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitand(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitand(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitand(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitand(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitand(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitor(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitor(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitor(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitor(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitor(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitor(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitor(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitor(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lshift(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lshift(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lshift(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lshift(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lshift(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lshift(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lshift(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lshift(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rshift(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rshift(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rshift(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rshift(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rshift(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rshift(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rshift(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.rshift(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitxor(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitxor(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitxor(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitxor(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitxor(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitxor(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitxor(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitxor(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ccomplex(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Binary, elementwise, broadcasting operation: CComplex.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ccomplex(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Binary, elementwise, broadcasting operation: CComplex.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide_sat(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide_sat(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide_sat(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide_sat(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide_sat(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide_sat(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide_sat(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide_sat(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.divide(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Binary, elementwise, broadcasting operation: Divide.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{System.Boolean},ILNumerics.BaseArray{System.Boolean})">
            <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Boolean"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eqnan(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Elementwise 'Equal' comparison operator on two arrays. Compares NaN and Inf like regular values.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eqnan(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Elementwise 'Equal' comparison operator on two arrays. Compares NaN and Inf like regular values.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eqnan(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Elementwise 'Equal' comparison operator on two arrays. Compares NaN and Inf like regular values.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.eqnan(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Elementwise 'Equal' comparison operator on two arrays. Compares NaN and Inf like regular values.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ge(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ge(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ge(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ge(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ge(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ge(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ge(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ge(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ge(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ge(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ge(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ge(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.gt(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.gt(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.gt(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.gt(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.gt(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.gt(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.gt(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.gt(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.gt(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.gt(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.gt(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.gt(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.le(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.le(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.le(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.le(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.le(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.le(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.le(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.le(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.le(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.le(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.le(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.le(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lt(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lt(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lt(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lt(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lt(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lt(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lt(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lt(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lt(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lt(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lt(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.lt(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double},System.Boolean)">
            <summary>
            Gives the maximum of corresponding elements from <paramref name="A"/> and <paramref name="B"/>. Recognizes NaN values.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="omitNaN">[Optional] specifies how to deal with NaN values in 
            <paramref name="A"/> or <paramref name="B"/>. Default: (true) prefer non-NaN values if possible.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Handling of NaN values: <paramref name="omitNaN"/> is true (default). For floating point element types and if one of the elements to compare is 
            <see cref="F:System.Double.NaN"/> the other element is returned. If both elements are 
            <see cref="F:System.Double.NaN"/> the element from <paramref name="A"/> is returned.</para>
            <para>If <paramref name="omitNaN"/> is false the result is <see cref="F:System.Double.NaN"/> if at least 
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>
            Gives the maximum of corresponding elements from <paramref name="A"/> and <paramref name="B"/>. Recognizes NaN values.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="omitNaN">[Optional] specifies how to deal with NaN values in 
            <paramref name="A"/> or <paramref name="B"/>. Default: (true) prefer non-NaN values if possible.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Handling of NaN values: <paramref name="omitNaN"/> is true (default). For floating point element types and if one of the elements to compare is 
            <see cref="P:ILNumerics.fcomplex.NaN"/> the other element is returned. If both elements are 
            <see cref="P:ILNumerics.fcomplex.NaN"/> the element from <paramref name="A"/> is returned.</para>
            <para>If <paramref name="omitNaN"/> is false the result is <see cref="P:ILNumerics.fcomplex.NaN"/> if at least 
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex},System.Boolean)">
            <summary>
            Gives the maximum of corresponding elements from <paramref name="A"/> and <paramref name="B"/>. Recognizes NaN values.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="omitNaN">[Optional] specifies how to deal with NaN values in 
            <paramref name="A"/> or <paramref name="B"/>. Default: (true) prefer non-NaN values if possible.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Handling of NaN values: <paramref name="omitNaN"/> is true (default). For floating point element types and if one of the elements to compare is 
            <see cref="P:ILNumerics.complex.NaN"/> the other element is returned. If both elements are 
            <see cref="P:ILNumerics.complex.NaN"/> the element from <paramref name="A"/> is returned.</para>
            <para>If <paramref name="omitNaN"/> is false the result is <see cref="P:ILNumerics.complex.NaN"/> if at least 
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single},System.Boolean)">
            <summary>
            Gives the maximum of corresponding elements from <paramref name="A"/> and <paramref name="B"/>. Recognizes NaN values.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="omitNaN">[Optional] specifies how to deal with NaN values in 
            <paramref name="A"/> or <paramref name="B"/>. Default: (true) prefer non-NaN values if possible.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Handling of NaN values: <paramref name="omitNaN"/> is true (default). For floating point element types and if one of the elements to compare is 
            <see cref="F:System.Single.NaN"/> the other element is returned. If both elements are 
            <see cref="F:System.Single.NaN"/> the element from <paramref name="A"/> is returned.</para>
            <para>If <paramref name="omitNaN"/> is false the result is <see cref="F:System.Single.NaN"/> if at least 
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>
            Gives the minimum of corresponding elements from <paramref name="A"/> and <paramref name="B"/>. Recognizes NaN values.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="omitNaN">[Optional] specifies how to deal with NaN values in 
            <paramref name="A"/> or <paramref name="B"/>. Default: (true) prefer non-NaN values if possible.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Handling of NaN values: <paramref name="omitNaN"/> is true (default). For floating point element types and if one of the elements to compare is 
            <see cref="P:ILNumerics.fcomplex.NaN"/> the other element is returned. If both elements are 
            <see cref="P:ILNumerics.fcomplex.NaN"/> the element from <paramref name="A"/> is returned.</para>
            <para>If <paramref name="omitNaN"/> is false the result is <see cref="P:ILNumerics.fcomplex.NaN"/> if at least 
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex},System.Boolean)">
            <summary>
            Gives the minimum of corresponding elements from <paramref name="A"/> and <paramref name="B"/>. Recognizes NaN values.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="omitNaN">[Optional] specifies how to deal with NaN values in 
            <paramref name="A"/> or <paramref name="B"/>. Default: (true) prefer non-NaN values if possible.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Handling of NaN values: <paramref name="omitNaN"/> is true (default). For floating point element types and if one of the elements to compare is 
            <see cref="P:ILNumerics.complex.NaN"/> the other element is returned. If both elements are 
            <see cref="P:ILNumerics.complex.NaN"/> the element from <paramref name="A"/> is returned.</para>
            <para>If <paramref name="omitNaN"/> is false the result is <see cref="P:ILNumerics.complex.NaN"/> if at least 
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single},System.Boolean)">
            <summary>
            Gives the minimum of corresponding elements from <paramref name="A"/> and <paramref name="B"/>. Recognizes NaN values.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="omitNaN">[Optional] specifies how to deal with NaN values in 
            <paramref name="A"/> or <paramref name="B"/>. Default: (true) prefer non-NaN values if possible.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Handling of NaN values: <paramref name="omitNaN"/> is true (default). For floating point element types and if one of the elements to compare is 
            <see cref="F:System.Single.NaN"/> the other element is returned. If both elements are 
            <see cref="F:System.Single.NaN"/> the element from <paramref name="A"/> is returned.</para>
            <para>If <paramref name="omitNaN"/> is false the result is <see cref="F:System.Single.NaN"/> if at least 
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double},System.Boolean)">
            <summary>
            Gives the minimum of corresponding elements from <paramref name="A"/> and <paramref name="B"/>. Recognizes NaN values.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <param name="omitNaN">[Optional] specifies how to deal with NaN values in 
            <paramref name="A"/> or <paramref name="B"/>. Default: (true) prefer non-NaN values if possible.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
            <remarks><para>Handling of NaN values: <paramref name="omitNaN"/> is true (default). For floating point element types and if one of the elements to compare is 
            <see cref="F:System.Double.NaN"/> the other element is returned. If both elements are 
            <see cref="F:System.Double.NaN"/> the element from <paramref name="A"/> is returned.</para>
            <para>If <paramref name="omitNaN"/> is false the result is <see cref="F:System.Double.NaN"/> if at least 
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod_sat(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod_sat(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod_sat(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod_sat(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod_sat(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod_sat(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod_sat(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod_sat(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.mod(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem_sat(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem_sat(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem_sat(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem_sat(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem_sat(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem_sat(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem_sat(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem_sat(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.multiplyElem(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow_sat(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow_sat(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow_sat(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow_sat(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow_sat(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow_sat(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow_sat(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow_sat(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.pow(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Binary, elementwise, broadcasting operation: Pow.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract_sat(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract_sat(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract_sat(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract_sat(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract_sat(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract_sat(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract_sat(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract_sat(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.subtract(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            </summary>
            <param name="A">The one array.</param>
            <param name="B">The other array.</param>
            <returns>Result of operating elements of <paramref name="A"/> and <paramref name="B"/> elementwise.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.neq(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
            <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.neq(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
            <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.neq(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
            <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.neq(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
            <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.neq(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
            <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.neq(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
            <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.neq(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
            <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.neq(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
            <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.neq(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.neq(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.neq(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
            <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.neq(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
            <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.neq(ILNumerics.BaseArray{System.Boolean},ILNumerics.BaseArray{System.Boolean})">
            <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            </summary>
            <param name="A">The first array.</param>
            <param name="B">The second array.</param>
            <returns>Logical array with the size broadcasted from <paramref name="A"/> and <paramref name="B"/>.</returns>
            <remarks><para>General notes on binary broadcasting operators: The operation is performed 
            elementwise on corresponding elements of <paramref name="A"/> and <paramref name="B"/>. The sizes of both 
            input arrays must be broadcastable and determine the size of the resulting array. Note, that 
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/>. However, 
            the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration affects the operation in the following ways: 
            <list type="bullet">
            <item>If <paramref name="A"/> and <paramref name="B"/> have different number of dimensions, the array with 
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In 
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> 
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item>
            <item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>: Result values of integer element types T are clamped to the 
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower 
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Boolean"/> precision 
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy"/> no such 
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item>
            </list>
            </para>
            <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A"/> or <paramref name="B"/> is 
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the 
            input array and/or its storage is reused and returned.</para>
            </remarks>
            <seealso href="https://ilnumerics.net/array-operators_v5.html"/>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.abs(ILNumerics.BaseArray{System.Int64})">
            <summary>Absolute values of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Absolute values of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.abs(ILNumerics.BaseArray{System.Int32})">
            <summary>Absolute values of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Absolute values of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.abs(ILNumerics.BaseArray{System.Int16})">
            <summary>Absolute values of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Absolute values of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.abs(ILNumerics.BaseArray{System.SByte})">
            <summary>Absolute values of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Absolute values of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.abs(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Absolute values of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Absolute values of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.abs(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Absolute values of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Absolute values of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.abs(ILNumerics.BaseArray{System.Single})">
            <summary>Absolute values of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Absolute values of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.abs(ILNumerics.BaseArray{System.Double})">
            <summary>Absolute values of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Absolute values of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.acos(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Computes angles for cosine array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Returns the angles whose cosine corresponds to the input array elements. See: <see cref="M:ILNumerics.fcomplex.Acos(ILNumerics.fcomplex)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.acos(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Computes angles for cosine array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Returns the angles whose cosine corresponds to the input array elements. See: <see cref="M:ILNumerics.complex.Acos(ILNumerics.complex)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.acos(ILNumerics.BaseArray{System.Single})">
            <summary>Computes angles for cosine array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Returns the angles whose cosine corresponds to the input array elements. See: <see cref="M:System.Math.Acos(System.Double)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.acos(ILNumerics.BaseArray{System.Double})">
            <summary>Computes angles for cosine array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Returns the angles whose cosine corresponds to the input array elements. See: <see cref="M:System.Math.Acos(System.Double)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.asinc(ILNumerics.BaseArray{System.Single})">
            <summary>Angles of cosine elements, complex output.</summary>
            <param name="A">Input array.</param>
            <returns>The angle whose sine corresponds to the array elements. See: <see cref="M:ILNumerics.fcomplex.Asin(System.Single)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.asinc(ILNumerics.BaseArray{System.Double})">
            <summary>Angles of cosine elements, complex output.</summary>
            <param name="A">Input array.</param>
            <returns>The angle whose sine corresponds to the array elements. See: <see cref="M:ILNumerics.complex.Asin(System.Double)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.asin(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Angles of cosine elements.</summary>
            <param name="A">Input array.</param>
            <returns>The angle whose sine corresponds to the array elements. See: <see cref="M:ILNumerics.fcomplex.Asin(ILNumerics.fcomplex)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.asin(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Angles of cosine elements.</summary>
            <param name="A">Input array.</param>
            <returns>The angle whose sine corresponds to the array elements. See: <see cref="M:ILNumerics.complex.Asin(ILNumerics.complex)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.asin(ILNumerics.BaseArray{System.Single})">
            <summary>Angles of cosine elements.</summary>
            <param name="A">Input array.</param>
            <returns>The angle whose sine corresponds to the array elements. See: <see cref="M:System.Math.Asin(System.Double)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.asin(ILNumerics.BaseArray{System.Double})">
            <summary>Angles of cosine elements.</summary>
            <param name="A">Input array.</param>
            <returns>The angle whose sine corresponds to the array elements. See: <see cref="M:System.Math.Asin(System.Double)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.atan(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Angles of tangent array elements.</summary>
            <param name="A">Input array.</param>
            <returns>The angle whose tangent corresponds to the array elements. See: <see cref="M:ILNumerics.fcomplex.Atan(ILNumerics.fcomplex)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.atan(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Angles of tangent array elements.</summary>
            <param name="A">Input array.</param>
            <returns>The angle whose tangent corresponds to the array elements. See: <see cref="M:ILNumerics.complex.Atan(ILNumerics.complex)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.atan(ILNumerics.BaseArray{System.Single})">
            <summary>Angles of tangent array elements.</summary>
            <param name="A">Input array.</param>
            <returns>The angle whose tangent corresponds to the array elements. See: <see cref="M:System.Math.Atan(System.Double)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.atan(ILNumerics.BaseArray{System.Double})">
            <summary>Angles of tangent array elements.</summary>
            <param name="A">Input array.</param>
            <returns>The angle whose tangent corresponds to the array elements. See: <see cref="M:System.Math.Atan(System.Double)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitneg(ILNumerics.BaseArray{System.UInt64})">
            <summary>Bitwise negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Bitwise negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitneg(ILNumerics.BaseArray{System.Int64})">
            <summary>Bitwise negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Bitwise negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitneg(ILNumerics.BaseArray{System.UInt32})">
            <summary>Bitwise negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Bitwise negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitneg(ILNumerics.BaseArray{System.Int32})">
            <summary>Bitwise negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Bitwise negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitneg(ILNumerics.BaseArray{System.UInt16})">
            <summary>Bitwise negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Bitwise negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitneg(ILNumerics.BaseArray{System.Int16})">
            <summary>Bitwise negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Bitwise negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitneg(ILNumerics.BaseArray{System.Byte})">
            <summary>Bitwise negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Bitwise negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.bitneg(ILNumerics.BaseArray{System.SByte})">
            <summary>Bitwise negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Bitwise negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ceil(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Computes the smallest integer greater than or equal to elements in <paramref name="A"/></summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size as <paramref name="A"/> with elements rounded up to the next integer. See: <see cref="M:ILNumerics.fcomplex.Ceiling(ILNumerics.fcomplex)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ceil(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Computes the smallest integer greater than or equal to elements in <paramref name="A"/></summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size as <paramref name="A"/> with elements rounded up to the next integer. See: <see cref="M:ILNumerics.complex.Ceiling(ILNumerics.complex)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ceil(ILNumerics.BaseArray{System.Single})">
            <summary>Computes the smallest integer greater than or equal to elements in <paramref name="A"/></summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size as <paramref name="A"/> with elements rounded up to the next integer. See: <see cref="M:System.Math.Ceiling(System.Double)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.ceil(ILNumerics.BaseArray{System.Double})">
            <summary>Computes the smallest integer greater than or equal to elements in <paramref name="A"/></summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size as <paramref name="A"/> with elements rounded up to the next integer. See: <see cref="M:System.Math.Ceiling(System.Double)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.conj(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Creates the complex conjugate of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the complex conjugate of A's array elements. See: <see cref="M:ILNumerics.fcomplex.Cos(ILNumerics.fcomplex)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.conj(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Creates the complex conjugate of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the complex conjugate of A's array elements. See: <see cref="M:ILNumerics.complex.Cos(ILNumerics.complex)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.conjInplace(ILNumerics.Core.Arrays.Mutable{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})">
            <summary>Conjugates complex elements inplace.</summary>
            <param name="A">Mutable input array.</param>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/> inplace.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>Elements of the input array <paramref name="A"/> are directly altered. New memory is only used if the elements 
            of <paramref name="A"/> are currently shared with other arrays. Only in this case a copy is created automatically.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.conjInplace(ILNumerics.Core.Arrays.Mutable{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}})">
            <summary>Conjugates fcomplex elements inplace.</summary>
            <param name="A">Mutable input array.</param>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/> inplace.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>Elements of the input array <paramref name="A"/> are directly altered. New memory is only used if the elements 
            of <paramref name="A"/> are currently shared with other arrays. Only in this case a copy is created automatically.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``1(ILNumerics.BaseArray)">
            <summary>
            Converts numeric array of unknown type to a specific array type. 
            </summary>
            <typeparam name="outT">Target element type.</typeparam>
            <param name="A">Source array.</param>
            <returns>Array of the same shape and size and element type of <typeparamref name="outT"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})">
            <summary>
            Convert typed source array <paramref name="A"/> into array of element type <typeparamref name="outT"/>.
            </summary>
            <typeparam name="inT">Source element type.</typeparam>
            <typeparam name="outT">Target element type.</typeparam>
            <param name="A">Source array.</param>
            <returns>Array of the same shape  and size than <paramref name="A"/>, having the element values converted to type <typeparamref name="outT"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cos(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Cosines of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the cosine of A's array elements. See: <see cref="M:ILNumerics.fcomplex.Cos(ILNumerics.fcomplex)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cos(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Cosines of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the cosine of A's array elements. See: <see cref="M:ILNumerics.complex.Cos(ILNumerics.complex)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cos(ILNumerics.BaseArray{System.Single})">
            <summary>Cosines of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the cosine of A's array elements. See: <see cref="M:System.Math.Cos(System.Double)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cos(ILNumerics.BaseArray{System.Double})">
            <summary>Cosines of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the cosine of A's array elements. See: <see cref="M:System.Math.Cos(System.Double)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cosh(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Hyperbolic cosines of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the hyperbolic cosine of A's array elements. See: <see cref="M:ILNumerics.fcomplex.Cosh(ILNumerics.fcomplex)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cosh(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Hyperbolic cosines of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the hyperbolic cosine of A's array elements. See: <see cref="M:ILNumerics.complex.Cosh(ILNumerics.complex)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cosh(ILNumerics.BaseArray{System.Single})">
            <summary>Hyperbolic cosines of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the hyperbolic cosine of A's array elements. See: <see cref="M:System.Math.Cosh(System.Double)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.cosh(ILNumerics.BaseArray{System.Double})">
            <summary>Hyperbolic cosines of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the hyperbolic cosine of A's array elements. See: <see cref="M:System.Math.Cosh(System.Double)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.exp(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Raise power of <c>e</c>.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with <c>e</c> raised to the power as given by A's array elements. See: <see cref="M:ILNumerics.fcomplex.Exp(ILNumerics.fcomplex)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.exp(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Raise power of <c>e</c>.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with <c>e</c> raised to the power as given by A's array elements. See: <see cref="M:ILNumerics.complex.Exp(ILNumerics.complex)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.exp(ILNumerics.BaseArray{System.Single})">
            <summary>Raise power of <c>e</c>.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with <c>e</c> raised to the power as given by A's array elements. See: <see cref="M:System.Math.Exp(System.Double)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.exp(ILNumerics.BaseArray{System.Double})">
            <summary>Raise power of <c>e</c>.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with <c>e</c> raised to the power as given by A's array elements. See: <see cref="M:System.Math.Exp(System.Double)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fix(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Round elements towards zero.</summary>
            <param name="A">Input array.</param>
            <returns>Array of same size as A with elements rounded towards zero.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fix(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Round elements towards zero.</summary>
            <param name="A">Input array.</param>
            <returns>Array of same size as A with elements rounded towards zero.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fix(ILNumerics.BaseArray{System.Single})">
            <summary>Round elements towards zero.</summary>
            <param name="A">Input array.</param>
            <returns>Array of same size as A with elements rounded towards zero.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.fix(ILNumerics.BaseArray{System.Double})">
            <summary>Round elements towards zero.</summary>
            <param name="A">Input array.</param>
            <returns>Array of same size as A with elements rounded towards zero.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.floor(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Round elements towards negative infinity.</summary>
            <param name="A">Input array.</param>
            <returns>Array of same size as A with elements rounded towards negative infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.floor(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Round elements towards negative infinity.</summary>
            <param name="A">Input array.</param>
            <returns>Array of same size as A with elements rounded towards negative infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.floor(ILNumerics.BaseArray{System.Single})">
            <summary>Round elements towards negative infinity.</summary>
            <param name="A">Input array.</param>
            <returns>Array of same size as A with elements rounded towards negative infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.floor(ILNumerics.BaseArray{System.Double})">
            <summary>Round elements towards negative infinity.</summary>
            <param name="A">Input array.</param>
            <returns>Array of same size as A with elements rounded towards negative infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Double})">
            <summary>Checks for non-infinity, non-NaN elements.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as A with 'true' element where elements in A are finite.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Double})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Double})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Double})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Double})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Checks for finite elements.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as A with 'true' element where elements in A are finite.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.fcomplex})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Checks for finite elements.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as A with 'true' element where elements in A are finite.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.complex})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.complex})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.complex})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.complex})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Single})">
            <summary>Checks for finite elements.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as A with 'true' element where elements in A are finite.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Single})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Single})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Single})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Single})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Checks for infinite elements.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> equal +/-infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.fcomplex})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Checks for infinite elements.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> equal +/-infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.complex})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.complex})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.complex})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.complex})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Single})">
            <summary>Checks for infinite elements.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> equal +/-infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Single})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Single})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Single})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Single})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Double})">
            <summary>Checks for infinite elements.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> equal +/-infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Double})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Double})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Double})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Double})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isnan(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Checks for elements which are not a number (NaN).</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> are NaN.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.fcomplex})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isnan(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Checks for elements which are not a number (NaN).</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> are NaN.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.complex})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.complex})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.complex})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.complex})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isnan(ILNumerics.BaseArray{System.Single})">
            <summary>Checks for elements which are not a number (NaN).</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> are NaN.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Single})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Single})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Single})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Single})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isnan(ILNumerics.BaseArray{System.Double})">
            <summary>Checks for elements which are not a number (NaN).</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> are NaN.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Double})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Double})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Double})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Double})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Checks for elements which correspond to negative infinity.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> 'equal' negative infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.fcomplex})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Checks for elements which correspond to negative infinity.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> 'equal' negative infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.complex})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.complex})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.complex})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.complex})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Single})">
            <summary>Checks for elements which correspond to negative infinity.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> 'equal' negative infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Single})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Single})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Single})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Single})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Double})">
            <summary>Checks for elements which correspond to negative infinity.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> 'equal' negative infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Double})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Double})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Double})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Double})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Checks for elements which correspond to positive infinity.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> 'equal' positive infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.fcomplex})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.fcomplex})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Checks for elements which correspond to positive infinity.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> 'equal' positive infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.complex})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.complex})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.complex})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.complex})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Single})">
            <summary>Checks for elements which correspond to positive infinity.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> 'equal' positive infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Single})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Single})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Single})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Single})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Double})">
            <summary>Checks for elements which correspond to positive infinity.</summary>
            <param name="A">Input array.</param>
            <returns>Logical array of the same size as <paramref name="A"/> with 'true' element where elements in <paramref name="A"/> 'equal' positive infinity.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para><b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Double})"/>, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Double})"/>, 
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Double})"/> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Double})"/> return false for NaN (not a number) 
            special floating point value elements.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.logc(ILNumerics.BaseArray{System.Single})">
            <summary>Logarithm of array elements - complex output.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of logc(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.logc(ILNumerics.BaseArray{System.Double})">
            <summary>Logarithm of array elements - complex output.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of logc(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.log(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Logarithm of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of log(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.log(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Logarithm of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of log(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.log(ILNumerics.BaseArray{System.Single})">
            <summary>Logarithm of array elements - real output.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of log(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.log(ILNumerics.BaseArray{System.Double})">
            <summary>Logarithm of array elements - real output.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of log(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.log10c(ILNumerics.BaseArray{System.Single})">
            <summary>Base 10 logarithm of array elements - complex output.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of log10c(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.log10c(ILNumerics.BaseArray{System.Double})">
            <summary>Base 10 logarithm of array elements - complex output.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of log10c(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.log10(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Base 10 logarithm of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of log10(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.log10(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Base 10 logarithm of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of log10(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.log10(ILNumerics.BaseArray{System.Single})">
            <summary>Base 10 logarithm of array elements - real output.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of log10(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.log10(ILNumerics.BaseArray{System.Double})">
            <summary>Base 10 logarithm of array elements - real output.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of log10(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.negate(ILNumerics.BaseArray{System.Double})">
            <summary>Unary negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Unary negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.negate(ILNumerics.BaseArray{System.Single})">
            <summary>Unary negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Unary negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.negate(ILNumerics.BaseArray{System.Int64})">
            <summary>Unary negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Unary negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.negate(ILNumerics.BaseArray{System.UInt32})">
            <summary>Unary negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Unary negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.negate(ILNumerics.BaseArray{System.Int32})">
            <summary>Unary negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Unary negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.negate(ILNumerics.BaseArray{System.UInt16})">
            <summary>Unary negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Unary negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.negate(ILNumerics.BaseArray{System.Int16})">
            <summary>Unary negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Unary negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.negate(ILNumerics.BaseArray{System.Byte})">
            <summary>Unary negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Unary negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.negate(ILNumerics.BaseArray{System.SByte})">
            <summary>Unary negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Unary negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.not(ILNumerics.BaseArray{System.Boolean})">
            <summary>Logical negation of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Logical negation of array elements.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.round(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Round elements to the nearest integer.</summary>
            <param name="A">Input array.</param>
            <returns>Array of same size as A with elements of A rounded towards the nearest integer value.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.round(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Round elements to the nearest integer.</summary>
            <param name="A">Input array.</param>
            <returns>Array of same size as A with elements of A rounded towards the nearest integer value.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.round(ILNumerics.BaseArray{System.Single})">
            <summary>Round elements to the nearest integer.</summary>
            <param name="A">Input array.</param>
            <returns>Array of same size as A with elements of A rounded towards the nearest integer value.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.round(ILNumerics.BaseArray{System.Double})">
            <summary>Round elements to the nearest integer.</summary>
            <param name="A">Input array.</param>
            <returns>Array of same size as A with elements of A rounded towards the nearest integer value.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.round(ILNumerics.BaseArray{System.Double},System.Int32)">
            <summary>Round elements to a specified number of fractional digits.</summary>
            <param name="A">Input array.</param>
            <param name="decimals">[Optional] number of fractional digits to round to. Default: (0) round to integers.</param>
            <returns>Array of same size as A with elements of A rounded towards the nearest even integer value.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.round(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)">
            <summary>Round elements to a specified number of fractional digits.</summary>
            <param name="A">Input array.</param>
            <param name="decimals">[Optional] number of fractional digits to round to. Default: (0) round to integers.</param>
            <returns>Array of same size as A with elements of A rounded towards the nearest even integer value.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.round(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)">
            <summary>Round elements to a specified number of fractional digits.</summary>
            <param name="A">Input array.</param>
            <param name="decimals">[Optional] number of fractional digits to round to. Default: (0) round to integers.</param>
            <returns>Array of same size as A with elements of A rounded towards the nearest even integer value.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.round(ILNumerics.BaseArray{System.Single},System.Int32)">
            <summary>Round elements to a specified number of fractional digits.</summary>
            <param name="A">Input array.</param>
            <param name="decimals">[Optional] number of fractional digits to round to. Default: (0) round to integers.</param>
            <returns>Array of same size as A with elements of A rounded towards the nearest even integer value.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sign(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Signum function of array elements (projection onto unit circle).</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same shape as <paramref name="A"/> with the elementwise result of sign(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sign(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Signum function of array elements (projection onto unit circle).</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same shape as <paramref name="A"/> with the elementwise result of sign(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sign(ILNumerics.BaseArray{System.Byte})">
            <summary>Signum function of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same shape as <paramref name="A"/> with the elementwise result of sign(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sign(ILNumerics.BaseArray{System.SByte})">
            <summary>Signum function of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same shape as <paramref name="A"/> with the elementwise result of sign(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sign(ILNumerics.BaseArray{System.UInt16})">
            <summary>Signum function of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same shape as <paramref name="A"/> with the elementwise result of sign(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sign(ILNumerics.BaseArray{System.Int16})">
            <summary>Signum function of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same shape as <paramref name="A"/> with the elementwise result of sign(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sign(ILNumerics.BaseArray{System.UInt32})">
            <summary>Signum function of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same shape as <paramref name="A"/> with the elementwise result of sign(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sign(ILNumerics.BaseArray{System.Int32})">
            <summary>Signum function of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same shape as <paramref name="A"/> with the elementwise result of sign(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sign(ILNumerics.BaseArray{System.UInt64})">
            <summary>Signum function of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same shape as <paramref name="A"/> with the elementwise result of sign(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sign(ILNumerics.BaseArray{System.Int64})">
            <summary>Signum function of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same shape as <paramref name="A"/> with the elementwise result of sign(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sign(ILNumerics.BaseArray{System.Single})">
            <summary>Signum function of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same shape as <paramref name="A"/> with the elementwise result of sign(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sign(ILNumerics.BaseArray{System.Double})">
            <summary>Signum function of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same shape as <paramref name="A"/> with the elementwise result of sign(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sin(ILNumerics.BaseArray{System.Double})">
            <summary>
            Compute the sinus of the elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New array with the same size as <paramref name="A"/> and with the result of the unary operation performed on all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sin(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            Compute the sinus of the elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New array with the same size as <paramref name="A"/> and with the result of the unary operation performed on all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sin(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            Compute the sinus of the elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New array with the same size as <paramref name="A"/> and with the result of the unary operation performed on all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sin(ILNumerics.BaseArray{System.Single})">
            <summary>
            Compute the sinus of the elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New array with the same size as <paramref name="A"/> and with the result of the unary operation performed on all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sinh(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Hyperbolic sine of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the hyperbolic sine of A's array elements. See: <see cref="M:ILNumerics.fcomplex.Cosh(ILNumerics.fcomplex)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sinh(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Hyperbolic sine of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the hyperbolic sine of A's array elements. See: <see cref="M:ILNumerics.complex.Cosh(ILNumerics.complex)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sinh(ILNumerics.BaseArray{System.Single})">
            <summary>Hyperbolic sine of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the hyperbolic sine of A's array elements. See: <see cref="M:System.Math.Cosh(System.Double)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sinh(ILNumerics.BaseArray{System.Double})">
            <summary>Hyperbolic sine of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the hyperbolic sine of A's array elements. See: <see cref="M:System.Math.Cosh(System.Double)"/></returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sqrtc(ILNumerics.BaseArray{System.Single})">
            <summary>Square root of array elements - complex output.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of sqrtc(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sqrtc(ILNumerics.BaseArray{System.Double})">
            <summary>Square root of array elements - complex output.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of sqrtc(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sqrt(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Square root of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of sqrt(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sqrt(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Square root of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of sqrt(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sqrt(ILNumerics.BaseArray{System.Single})">
            <summary>Square root of array elements - real output.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of sqrt(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.sqrt(ILNumerics.BaseArray{System.Double})">
            <summary>Square root of array elements - real output.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/> with elementwise result of sqrt(A)..</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tan(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Tangent of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the tangents of A's array elements. See: <see cref="M:ILNumerics.fcomplex.Tan(ILNumerics.fcomplex)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tan(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Tangent of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the tangents of A's array elements. See: <see cref="M:ILNumerics.complex.Tan(ILNumerics.complex)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tan(ILNumerics.BaseArray{System.Single})">
            <summary>Tangent of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the tangents of A's array elements. See: <see cref="M:System.Math.Tan(System.Double)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tan(ILNumerics.BaseArray{System.Double})">
            <summary>Tangent of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the tangents of A's array elements. See: <see cref="M:System.Math.Tan(System.Double)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tanh(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Hyperbolic tangent of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the hyperbolic tangents of A's array elements. See: <see cref="M:ILNumerics.fcomplex.Tanh(ILNumerics.fcomplex)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tanh(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Hyperbolic tangent of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the hyperbolic tangents of A's array elements. See: <see cref="M:ILNumerics.complex.Tanh(ILNumerics.complex)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tanh(ILNumerics.BaseArray{System.Single})">
            <summary>Hyperbolic tangent of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the hyperbolic tangents of A's array elements. See: <see cref="M:System.Math.Tanh(System.Double)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tanh(ILNumerics.BaseArray{System.Double})">
            <summary>Hyperbolic tangent of array elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array of the same size/type as <paramref name="A"/> with the hyperbolic tangents of A's array elements. See: <see cref="M:System.Math.Tanh(System.Double)"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tocomplex(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Convert elements to Complex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{complex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tocomplex(ILNumerics.BaseArray{System.Byte})">
            <summary>Convert elements to Complex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{complex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tocomplex(ILNumerics.BaseArray{System.SByte})">
            <summary>Convert elements to Complex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{complex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tocomplex(ILNumerics.BaseArray{System.UInt16})">
            <summary>Convert elements to Complex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{complex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tocomplex(ILNumerics.BaseArray{System.Int16})">
            <summary>Convert elements to Complex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{complex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tocomplex(ILNumerics.BaseArray{System.UInt32})">
            <summary>Convert elements to Complex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{complex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tocomplex(ILNumerics.BaseArray{System.Int32})">
            <summary>Convert elements to Complex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{complex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tocomplex(ILNumerics.BaseArray{System.UInt64})">
            <summary>Convert elements to Complex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{complex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tocomplex(ILNumerics.BaseArray{System.Int64})">
            <summary>Convert elements to Complex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{complex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tocomplex(ILNumerics.BaseArray{System.Single})">
            <summary>Convert elements to Complex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{complex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tocomplex(ILNumerics.BaseArray{System.Double})">
            <summary>Convert elements to Complex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{complex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tocomplex(ILNumerics.BaseArray)">
            <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.Byte"/> elements.
            </summary>
            <param name="A">Source array.</param>
            <returns>New array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.todouble(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Convert elements to Double.</summary>
            <param name="A">Input array.</param>
            <returns>Array{double} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.todouble(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Convert elements to Double.</summary>
            <param name="A">Input array.</param>
            <returns>Array{double} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.todouble(ILNumerics.BaseArray{System.Byte})">
            <summary>Convert elements to Double.</summary>
            <param name="A">Input array.</param>
            <returns>Array{double} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.todouble(ILNumerics.BaseArray{System.SByte})">
            <summary>Convert elements to Double.</summary>
            <param name="A">Input array.</param>
            <returns>Array{double} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.todouble(ILNumerics.BaseArray{System.UInt16})">
            <summary>Convert elements to Double.</summary>
            <param name="A">Input array.</param>
            <returns>Array{double} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.todouble(ILNumerics.BaseArray{System.Int16})">
            <summary>Convert elements to Double.</summary>
            <param name="A">Input array.</param>
            <returns>Array{double} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.todouble(ILNumerics.BaseArray{System.UInt32})">
            <summary>Convert elements to Double.</summary>
            <param name="A">Input array.</param>
            <returns>Array{double} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.todouble(ILNumerics.BaseArray{System.Int32})">
            <summary>Convert elements to Double.</summary>
            <param name="A">Input array.</param>
            <returns>Array{double} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.todouble(ILNumerics.BaseArray{System.UInt64})">
            <summary>Convert elements to Double.</summary>
            <param name="A">Input array.</param>
            <returns>Array{double} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.todouble(ILNumerics.BaseArray{System.Int64})">
            <summary>Convert elements to Double.</summary>
            <param name="A">Input array.</param>
            <returns>Array{double} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.todouble(ILNumerics.BaseArray{System.Single})">
            <summary>Convert elements to Double.</summary>
            <param name="A">Input array.</param>
            <returns>Array{double} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.todouble(ILNumerics.BaseArray)">
            <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.Double"/> elements.
            </summary>
            <param name="A">Source array.</param>
            <returns>New array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tofcomplex(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Convert elements to FComplex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{fcomplex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tofcomplex(ILNumerics.BaseArray{System.Byte})">
            <summary>Convert elements to FComplex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{fcomplex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tofcomplex(ILNumerics.BaseArray{System.SByte})">
            <summary>Convert elements to FComplex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{fcomplex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tofcomplex(ILNumerics.BaseArray{System.UInt16})">
            <summary>Convert elements to FComplex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{fcomplex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tofcomplex(ILNumerics.BaseArray{System.Int16})">
            <summary>Convert elements to FComplex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{fcomplex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tofcomplex(ILNumerics.BaseArray{System.UInt32})">
            <summary>Convert elements to FComplex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{fcomplex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tofcomplex(ILNumerics.BaseArray{System.Int32})">
            <summary>Convert elements to FComplex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{fcomplex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tofcomplex(ILNumerics.BaseArray{System.UInt64})">
            <summary>Convert elements to FComplex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{fcomplex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tofcomplex(ILNumerics.BaseArray{System.Int64})">
            <summary>Convert elements to FComplex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{fcomplex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tofcomplex(ILNumerics.BaseArray{System.Single})">
            <summary>Convert elements to FComplex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{fcomplex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tofcomplex(ILNumerics.BaseArray{System.Double})">
            <summary>Convert elements to FComplex.</summary>
            <param name="A">Input array.</param>
            <returns>Array{fcomplex} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tofcomplex(ILNumerics.BaseArray)">
            <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:ILNumerics.fcomplex"/> elements.
            </summary>
            <param name="A">Source array.</param>
            <returns>New array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint16(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Convert elements to Int16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint16(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Convert elements to Int16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint16(ILNumerics.BaseArray{System.Byte})">
            <summary>Convert elements to Int16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint16(ILNumerics.BaseArray{System.SByte})">
            <summary>Convert elements to Int16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint16(ILNumerics.BaseArray{System.UInt32})">
            <summary>Convert elements to Int16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint16(ILNumerics.BaseArray{System.Int32})">
            <summary>Convert elements to Int16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint16(ILNumerics.BaseArray{System.UInt64})">
            <summary>Convert elements to Int16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint16(ILNumerics.BaseArray{System.Int64})">
            <summary>Convert elements to Int16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint16(ILNumerics.BaseArray{System.Single})">
            <summary>Convert elements to Int16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint16(ILNumerics.BaseArray{System.Double})">
            <summary>Convert elements to Int16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint16(ILNumerics.BaseArray)">
            <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.Int16"/> elements.
            </summary>
            <param name="A">Source array.</param>
            <returns>New array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint16(ILNumerics.BaseArray{System.UInt16})">
            <summary>(Reinterpret) cast array of unsigned elements to signed elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed without copying any elements. The returned array 
            has the same storage order and the same size as A.</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint32(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Convert elements to Int32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint32(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Convert elements to Int32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint32(ILNumerics.BaseArray{System.Byte})">
            <summary>Convert elements to Int32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint32(ILNumerics.BaseArray{System.SByte})">
            <summary>Convert elements to Int32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint32(ILNumerics.BaseArray{System.UInt16})">
            <summary>Convert elements to Int32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint32(ILNumerics.BaseArray{System.Int16})">
            <summary>Convert elements to Int32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint32(ILNumerics.BaseArray{System.UInt64})">
            <summary>Convert elements to Int32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint32(ILNumerics.BaseArray{System.Int64})">
            <summary>Convert elements to Int32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint32(ILNumerics.BaseArray{System.Single})">
            <summary>Convert elements to Int32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint32(ILNumerics.BaseArray{System.Double})">
            <summary>Convert elements to Int32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{int} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint32(ILNumerics.BaseArray)">
            <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.Int32"/> elements.
            </summary>
            <param name="A">Source array.</param>
            <returns>New array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint32(ILNumerics.BaseArray{System.UInt32})">
            <summary>(Reinterpret) cast array of unsigned elements to signed elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed without copying any elements. The returned array 
            has the same storage order and the same size as A.</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint64(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Convert elements to Int64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{long} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint64(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Convert elements to Int64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{long} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint64(ILNumerics.BaseArray{System.Byte})">
            <summary>Convert elements to Int64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{long} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint64(ILNumerics.BaseArray{System.SByte})">
            <summary>Convert elements to Int64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{long} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint64(ILNumerics.BaseArray{System.UInt16})">
            <summary>Convert elements to Int64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{long} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint64(ILNumerics.BaseArray{System.Int16})">
            <summary>Convert elements to Int64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{long} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint64(ILNumerics.BaseArray{System.UInt32})">
            <summary>Convert elements to Int64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{long} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint64(ILNumerics.BaseArray{System.Int32})">
            <summary>Convert elements to Int64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{long} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint64(ILNumerics.BaseArray{System.Single})">
            <summary>Convert elements to Int64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{long} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint64(ILNumerics.BaseArray{System.Double})">
            <summary>Convert elements to Int64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{long} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint64(ILNumerics.BaseArray)">
            <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.Int64"/> elements.
            </summary>
            <param name="A">Source array.</param>
            <returns>New array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint64(ILNumerics.BaseArray{System.UInt64})">
            <summary>(Reinterpret) cast array of unsigned elements to signed elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed without copying any elements. The returned array 
            has the same storage order and the same size as A.</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint8(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Convert elements to SByte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{sbyte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint8(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Convert elements to SByte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{sbyte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint8(ILNumerics.BaseArray{System.UInt16})">
            <summary>Convert elements to SByte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{sbyte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint8(ILNumerics.BaseArray{System.Int16})">
            <summary>Convert elements to SByte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{sbyte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint8(ILNumerics.BaseArray{System.UInt32})">
            <summary>Convert elements to SByte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{sbyte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint8(ILNumerics.BaseArray{System.Int32})">
            <summary>Convert elements to SByte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{sbyte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint8(ILNumerics.BaseArray{System.UInt64})">
            <summary>Convert elements to SByte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{sbyte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint8(ILNumerics.BaseArray{System.Int64})">
            <summary>Convert elements to SByte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{sbyte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint8(ILNumerics.BaseArray{System.Single})">
            <summary>Convert elements to SByte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{sbyte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint8(ILNumerics.BaseArray{System.Double})">
            <summary>Convert elements to SByte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{sbyte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint8(ILNumerics.BaseArray)">
            <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.SByte"/> elements.
            </summary>
            <param name="A">Source array.</param>
            <returns>New array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.toint8(ILNumerics.BaseArray{System.Byte})">
            <summary>(Reinterpret) cast array of unsigned elements to signed elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed without copying any elements. The returned array 
            has the same storage order and the same size as A.</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tological(ILNumerics.BaseArray)">
            <summary>
            Creates a logical array with 'true' values at the positions with non-0 elements of <paramref name="A"/>.
            </summary>
            <param name="A">Source array.</param>
            <returns>New array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tosingle(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Convert elements to Single.</summary>
            <param name="A">Input array.</param>
            <returns>Array{float} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tosingle(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Convert elements to Single.</summary>
            <param name="A">Input array.</param>
            <returns>Array{float} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tosingle(ILNumerics.BaseArray{System.Byte})">
            <summary>Convert elements to Single.</summary>
            <param name="A">Input array.</param>
            <returns>Array{float} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tosingle(ILNumerics.BaseArray{System.SByte})">
            <summary>Convert elements to Single.</summary>
            <param name="A">Input array.</param>
            <returns>Array{float} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tosingle(ILNumerics.BaseArray{System.UInt16})">
            <summary>Convert elements to Single.</summary>
            <param name="A">Input array.</param>
            <returns>Array{float} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tosingle(ILNumerics.BaseArray{System.Int16})">
            <summary>Convert elements to Single.</summary>
            <param name="A">Input array.</param>
            <returns>Array{float} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tosingle(ILNumerics.BaseArray{System.UInt32})">
            <summary>Convert elements to Single.</summary>
            <param name="A">Input array.</param>
            <returns>Array{float} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tosingle(ILNumerics.BaseArray{System.Int32})">
            <summary>Convert elements to Single.</summary>
            <param name="A">Input array.</param>
            <returns>Array{float} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tosingle(ILNumerics.BaseArray{System.UInt64})">
            <summary>Convert elements to Single.</summary>
            <param name="A">Input array.</param>
            <returns>Array{float} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tosingle(ILNumerics.BaseArray{System.Int64})">
            <summary>Convert elements to Single.</summary>
            <param name="A">Input array.</param>
            <returns>Array{float} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tosingle(ILNumerics.BaseArray{System.Double})">
            <summary>Convert elements to Single.</summary>
            <param name="A">Input array.</param>
            <returns>Array{float} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.tosingle(ILNumerics.BaseArray)">
            <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.Single"/> elements.
            </summary>
            <param name="A">Source array.</param>
            <returns>New array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint16(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Convert elements to UInt16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ushort} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint16(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Convert elements to UInt16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ushort} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint16(ILNumerics.BaseArray{System.Byte})">
            <summary>Convert elements to UInt16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ushort} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint16(ILNumerics.BaseArray{System.SByte})">
            <summary>Convert elements to UInt16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ushort} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint16(ILNumerics.BaseArray{System.UInt32})">
            <summary>Convert elements to UInt16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ushort} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint16(ILNumerics.BaseArray{System.Int32})">
            <summary>Convert elements to UInt16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ushort} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint16(ILNumerics.BaseArray{System.UInt64})">
            <summary>Convert elements to UInt16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ushort} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint16(ILNumerics.BaseArray{System.Int64})">
            <summary>Convert elements to UInt16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ushort} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint16(ILNumerics.BaseArray{System.Single})">
            <summary>Convert elements to UInt16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ushort} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint16(ILNumerics.BaseArray{System.Double})">
            <summary>Convert elements to UInt16.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ushort} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint16(ILNumerics.BaseArray)">
            <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.UInt16"/> elements.
            </summary>
            <param name="A">Source array.</param>
            <returns>New array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint16(ILNumerics.BaseArray{System.Int16})">
            <summary>(Reinterpret) cast array of unsigned elements to signed elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed without copying any elements. The returned array 
            has the same storage order and the same size as A.</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint32(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Convert elements to UInt32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{uint} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint32(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Convert elements to UInt32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{uint} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint32(ILNumerics.BaseArray{System.Byte})">
            <summary>Convert elements to UInt32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{uint} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint32(ILNumerics.BaseArray{System.SByte})">
            <summary>Convert elements to UInt32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{uint} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint32(ILNumerics.BaseArray{System.UInt16})">
            <summary>Convert elements to UInt32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{uint} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint32(ILNumerics.BaseArray{System.Int16})">
            <summary>Convert elements to UInt32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{uint} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint32(ILNumerics.BaseArray{System.UInt64})">
            <summary>Convert elements to UInt32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{uint} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint32(ILNumerics.BaseArray{System.Int64})">
            <summary>Convert elements to UInt32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{uint} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint32(ILNumerics.BaseArray{System.Single})">
            <summary>Convert elements to UInt32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{uint} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint32(ILNumerics.BaseArray{System.Double})">
            <summary>Convert elements to UInt32.</summary>
            <param name="A">Input array.</param>
            <returns>Array{uint} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint32(ILNumerics.BaseArray)">
            <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.UInt32"/> elements.
            </summary>
            <param name="A">Source array.</param>
            <returns>New array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint32(ILNumerics.BaseArray{System.Int32})">
            <summary>(Reinterpret) cast array of unsigned elements to signed elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed without copying any elements. The returned array 
            has the same storage order and the same size as A.</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint64(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Convert elements to UInt64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ulong} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint64(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Convert elements to UInt64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ulong} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint64(ILNumerics.BaseArray{System.Byte})">
            <summary>Convert elements to UInt64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ulong} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint64(ILNumerics.BaseArray{System.SByte})">
            <summary>Convert elements to UInt64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ulong} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint64(ILNumerics.BaseArray{System.UInt16})">
            <summary>Convert elements to UInt64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ulong} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint64(ILNumerics.BaseArray{System.Int16})">
            <summary>Convert elements to UInt64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ulong} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint64(ILNumerics.BaseArray{System.UInt32})">
            <summary>Convert elements to UInt64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ulong} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint64(ILNumerics.BaseArray{System.Int32})">
            <summary>Convert elements to UInt64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ulong} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint64(ILNumerics.BaseArray{System.Single})">
            <summary>Convert elements to UInt64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ulong} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint64(ILNumerics.BaseArray{System.Double})">
            <summary>Convert elements to UInt64.</summary>
            <param name="A">Input array.</param>
            <returns>Array{ulong} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint64(ILNumerics.BaseArray)">
            <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.UInt64"/> elements.
            </summary>
            <param name="A">Source array.</param>
            <returns>New array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint64(ILNumerics.BaseArray{System.Int64})">
            <summary>(Reinterpret) cast array of unsigned elements to signed elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed without copying any elements. The returned array 
            has the same storage order and the same size as A.</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint8(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>Convert elements to Byte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{byte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint8(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>Convert elements to Byte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{byte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint8(ILNumerics.BaseArray{System.UInt16})">
            <summary>Convert elements to Byte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{byte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint8(ILNumerics.BaseArray{System.Int16})">
            <summary>Convert elements to Byte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{byte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint8(ILNumerics.BaseArray{System.UInt32})">
            <summary>Convert elements to Byte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{byte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint8(ILNumerics.BaseArray{System.Int32})">
            <summary>Convert elements to Byte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{byte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint8(ILNumerics.BaseArray{System.UInt64})">
            <summary>Convert elements to Byte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{byte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint8(ILNumerics.BaseArray{System.Int64})">
            <summary>Convert elements to Byte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{byte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint8(ILNumerics.BaseArray{System.Single})">
            <summary>Convert elements to Byte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{byte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint8(ILNumerics.BaseArray{System.Double})">
            <summary>Convert elements to Byte.</summary>
            <param name="A">Input array.</param>
            <returns>Array{byte} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint8(ILNumerics.BaseArray)">
            <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.Byte"/> elements.
            </summary>
            <param name="A">Source array.</param>
            <returns>New array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint8(ILNumerics.BaseArray{System.SByte})">
            <summary>(Reinterpret) cast array of unsigned elements to signed elements.</summary>
            <param name="A">Input array.</param>
            <returns>Array{short} of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed without copying any elements. The returned array 
            has the same storage order and the same size as A.</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.MathInternal.touint8(ILNumerics.BaseArray{System.Boolean})">
            <summary>Convert elements to Byte.</summary>
            <param name="A">Input array.</param>
            <returns>Logical of the same shape as <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed without copying elements of <paramref name="A"/>.</para>
            <para>The array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>.</para>
            <para>The operation is performed by 'reinterprete-cast'-ing <paramref name="A"/> to the new output type.</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.UInt64Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.Int64Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.UInt32Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.Int32Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.UInt16Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.Int16Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.ByteSat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.SByteSat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Add.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Xor.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Xor.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Xor.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Xor.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Xor.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Xor.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Xor.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Xor.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Xor.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Xor.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Xor.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Xor.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Xor.Bool.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Or.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Or.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Or.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Or.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Or.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Or.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Or.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Or.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Or.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Or.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Or.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Or.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Or.Bool.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.And.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.And.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.And.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.And.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.And.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.And.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.And.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.And.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.And.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.And.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.And.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.And.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.And.Bool.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="pA"/> and <paramref name="pB"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Func{System.UInt64,System.UInt64,System.UInt64})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="pA"/> and <paramref name="pB"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Func{System.Int64,System.Int64,System.Int64})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="pA"/> and <paramref name="pB"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Func{System.UInt32,System.UInt32,System.UInt32})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="pA"/> and <paramref name="pB"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Func{System.Int32,System.Int32,System.Int32})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="pA"/> and <paramref name="pB"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Func{System.UInt16,System.UInt16,System.UInt16})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="pA"/> and <paramref name="pB"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Func{System.Int16,System.Int16,System.Int16})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="pA"/> and <paramref name="pB"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Func{System.Byte,System.Byte,System.Byte})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="pA"/> and <paramref name="pB"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Func{System.SByte,System.SByte,System.SByte})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="pA"/> and <paramref name="pB"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Func{ILNumerics.fcomplex,ILNumerics.fcomplex,ILNumerics.fcomplex})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="pA"/> and <paramref name="pB"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Func{ILNumerics.complex,ILNumerics.complex,ILNumerics.complex})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="pA"/> and <paramref name="pB"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Func{System.Single,System.Single,System.Single})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="pA"/> and <paramref name="pB"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Generic`1.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Func{`0,`0,`0})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="pA"/> and <paramref name="pB"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Generic_C_CS`3.Strided64(`2[],`0[],System.Byte*,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Generic_S_SS`3.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Generic_S_SC`3.Strided64(System.Byte*,System.Byte*,`1[],System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Generic_S_CS`3.Strided64(System.Byte*,`0[],System.Byte*,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Generic_S_CC`3.Strided64(System.Byte*,`0[],`1[],System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Generic_C_SS`3.Strided64(`2[],System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Generic_C_SC`3.Strided64(`2[],System.Byte*,`1[],System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Apply.Generic_C_CC`3.Strided64(`2[],`0[],`1[],System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.ApplyIndexed.Generic_C_CS`3.Strided64(`2[],`0[],System.Byte*,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,System.Int64,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.ApplyIndexed.Generic_S_SS`3.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,System.Int64,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.ApplyIndexed.Generic_S_SC`3.Strided64(System.Byte*,System.Byte*,`1[],System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,System.Int64,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.ApplyIndexed.Generic_S_CS`3.Strided64(System.Byte*,`0[],System.Byte*,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,System.Int64,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.ApplyIndexed.Generic_S_CC`3.Strided64(System.Byte*,`0[],`1[],System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,System.Int64,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.ApplyIndexed.Generic_C_SS`3.Strided64(`2[],System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,System.Int64,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.ApplyIndexed.Generic_C_SC`3.Strided64(`2[],System.Byte*,`1[],System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,System.Int64,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.ApplyIndexed.Generic_C_CC`3.Strided64(`2[],`0[],`1[],System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64*,System.Func{`0,`1,System.Int64,`2})">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="C">Pointer to base address of the output array, including any base offset.</param>
            <param name="A">Pointer to the base address of input array A, including any base offset.</param>
            <param name="B">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="func">The scalar function to be used to perform the binary action on individual, 
            corresponding elements of <paramref name="A"/> and <paramref name="B"/>.</param>
            <param name="offsA">Offset of first element into <paramref name="A"/>.</param>
            <param name="offsB">Offset of first element into <paramref name="B"/>.</param>
            <param name="offsC">Offset of first element into <paramref name="C"/>.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Atan2.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Atan2.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitAnd.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitAnd.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitAnd.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitAnd.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitAnd.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitAnd.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitAnd.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitAnd.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitOr.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitOr.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitOr.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitOr.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitOr.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitOr.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitOr.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitOr.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftLeft.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftLeft.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftLeft.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftLeft.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftLeft.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftLeft.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftLeft.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftLeft.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftRight.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftRight.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftRight.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftRight.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftRight.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftRight.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftRight.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitShiftRight.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitXor.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitXor.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitXor.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitXor.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitXor.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitXor.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitXor.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.BitXor.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.CComplex.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.CComplex.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.UInt64Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.Int64Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.UInt32Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.Int32Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.UInt16Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.Int16Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.ByteSat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.SByteSat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Divide.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualTo.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualTo.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualTo.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualTo.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualTo.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualTo.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualTo.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualTo.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualTo.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualTo.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualTo.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualTo.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualTo.Bool.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualWithEqualNaNs.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualWithEqualNaNs.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualWithEqualNaNs.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.EqualWithEqualNaNs.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterOrEqual.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterOrEqual.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterOrEqual.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterOrEqual.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterOrEqual.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterOrEqual.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterOrEqual.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterOrEqual.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterOrEqual.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterOrEqual.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterOrEqual.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterOrEqual.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterThan.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterThan.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterThan.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterThan.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterThan.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterThan.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterThan.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterThan.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterThan.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterThan.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterThan.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.GreaterThan.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerOrEqual.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerOrEqual.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerOrEqual.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerOrEqual.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerOrEqual.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerOrEqual.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerOrEqual.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerOrEqual.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerOrEqual.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerOrEqual.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerOrEqual.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerOrEqual.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerThan.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerThan.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerThan.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerThan.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerThan.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerThan.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerThan.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerThan.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerThan.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerThan.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerThan.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.LowerThan.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MaximumPrefNonNaN.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MaximumPrefNonNaN.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MaximumPrefNonNaN.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MaximumPrefNonNaN.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MaximumPrefNaN.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MaximumPrefNaN.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MaximumPrefNaN.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MaximumPrefNaN.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Maximum.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Maximum.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Maximum.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Maximum.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Maximum.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Maximum.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Maximum.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Maximum.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MinimumPrefNonNaN.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MinimumPrefNonNaN.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MinimumPrefNonNaN.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MinimumPrefNonNaN.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MinimumPrefNaN.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MinimumPrefNaN.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MinimumPrefNaN.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MinimumPrefNaN.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Minimum.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Minimum.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Minimum.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Minimum.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Minimum.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Minimum.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Minimum.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Minimum.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.UInt64Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.Int64Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.UInt32Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.Int32Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.UInt16Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.Int16Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.ByteSat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.SByteSat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Modulo.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.UInt64Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.Int64Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.UInt32Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.Int32Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.UInt16Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.Int16Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.ByteSat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.SByteSat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.MultiplyElem.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.UInt64Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.Int64Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.UInt32Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.Int32Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.UInt16Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.Int16Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.ByteSat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.SByteSat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Pow.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.UInt64Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.Int64Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.UInt32Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.Int32Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.UInt16Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.Int16Sat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.ByteSat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.SByteSat.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.Subtract.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.UnEqualTo.UInt64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.UnEqualTo.Int64.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.UnEqualTo.UInt32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.UnEqualTo.Int32.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.UnEqualTo.UInt16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.UnEqualTo.Int16.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.UnEqualTo.Byte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.UnEqualTo.SByte.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.UnEqualTo.FComplex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.UnEqualTo.Complex.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.UnEqualTo.Single.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.UnEqualTo.Double.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.InnerLoops.UnEqualTo.Bool.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*,System.Int64*)">
            <summary>
            Performs the inner loop for this binary operation.
            </summary>
            <param name="pOut">Pointer to base address of the output array, including any base offset.</param>
            <param name="pA">Pointer to the base address of input array A, including any base offset.</param>
            <param name="pB">Pointer to the base address of input array B, including any base offset.</param>
            <param name="start">Element index to start operation in this (thread) chunk.</param>
            <param name="len">Number of elements to process.</param>
            <param name="dims_strides"></param>
            <param name="numberTrues">[Output] stores the number of true values created in this chunk.</param>
            <remarks><para>dims_strides carries the BSD of the output array and the strides of A and B. 
            Dimensions may be reordered, strides include the element length scaling. All dims / strides are 
            of length dims_strides[0] exactly. outdims are actual (broadcasted) dims - 1! </para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.put``7(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},ILNumerics.BaseArray{``6},ILNumerics.InArray{``0},ILNumerics.PutModes)">
            <summary>
            Replaces elements of <paramref name="A"/> with <paramref name="values"/> at positions given by sequential (i.e.: flatten, row-major) <paramref name="indices"/>.
            </summary>
            <typeparam name="T1">Element type of <paramref name="A"/>.</typeparam>
            <typeparam name="LocalT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="InT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="OutT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="RetT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="StorageT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="IndT">Element type of indices. Must be numeric.</typeparam>
            <param name="A">The array storing the elements to be replaced.</param>
            <param name="indices">Index array. The shape is ignored. Values must be numeric and are read in row-major order.</param>
            <param name="values">Values array. The shape is ignored. Values are read in row-major order.</param>
            <param name="mode">[Optionl] Specifies how to handle index values in <paramref name="indices"/> which are out-of-range. Default: error.</param>
            <remarks>
            <para>This function has a similar effect as doing <c>A.flat[indices] = values</c> in numpy. However, in ILNumerics the iterator 
            returned from <c>A.flat</c> is read-only. Use <see cref="M:ILNumerics.Core.Functions.Builtin.numpyInternal.put``7(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},ILNumerics.BaseArray{``6},ILNumerics.InArray{``0},ILNumerics.PutModes)"/> as 
            a replacement.</para>
            <para>Note that the values in <paramref name="indices"/> are considered <i>sequential</i> indices, i.e. they correspond to the 
            element position in a flattened array, where the flattening is performed in row-major order. For performance reasons and if 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.StorageOrder"/> is not <see cref="F:ILNumerics.StorageOrders.RowMajor"/> A is converted to row-major 
            storage layout first and remains in row-major storage after the function returns. Note further, that the conversion happens 
            proactively, and is not rolled back in case of errors during the iteration.</para>
            <para>Elements of <paramref name="indices"/> can be negative, which corresponds to indexing from the end of flattened <paramref name="A"/>.</para>
            <para>Repeated values in <paramref name="indices"/> lead to only the last corresponding value in <paramref name="values"/> to be stored 
            at the respective position in <paramref name="A"/>.</para>
            <para>If <paramref name="values"/> has more elements than are indices provided in <paramref name="indices"/> superfluent values are ignored. No exception 
            is thrown in this case. If <paramref name="values"/> has fewer elements than indices are provided in <paramref name="indices"/> existing values 
            are repeated as necessary.</para>
            <para>The <paramref name="mode"/> parameter determines what happens with indices laying outside of the bounds of A. The default value
            of <see cref="F:ILNumerics.PutModes.Raise"/> throws an <see cref="T:System.IndexOutOfRangeException"/> in this case. Two other options exist which bring the
            index back into the valid range: <see cref="F:ILNumerics.PutModes.Wrap"/> computes the modulus, <see cref="F:ILNumerics.PutModes.Clip"/> limits the indices to the allowed range. 
            Note that negative indices behave as usual (counting from the end of A) for modes <see cref="F:ILNumerics.PutModes.Raise"/> and <see cref="F:ILNumerics.PutModes.Wrap"/> only.</para>
            <para><see cref="M:ILNumerics.Core.Functions.Builtin.numpyInternal.put``7(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},ILNumerics.BaseArray{``6},ILNumerics.InArray{``0},ILNumerics.PutModes)"/> requires 
            the element type of <paramref name="A"/> to be value types (struct, commonly numeric).</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="mode"/> is <see cref="F:ILNumerics.PutModes.Raise"/> and any element 
            in <paramref name="indices"/> is out of the allowed range of [-A.S.NumberOfElements...&gt;= A.<see cref="P:ILNumerics.Size.NumberOfElements"/>].</exception>
            <exception cref="T:System.ArgumentException">if either of <paramref name="indices"/> or <paramref name="values"/> is null, 
            if <paramref name="values"/> is empty but <paramref name="indices"/> is not, 
            if the specified <paramref name="mode"/> cannot successfully be applied (for example, because <paramref name="A"/> is empty).</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.put_1(System.Byte*,System.Int64,System.Collections.Generic.IEnumerator{System.Int64},System.Byte*,ILNumerics.Size,ILNumerics.PutModes)">
            <summary>
            Performs copy operation for numpy.put.
            </summary>
            <param name="pA">First element of A pointer. Base offset considered.</param>
            <param name="lenA">Number of elements of A.</param>
            <param name="indices">Indices iterator.</param>
            <param name="pV">Base pointer for values array. No base offset considered.</param>
            <param name="mode">How to handle out-of-range indices. See: <see cref="T:ILNumerics.PutModes"/>.</param>
            <param name="sizeV">Size descriptor for values array.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.put_16(ILNumerics.complex*,System.Int64,System.Collections.Generic.IEnumerator{System.Int64},ILNumerics.complex*,ILNumerics.Size,ILNumerics.PutModes)">
            <summary>
            Performs copy operation for numpy.put.
            </summary>
            <param name="pA">First element of A pointer. Base offset considered.</param>
            <param name="lenA">Number of elements of A.</param>
            <param name="indices">Indices iterator.</param>
            <param name="pV">Base pointer for values array. No base offset considered.</param>
            <param name="mode">How to handle out-of-range indices. See: <see cref="T:ILNumerics.PutModes"/>.</param>
            <param name="sizeV">Size descriptor for values array.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.put_8(System.UInt64*,System.Int64,System.Collections.Generic.IEnumerator{System.Int64},System.UInt64*,ILNumerics.Size,ILNumerics.PutModes)">
            <summary>
            Performs copy operation for numpy.put.
            </summary>
            <param name="pA">First element of A pointer. Base offset considered.</param>
            <param name="lenA">Number of elements of A.</param>
            <param name="indices">Indices iterator.</param>
            <param name="pV">Base pointer for values array. No base offset considered.</param>
            <param name="mode">How to handle out-of-range indices. See: <see cref="T:ILNumerics.PutModes"/>.</param>
            <param name="sizeV">Size descriptor for values array.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.put_4(System.UInt32*,System.Int64,System.Collections.Generic.IEnumerator{System.Int64},System.UInt32*,ILNumerics.Size,ILNumerics.PutModes)">
            <summary>
            Performs copy operation for numpy.put.
            </summary>
            <param name="pA">First element of A pointer. Base offset considered.</param>
            <param name="lenA">Number of elements of A.</param>
            <param name="indices">Indices iterator.</param>
            <param name="pV">Base pointer for values array. No base offset considered.</param>
            <param name="mode">How to handle out-of-range indices. See: <see cref="T:ILNumerics.PutModes"/>.</param>
            <param name="sizeV">Size descriptor for values array.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.put_2(System.UInt16*,System.Int64,System.Collections.Generic.IEnumerator{System.Int64},System.UInt16*,ILNumerics.Size,ILNumerics.PutModes)">
            <summary>
            Performs copy operation for numpy.put.
            </summary>
            <param name="pA">First element of A pointer. Base offset considered.</param>
            <param name="lenA">Number of elements of A.</param>
            <param name="indices">Indices iterator.</param>
            <param name="pV">Base pointer for values array. No base offset considered.</param>
            <param name="mode">How to handle out-of-range indices. See: <see cref="T:ILNumerics.PutModes"/>.</param>
            <param name="sizeV">Size descriptor for values array.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.repeat``7(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.BaseArray{``6},System.Nullable{System.UInt32})">
            <summary>
            Repeat elements along a flattened array or a specific axis.
            </summary>
            <typeparam name="T1">Element type of <paramref name="A"/>.</typeparam>
            <typeparam name="LocalT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="InT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="OutT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="RetT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="StorageT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="IndT">Element type of <paramref name="repeats"/>. Must be an integer type.</typeparam>
            <param name="A">The array storing the elements to be repeated.</param>
            <param name="repeats">Counts for element repetitions.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) flatten A and repeat all values along dimension #0.</param>
            <remarks>
            <para>This function repeats elements of <paramref name="A"/> along a single dimension. By default, where no <paramref name="axis"/> 
            is defined <paramref name="A"/> is reshaped to a vector in row-major order and all elements are repeated according to <paramref name="repeats"/>.
            Otherwise, if an <paramref name="axis"/> was specified, repetitions are performed along that dimension only. In this case, the array returned
            has the same shape as <paramref name="A"/>, except that the working dimension <paramref name="axis"/> is enlarged.</para>
            <para>The shape of <paramref name="repeats"/> is ignored. Its values give the counts for each element along the axis <paramref name="axis"/>. 
            Values must be numeric, positive integers and are read in row-major order. If <paramref name="repeats"/> has exactly one element 
            all elements along the working dimension of <paramref name="A"/> are repeated by the same number. Alternatively, the length of <paramref name="repeats"/> 
            must match A.S[axis] to specify individual repetition counts for each element along the working dimension. Thus, if <paramref name="axis"/> is 
            null (default) <paramref name="repeats"/> can be a scalar or an array with 'A.S.NumberOfElements == repeats.S.NumberOfElements'.</para>
            <para>This function returns a new array and does not alter <paramref name="A"/> or any input parameters.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"> if any of the <paramref name="A"/> or <paramref name="repeats"/> is null</exception>
            <exception cref="T:System.ArgumentException">
            if <paramref name="axis"/> points to a virtual dimension; 
            if <paramref name="repeats"/> is not a numeric array, is of a shape which is not broadcastable to the length of the working dimension or contains elements which are not convertible to positive integer values; 
            </exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same maximum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the minimum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same minimum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the minimum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same minimum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the minimum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same minimum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.numpyInternal.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the minimum of elements of <paramref name="A"/> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A"/> except that the 
            dimension specified by <paramref name="dim"/> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim"/> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim"/> is reduced to 1. If A.S[dim] == 0 the 
            <paramref name="dim"/>s dimension length in the array returned will also be 0.</para>
            <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
            <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If 
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
            <para>If the optional output parameter <paramref name="I"/> is not null on entry the function computes and returns the indices in <paramref name="A"/> of the 
            values returned. Thus, <paramref name="I"/> has the same shape as the return array. If the storage of <paramref name="I"/> on entry is sufficient 
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is 
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation 
            null can be provided as <paramref name="I"/> which is the default.</para>
            <para>If <paramref name="I"/> is requested and multiple elements along the working dimension in <paramref name="A"/> have the same minimum value it is undefined which 
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I"/> is undefined and may point to the first or any other occurrence of the 
            value returned from the working dimension.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim"/> was false.</exception>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.AccumulatingAllBase`12">
            <summary>
            Unary operator template for unary operations, no inplace. Output type may be different from the input type! (Anyall, Allall, Sumall)
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="LocalT2"></typeparam>
            <typeparam name="InT2"></typeparam>
            <typeparam name="OutT2"></typeparam>
            <typeparam name="RetT2"></typeparam>
            <typeparam name="StorageT2"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.AccumulatingAllBase`12.operate(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>
            General operator over elements of <paramref name="A"/>, not inplace. Potentially other output type.
            </summary>
            <param name="A">Input array.</param>
            <returns>New scalar array.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.AccumulatingAllBase`12.Strided(`5,`11)">
            <summary>
            Performs strided accumulation over a threaded chunk. 
            </summary>
            <param name="v1">Input storage</param>
            <param name="v2">Output storage, scalar.</param>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.ReduceOtherTypeBase`12">
            <summary>
            Accumulating operator template for reduction operations. No index retrieval. Potentially varying output types.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.ReduceOtherTypeBase`12.operate(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},System.Int32,System.Boolean)">
            <summary>
            Reduction operator over elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The dimension to operate along. This is expected to be a valid dimension index.</param>
            <returns>New logical array with the same size as <paramref name="A"/> except the dimension <paramref name="dim"/> which is reduced to 1 (even for empty A!).</returns>
            <remarks><para>The storage order of the array returned depends on the order of <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.ReduceOtherTypeBase`12.prepareBSDs(`5,`11,System.Int64**,System.Int64*@,System.Int64*@,System.UInt32,System.Boolean)">
            <summary>
            Prepares the BSDs of the output array and the working bsds for iteration. See Strided64() for the format specification.
            </summary>
            <param name="inStorage">Input storage.</param>
            <param name="outStorage">Output storage.</param>
            <param name="keepdim">Whether the new, reduced, singleton dimension is to be kept from the output. False: remove.</param>
            <param name="buffer">temp buffer with long elements for both temp. working BSDs.</param>
            <param name="inBSD">[Out] the working bsd for the input array.</param>
            <param name="outBSD">[Out] the working bsd for the output array.</param>
            <param name="dim">Index of the accumulating dimension.</param>
            <returns>Number of elements required for the output array.</returns>
            <remarks><para>This operator allows empty dimensions to be 'reduced' to a singleton dimension!</para></remarks>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.ReduceSameTypeBase`6">
            <summary>
            Accumulating operator template for reduction operations. No index retrieval. Potentially varying output types.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.ReduceSameTypeBase`6.operate(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},System.Int32,System.Boolean)">
            <summary>
            Reduction operator over elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The dimension to operate along. This is expected to be a valid dimension index.</param>
            <returns>New array with the same size as <paramref name="A"/> except dimension <paramref name="dim"/> which is reduced to min(1,A.S[dim]).</returns>
            <remarks><para>The storage order of the array returned depends on the order of <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.ReduceSameTypeBase`6.prepareBSDs(`5,`5,System.Int64**,System.Int64*@,System.Int64*@,System.UInt32,System.Boolean)">
            <summary>
            Prepares the BSDs of the output array and the working bsds for iteration. Working dim: outStorageBSD: min(1,A.S[dim]), in working BSD moved to END.
            </summary>
            <param name="inStorage">Input storage.</param>
            <param name="outStorage">Output storage.</param>
            <param name="keepdim">Whether the new, reduced, singleton dimension is to be kept from the output. False: remove.</param>
            <param name="buffer">temp buffer with long elements for both temp. working BSDs.</param>
            <param name="inBSD">[Out] the working bsd for the input array.</param>
            <param name="outBSD">[Out] the working bsd for the output array.</param>
            <param name="dim">Index of the accumulating dimension.</param>
            <returns>Number of elements required for the output array.</returns>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.ReduceSameTypeBaseIndices`6">
            <summary>
            Accumulating operator template for reduction operations. No index retrieval. Potentially varying output types.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.ReduceSameTypeBaseIndices`6.operate(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Reduction operator over elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="I">Output: indices of found values.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The dimension to operate along. This is expected to be a valid dimension index.</param>
            <returns>New array with the same size as <paramref name="A"/> except the dimension <paramref name="dim"/> which is reduced to min(1,A.S[dim]).</returns>
            <remarks><para>The storage order of the array returned depends on the order of <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.ReduceSameTypeBaseIndices`6.prepareBSDs(`5,`5,System.Int64**,System.Int64*@,System.Int64*@,System.Int64*@,System.UInt32,System.Boolean)">
            <summary>
            Prepares the BSDs of the output array and the working bsds for iteration. See Strided64() for the format specification.
            </summary>
            <param name="inStorage">Input storage.</param>
            <param name="outStorage">Output storage.</param>
            <param name="keepdim">Whether the new, reduced, singleton dimension is to be kept from the output. False: remove.</param>
            <param name="buffer">temp buffer with long elements for both temp. working BSDs.</param>
            <param name="inBSD">[Out] the working bsd for the input array.</param>
            <param name="outBSD">[Out] the working bsd for the output array.</param>
            <param name="outIdxBSD">[Out] the working bsd for the index output array (strides for 'long' elements).</param>
            <param name="dim">Index of the accumulating dimension.</param>
            <returns>Number of elements required for the output array.</returns>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.UnaryInplaceAxisBase`6">
            <summary>
            Accumulating operator template for reduction operations. No index retrieval. Potentially varying output types.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnaryInplaceAxisBase`6.operate(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},System.Int32)">
            <summary>
            Inplace unary along working axis operator over elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">The dimension to operate along. This is expected to be a valid dimension index.</param>
            <returns>New array with the same size as <paramref name="A"/>.</returns>
            <remarks><para>The storage order of the array returned depends on the order of <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>No new array is creatd. Elements of <paramref name="A"/> are altered inplace.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnaryInplaceAxisBase`6.prepareBSDs(`5,System.Int64**,System.Int64*@,System.UInt32)">
            <summary>
            Prepares the working bsd for iteration. Working dim in working bsd: FIRST dimension.
            </summary>
            <param name="inStorage">Input storage.</param>
            <param name="buffer">temp buffer with long elements for working BSD.</param>
            <param name="bsd">[Out] the working bsd for the in+output array. dims:-1, strides in bytes, working dim at #0.</param>
            <param name="dim">Index of the working dimension.</param>
            <returns>Number of elements except in working dimension.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnaryInplaceAxisBase`6.determineWorkDimLength(System.Int64)">
            <summary>
            Prototyp implementation (sort)
            </summary>
            <param name="v">length of input dimension[dim]</param>
            <returns><paramref name="v"/>.</returns>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.UnaryInplaceAxisIndicesBase`6">
            <summary>
            Accumulating operator template for reduction operations. No index retrieval. Potentially varying output types.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnaryInplaceAxisIndicesBase`6.operate(ILNumerics.Core.Arrays.Mutable{`0,`1,`2,`3,`4,`5},ILNumerics.Core.StorageLayer.Storage{System.Int64}@,System.Int32)">
            <summary>
            Inplace unary along working axis operator over elements of <paramref name="A"/>, maintaining indices.
            </summary>
            <param name="A">Input array.</param>
            <param name="indices">[Output] Storage of indices when returning.</param>
            <param name="dim">The dimension to operate along. This is expected to be a valid dimension index or 0.</param>
            <returns>New array with the same size as <paramref name="A"/>.</returns>
            <remarks><para>The storage order of the array returned depends on the order of <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>No new array is creatd. Elements of <paramref name="A"/> and <paramref name="indices"/> are altered inplace.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnaryInplaceAxisIndicesBase`6.prepareBSDs(`5,ILNumerics.Core.StorageLayer.Storage{System.Int64},System.Int64**,System.Int64*@,System.UInt32)">
            <summary>
            Prepares the working bsd for iteration. Working dim in working bsd: FIRST dimension.
            </summary>
            <param name="inStorage">Input storage.</param>
            <param name="indices">Storage for the indices, same shape as <paramref name="inStorage"/>, may has other strides though!</param>
            <param name="buffer">temp buffer with long elements for working BSD.</param>
            <param name="bsd">[Out] the working bsd for the in+output array. dims:-1, strides in bytes, working dim at #0.</param>
            <param name="dim">Index of the working dimension.</param>
            <returns>Number of elements except in working dimension.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnaryInplaceAxisIndicesBase`6.determineWorkDimLength(System.Int64)">
            <summary>
            Prototyp implementation (sort)
            </summary>
            <param name="v">length of input dimension[dim]</param>
            <returns><paramref name="v"/>.</returns>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.UnarySameTypeDiffBase`6">
            <summary>
            Accumulating operator template for reduction operations. No index retrieval. Potentially varying output types.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnarySameTypeDiffBase`6.operate(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},System.UInt32,System.Int32)">
            <summary>
            Reduction operator over elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="N">Order of differences to compute along dimension <paramref name="dim"/>.</param>
            <param name="dim">The dimension to operate along. This is expected to be a valid dimension index in range 0...A.S.NumberoOfDimensions - 1.</param>
            <returns>New array with the same size as <paramref name="A"/> except dimension <paramref name="dim"/> which is reduced to max(0,A.S[dim]-N).</returns>
            <remarks><para>The storage order of the array returned depends on the order of <paramref name="A"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para>
            <para>On <paramref name="N"/> being 0 A is returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnarySameTypeDiffBase`6.prepareBSDs(`5,`5,System.Int64**,System.Int64*@,System.Int64*@,System.UInt32)">
            <summary>
            Prepares the BSDs of the output array and the working bsds for iteration. Working dim outStorageBSD: same as input. in working bsds: FIRST dimension.
            </summary>
            <param name="inStorage">Input storage.</param>
            <param name="outStorage">Output storage.</param>
            <param name="buffer">temp buffer with long elements for both temp. working BSDs.</param>
            <param name="inBSD">[Out] the working bsd for the input array.</param>
            <param name="outBSD">[Out] the working bsd for the output array.</param>
            <param name="dim">Index of the accumulating dimension.</param>
            <returns>Number of elements required for the output array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnarySameTypeDiffBase`6.determineWorkDimLength(System.Int64)">
            <summary>
            Working length of diff() result.
            </summary>
            <param name="v">length of input dimension[dim]</param>
            <returns><paramref name="v"/>Math.Min(v-1, 0)</returns>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.UnarySameTypeSameSizeBase`6">
            <summary>
            Accumulating operator template for reduction operations. No index retrieval. Potentially varying output types.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnarySameTypeSameSizeBase`6.operate(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},System.Int32)">
            <summary>
            Reduction operator over elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <param name="dim">The dimension to operate along. This is expected to be a valid dimension index.</param>
            <returns>New array with the same size as <paramref name="A"/>.</returns>
            <remarks><para>The storage order of the array returned depends on the order of <paramref name="A"/>.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnarySameTypeSameSizeBase`6.prepareBSDs(`5,`5,System.Int64**,System.Int64*@,System.Int64*@,System.UInt32)">
            <summary>
            Prepares the BSDs of the output array and the working bsds for iteration. Working dim outStorageBSD: same as input. in working bsds: FIRST dimension.
            </summary>
            <param name="inStorage">Input storage.</param>
            <param name="outStorage">Output storage.</param>
            <param name="buffer">temp buffer with long elements for both temp. working BSDs.</param>
            <param name="inBSD">[Out] the working bsd for the input array.</param>
            <param name="outBSD">[Out] the working bsd for the output array.</param>
            <param name="dim">Index of the accumulating dimension.</param>
            <returns>Number of elements required for the output array.</returns>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnarySameTypeSameSizeBase`6.determineWorkDimLength(System.Int64)">
            <summary>
            Prototyp implementation (cumsum, cumprod)
            </summary>
            <param name="v">length of input dimension[dim]</param>
            <returns><paramref name="v"/>.</returns>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.BroadcastingBinaryBase`6">
            <summary>
            Base class for binary operator classes, handling two inputs and the same output type, potentially inplace: +,-,/,*,%
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.BroadcastingBinaryBase`6.Strided64(System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Int64*)">
            <summary>
            abstract declaration for strided worker functions
            </summary>
            <param name="pOut"></param>
            <param name="pA"></param>
            <param name="pB"></param>
            <param name="start"></param>
            <param name="len"></param>
            <param name="dims_strides"></param>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.BroadcastingBinaryGenericBase`7">
            <summary>
            Base class for binary operator classes, handling two inputs and the same output type, potentially inplace: +,-,/,*,%
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
            <typeparam name="DelegateT">Delegate type for the inner element function. Can be generic.</typeparam>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.BroadcastingBinaryMultiGenericBase_C_CS`19">
            <summary>
            <![CDATA[Base class for 'apply<,,>()' type operators.Implements all permutations for class/struct element types.]]>
            </summary>
            <typeparam name="Tin1"></typeparam>
            <typeparam name="LocalTin1"></typeparam>
            <typeparam name="InTin1"></typeparam>
            <typeparam name="OutTin1"></typeparam>
            <typeparam name="RetTin1"></typeparam>
            <typeparam name="StorageTin1"></typeparam>
            <typeparam name="Tin2"></typeparam>
            <typeparam name="LocalTin2"></typeparam>
            <typeparam name="InTin2"></typeparam>
            <typeparam name="OutTin2"></typeparam>
            <typeparam name="RetTin2"></typeparam>
            <typeparam name="StorageTin2"></typeparam>
            <typeparam name="Tout"></typeparam>
            <typeparam name="LocalTout"></typeparam>
            <typeparam name="InTout"></typeparam>
            <typeparam name="OutTout"></typeparam>
            <typeparam name="RetTout"></typeparam>
            <typeparam name="StorageTout"></typeparam>
            <typeparam name="DelegateT"></typeparam>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.BroadcastingBinaryMultiGenericBase_S_SS`19">
            <summary>
            <![CDATA[Base class for 'apply<,,>()' type operators.Implements all permutations for class/struct element types.]]>
            </summary>
            <typeparam name="Tin1"></typeparam>
            <typeparam name="LocalTin1"></typeparam>
            <typeparam name="InTin1"></typeparam>
            <typeparam name="OutTin1"></typeparam>
            <typeparam name="RetTin1"></typeparam>
            <typeparam name="StorageTin1"></typeparam>
            <typeparam name="Tin2"></typeparam>
            <typeparam name="LocalTin2"></typeparam>
            <typeparam name="InTin2"></typeparam>
            <typeparam name="OutTin2"></typeparam>
            <typeparam name="RetTin2"></typeparam>
            <typeparam name="StorageTin2"></typeparam>
            <typeparam name="Tout"></typeparam>
            <typeparam name="LocalTout"></typeparam>
            <typeparam name="InTout"></typeparam>
            <typeparam name="OutTout"></typeparam>
            <typeparam name="RetTout"></typeparam>
            <typeparam name="StorageTout"></typeparam>
            <typeparam name="DelegateT"></typeparam>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.BroadcastingBinaryMultiGenericBase_S_SC`19">
            <summary>
            <![CDATA[Base class for 'apply<,,>()' type operators.Implements all permutations for class/struct element types.]]>
            </summary>
            <typeparam name="Tin1"></typeparam>
            <typeparam name="LocalTin1"></typeparam>
            <typeparam name="InTin1"></typeparam>
            <typeparam name="OutTin1"></typeparam>
            <typeparam name="RetTin1"></typeparam>
            <typeparam name="StorageTin1"></typeparam>
            <typeparam name="Tin2"></typeparam>
            <typeparam name="LocalTin2"></typeparam>
            <typeparam name="InTin2"></typeparam>
            <typeparam name="OutTin2"></typeparam>
            <typeparam name="RetTin2"></typeparam>
            <typeparam name="StorageTin2"></typeparam>
            <typeparam name="Tout"></typeparam>
            <typeparam name="LocalTout"></typeparam>
            <typeparam name="InTout"></typeparam>
            <typeparam name="OutTout"></typeparam>
            <typeparam name="RetTout"></typeparam>
            <typeparam name="StorageTout"></typeparam>
            <typeparam name="DelegateT"></typeparam>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.BroadcastingBinaryMultiGenericBase_S_CS`19">
            <summary>
            <![CDATA[Base class for 'apply<,,>()' type operators.Implements all permutations for class/struct element types.]]>
            </summary>
            <typeparam name="Tin1"></typeparam>
            <typeparam name="LocalTin1"></typeparam>
            <typeparam name="InTin1"></typeparam>
            <typeparam name="OutTin1"></typeparam>
            <typeparam name="RetTin1"></typeparam>
            <typeparam name="StorageTin1"></typeparam>
            <typeparam name="Tin2"></typeparam>
            <typeparam name="LocalTin2"></typeparam>
            <typeparam name="InTin2"></typeparam>
            <typeparam name="OutTin2"></typeparam>
            <typeparam name="RetTin2"></typeparam>
            <typeparam name="StorageTin2"></typeparam>
            <typeparam name="Tout"></typeparam>
            <typeparam name="LocalTout"></typeparam>
            <typeparam name="InTout"></typeparam>
            <typeparam name="OutTout"></typeparam>
            <typeparam name="RetTout"></typeparam>
            <typeparam name="StorageTout"></typeparam>
            <typeparam name="DelegateT"></typeparam>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.BroadcastingBinaryMultiGenericBase_S_CC`19">
            <summary>
            <![CDATA[Base class for 'apply<,,>()' type operators.Implements all permutations for class/struct element types.]]>
            </summary>
            <typeparam name="Tin1"></typeparam>
            <typeparam name="LocalTin1"></typeparam>
            <typeparam name="InTin1"></typeparam>
            <typeparam name="OutTin1"></typeparam>
            <typeparam name="RetTin1"></typeparam>
            <typeparam name="StorageTin1"></typeparam>
            <typeparam name="Tin2"></typeparam>
            <typeparam name="LocalTin2"></typeparam>
            <typeparam name="InTin2"></typeparam>
            <typeparam name="OutTin2"></typeparam>
            <typeparam name="RetTin2"></typeparam>
            <typeparam name="StorageTin2"></typeparam>
            <typeparam name="Tout"></typeparam>
            <typeparam name="LocalTout"></typeparam>
            <typeparam name="InTout"></typeparam>
            <typeparam name="OutTout"></typeparam>
            <typeparam name="RetTout"></typeparam>
            <typeparam name="StorageTout"></typeparam>
            <typeparam name="DelegateT"></typeparam>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.BroadcastingBinaryMultiGenericBase_C_SS`19">
            <summary>
            <![CDATA[Base class for 'apply<,,>()' type operators.Implements all permutations for class/struct element types.]]>
            </summary>
            <typeparam name="Tin1"></typeparam>
            <typeparam name="LocalTin1"></typeparam>
            <typeparam name="InTin1"></typeparam>
            <typeparam name="OutTin1"></typeparam>
            <typeparam name="RetTin1"></typeparam>
            <typeparam name="StorageTin1"></typeparam>
            <typeparam name="Tin2"></typeparam>
            <typeparam name="LocalTin2"></typeparam>
            <typeparam name="InTin2"></typeparam>
            <typeparam name="OutTin2"></typeparam>
            <typeparam name="RetTin2"></typeparam>
            <typeparam name="StorageTin2"></typeparam>
            <typeparam name="Tout"></typeparam>
            <typeparam name="LocalTout"></typeparam>
            <typeparam name="InTout"></typeparam>
            <typeparam name="OutTout"></typeparam>
            <typeparam name="RetTout"></typeparam>
            <typeparam name="StorageTout"></typeparam>
            <typeparam name="DelegateT"></typeparam>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.BroadcastingBinaryMultiGenericBase_C_SC`19">
            <summary>
            <![CDATA[Base class for 'apply<,,>()' type operators.Implements all permutations for class/struct element types.]]>
            </summary>
            <typeparam name="Tin1"></typeparam>
            <typeparam name="LocalTin1"></typeparam>
            <typeparam name="InTin1"></typeparam>
            <typeparam name="OutTin1"></typeparam>
            <typeparam name="RetTin1"></typeparam>
            <typeparam name="StorageTin1"></typeparam>
            <typeparam name="Tin2"></typeparam>
            <typeparam name="LocalTin2"></typeparam>
            <typeparam name="InTin2"></typeparam>
            <typeparam name="OutTin2"></typeparam>
            <typeparam name="RetTin2"></typeparam>
            <typeparam name="StorageTin2"></typeparam>
            <typeparam name="Tout"></typeparam>
            <typeparam name="LocalTout"></typeparam>
            <typeparam name="InTout"></typeparam>
            <typeparam name="OutTout"></typeparam>
            <typeparam name="RetTout"></typeparam>
            <typeparam name="StorageTout"></typeparam>
            <typeparam name="DelegateT"></typeparam>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.BroadcastingBinaryMultiGenericBase_C_CC`19">
            <summary>
            <![CDATA[Base class for 'apply<,,>()' type operators.Implements all permutations for class/struct element types.]]>
            </summary>
            <typeparam name="Tin1"></typeparam>
            <typeparam name="LocalTin1"></typeparam>
            <typeparam name="InTin1"></typeparam>
            <typeparam name="OutTin1"></typeparam>
            <typeparam name="RetTin1"></typeparam>
            <typeparam name="StorageTin1"></typeparam>
            <typeparam name="Tin2"></typeparam>
            <typeparam name="LocalTin2"></typeparam>
            <typeparam name="InTin2"></typeparam>
            <typeparam name="OutTin2"></typeparam>
            <typeparam name="RetTin2"></typeparam>
            <typeparam name="StorageTin2"></typeparam>
            <typeparam name="Tout"></typeparam>
            <typeparam name="LocalTout"></typeparam>
            <typeparam name="InTout"></typeparam>
            <typeparam name="OutTout"></typeparam>
            <typeparam name="RetTout"></typeparam>
            <typeparam name="StorageTout"></typeparam>
            <typeparam name="DelegateT"></typeparam>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.BroadcastingOtherTypeBase`12">
            <summary>
            Base class for binary operator classes, handling two inputs and the same output type, potentially inplace: +,-,/,*,%
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="LocalT2"></typeparam>
            <typeparam name="InT2"></typeparam>
            <typeparam name="OutT2"></typeparam>
            <typeparam name="RetT2"></typeparam>
            <typeparam name="StorageT2"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.CopyToOperators.CopyTo(System.IntPtr,ILNumerics.Size,System.IntPtr,ILNumerics.Size,System.Nullable{ILNumerics.StorageOrders},System.UInt32)">
            <summary>
            Copy the data of this array to another memory region, specify element storage order for writing. 
            </summary>
            <param name="dest">Pointer to a memory region, large enough to store all elements of this array in the storage layout given by <paramref name="layout"/>.</param>
            <param name="outSize">[Output] On return the size descriptor holds the dimension lengths and strides according to the size of this array and the specified <paramref name="layout"/>.</param>
            <param name="layout">The storage order used to write the elements to <paramref name="dest"/>. If this is null on entry <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> is used.</param>
            <remarks><para><paramref name="outSize"/> can be <c>null</c> on entry in which case it will be ignored.</para>
            <para>If <paramref name="layout"/> is <c>null</c> or <see cref="F:ILNumerics.StorageOrders.Other"/> the storage layout of the array 
            returned will be automatically determined based on the current storage layout: copying from continous storages will keep 
            the source storage layout (column- or row major layout). Copying from non-continous storages will create storage as determined by <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>. </para>
            <para>If <paramref name="layout"/> is one of <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/> the 
            elements are stored into <paramref name="dest"/> with this layout.</para>
            <para>Make sure that the memory region addressed by <paramref name="dest"/> is large enough to hold at least all elements of 
            the region to be copied.</para>
            </remarks>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.UnaryBaseInPlace`6">
            <summary>
            Unary operator template for unary operations, potentially inplace. Output type is the same as the input type.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnaryBaseInPlace`6.operate(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>
            General operator over elements of <paramref name="A"/>.
            </summary>
            <param name="A">Input array.</param>
            <returns>New array with the same size as <paramref name="A"/> and with the result of the unary operation performed on all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/> and <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> 
            (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The input array <paramref name="A"/> is not altered.</para></remarks>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.UnaryBaseInPlaceOnly`6">
            <summary>
            Unary operator template for unary operations, always inplace.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnaryBaseInPlaceOnly`6.operate(ILNumerics.Core.Arrays.Mutable{`0,`1,`2,`3,`4,`5})">
            <summary>
            General operator over elements of <paramref name="A"/>, potentially inplace.
            </summary>
            <param name="A">Input array.</param>
            <returns>New array with the same size as <paramref name="A"/> and with the result of the unary operation performed on all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.UnaryBaseInPlaceParam3`9">
            <summary>
            Unary operator template for unary operations, potentially inplace. Output type is the same as the input type.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
            <typeparam name="Param1T"></typeparam>
            <typeparam name="Param2T"></typeparam>
            <typeparam name="Param3T"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnaryBaseInPlaceParam3`9.operate(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},`6,`7,`8)">
            <summary>
            General operator over elements of <paramref name="A"/>, potentially inplace.
            </summary>
            <param name="A">Input array.</param>
            <param name="p1">Parameter 1, scalar numeric primitive type.</param>
            <param name="p2">Parameter 2, scalar numeric primitive type.</param>
            <param name="p3">Parameter 3, scalar numeric primitive type.</param>
            <returns>New array with the same size as <paramref name="A"/> and with the result of the unary operation performed on all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnaryBaseInPlaceParam3`9.operateInternal(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},`6,`7,`8)">
            <summary>
            General operator over elements of <paramref name="A"/>, potentially inplace.
            </summary>
            <param name="A">Input array.</param>
            <param name="p1">Parameter 1, scalar numeric primitive type.</param>
            <param name="p2">Parameter 2, scalar numeric primitive type.</param>
            <param name="p3">Parameter 3, scalar numeric primitive type.</param>
            <returns>New array with the same size as <paramref name="A"/> and with the result of the unary operation performed on all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.UnaryBaseInPlaceParameterized2`6">
            <summary>
            Unary operator template for unary operations, potentially inplace. Output type is the same as the input type.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnaryBaseInPlaceParameterized2`6.operate(`5,`0,`0)">
            <summary>
            General operator over elements of <paramref name="storage"/>. Inplace operation.
            </summary>
            <param name="storage">Input storage.</param>
            <param name="v1">Additional parameter will end up in inner loops.</param>
            <param name="v2">Additional parameter will end up in inner loops.</param>
            <remarks><para>The operation is efficiently performed on all elements of the input storage <paramref name="storage"/>.</para>
            <para>The storage order of <paramref name="storage"/> is not changed.</para>
            <para>The storage is expected to be not shared with other arrays.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">If <paramref name="storage"/> or its memory is shared by more than one array.</exception>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.UnaryBaseOOPlaceParameter1`7">
            <summary>
            Unary operator template for unary operations, potentially inplace. 
            Output type is the same as the input type.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
            <typeparam name="ParamT">Parameter type (struct).</typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnaryBaseOOPlaceParameter1`7.operate(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},`6)">
            <summary>
            General operator over elements of <paramref name="A"/>, potentially inplace, 1 parameter.
            </summary>
            <param name="A">Input array.</param>
            <returns>New array with the same size as <paramref name="A"/> and with the result of the unary operation performed on all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.UnaryBaseOutOfPlace`12">
            <summary>
            Unary operator template for unary operations, no inplace. Output type is different from the input type.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="LocalT2"></typeparam>
            <typeparam name="InT2"></typeparam>
            <typeparam name="OutT2"></typeparam>
            <typeparam name="RetT2"></typeparam>
            <typeparam name="StorageT2"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnaryBaseOutOfPlace`12.operate(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})">
            <summary>
            General operator over elements of <paramref name="A"/>, potentially inplace.
            </summary>
            <param name="A">Input array.</param>
            <returns>New array with the same size as <paramref name="A"/> and with the result of the unary operation performed on all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            </remarks>
        </member>
        <member name="T:ILNumerics.Core.Functions.Builtin.UnaryBaseOutOfPlaceLogical`6">
            <summary>
            Unary operator template for unary operations, no inplace. Output type is different from the input type.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.UnaryBaseOutOfPlaceLogical`6.operate(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            General operator over elements of <paramref name="A"/>, potentially inplace.
            </summary>
            <param name="A">Input array.</param>
            <returns>New array with the same size as <paramref name="A"/> and with the result of the unary operation performed on all elements of <paramref name="A"/>.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="F:ILNumerics.Core.Functions.Builtin.WriteToOperators.times_main">
            <summary>
            0: entry function, 1: start work, 2: finished work, 3: finished waiting for workers, 4...3+n: started worker 0..(n-1)
            </summary>
        </member>
        <member name="F:ILNumerics.Core.Functions.Builtin.WriteToOperators.times_threads">
            <summary>
            0: number workers, [1: worker start, 2: worker end]... * (0..(n-1))
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToOperators.WriteTo_BSD``1(ILNumerics.Core.MemoryLayer.MemoryHandle,ILNumerics.Size,ILNumerics.Core.MemoryLayer.MemoryHandle,System.Int64*,System.UInt32,System.Boolean)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="outBSD">must be broadcastable from inSize! this is checked in SetRange_ML</param>
            <param name="inExpand">If this is called from Expand disables cells copy &amp; clone mechanism.</param>
            <param name="sizeofT">Element size in bytes.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToOperators.WriteTo_BSD_Gen(ILNumerics.Core.MemoryLayer.NativeHostHandle,ILNumerics.Size,ILNumerics.Core.MemoryLayer.NativeHostHandle,System.Int64*,System.UInt32)">
            <summary>
            Broadcasts elements from <paramref name="src"/> and <paramref name="inSize"/> and writes them to corresponding elements of <paramref name="dest"/> as addressed by <paramref name="outBSD"/>.
            </summary>
            <typeparam name="T">Element type. This is expected to be a reference type.</typeparam>
            <param name="src">Source memory handle.</param>
            <param name="inSize">Source array size.</param>
            <param name="dest">Destination memory handle.</param>
            <param name="outBSD">Destination BSD describing the range to be overwritten.</param>
            <remarks><paramref name="inSize"/> is broadcasted to <paramref name="outBSD"/> - not the other way around (unidirectional broadcasting).
            This function checks for argument sizes / shapes. It is provided for completeness and reference element types, since value (struct) element 
            types are handled by other overloads of this class more efficiently. However, this is not a technical restriction! Note, whatsoever, 
            that this function is not parallelized.</remarks>
            <exception cref="T:System.ArgumentException">if the input is not broadcastable to the destination shape.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToOperators.WriteTo_BSD_Ref``1(ILNumerics.Core.MemoryLayer.ManagedHostHandle{``0},ILNumerics.Size,ILNumerics.Core.MemoryLayer.ManagedHostHandle{``0},System.Int64*)">
            <summary>
            Broadcasts elements from <paramref name="src"/> and <paramref name="inSize"/> and writes them to corresponding elements of <paramref name="dest"/> as addressed by <paramref name="outBSD"/>.
            </summary>
            <typeparam name="T">Element type. This is expected to be a reference type.</typeparam>
            <param name="src">Source memory handle.</param>
            <param name="inSize">Source array size.</param>
            <param name="dest">Destination memory handle.</param>
            <param name="outBSD">Destination BSD describing the range to be overwritten.</param>
            <remarks><paramref name="inSize"/> is broadcasted to <paramref name="outBSD"/> - not the other way around (unidirectional broadcasting).
            This function checks for argument sizes / shapes. It is provided for completeness and reference element types, since value (struct) element 
            types are handled by other overloads of this class more efficiently. However, this is not a technical restriction! Note, whatsoever, 
            that this function is not parallelized.</remarks>
            <exception cref="T:System.ArgumentException">if the input is not broadcastable to the destination shape.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToOperators.WriteTo_BSD_Cell(ILNumerics.Core.MemoryLayer.ManagedHostHandle{ILNumerics.Core.StorageLayer.IStorage},ILNumerics.Size,ILNumerics.Core.MemoryLayer.ManagedHostHandle{ILNumerics.Core.StorageLayer.IStorage},System.Int64*)">
            <summary>
            Broadcasts elements from <paramref name="src"/> and <paramref name="inSize"/> and writes them to corresponding elements of <paramref name="dest"/> as addressed by <paramref name="outBSD"/>.
            </summary>
            <param name="src">Source memory handle.</param>
            <param name="inSize">Source array size.</param>
            <param name="dest">Destination memory handle.</param>
            <param name="outBSD">Destination BSD describing the range to be overwritten.</param>
            <remarks><paramref name="inSize"/> is broadcasted to <paramref name="outBSD"/> - not the other way around (unidirectional broadcasting).
            This function checks for argument sizes / shapes. It is provided for completeness and reference element types, since value (struct) element 
            types are handled by other overloads of this class more efficiently. However, this is not a technical restriction! Note, whatsoever, 
            that this function is not parallelized.</remarks>
            <exception cref="T:System.ArgumentException">if the input is not broadcastable to the destination shape.</exception>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToOperators.WriteTo_BSD_ML_2(System.IntPtr,ILNumerics.Size,System.IntPtr,System.Int64*)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting on the right side only.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="outBSD"></param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToOperators.WriteTo_BSD_ML_16(System.IntPtr,ILNumerics.Size,System.IntPtr,System.Int64*)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting on the right side only.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="outBSD"></param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToOperators.WriteTo_BSD_ML_8(System.IntPtr,ILNumerics.Size,System.IntPtr,System.Int64*)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting on the right side only.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="outBSD"></param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToOperators.WriteTo_BSD_ML_4(System.IntPtr,ILNumerics.Size,System.IntPtr,System.Int64*)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting on the right side only.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="outBSD"></param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToOperators.WriteTo_BSD_ML_1(System.IntPtr,ILNumerics.Size,System.IntPtr,System.Int64*)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting on the right side only.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="outBSD"></param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToBSDIterOperators.WriteTo_BSD_Iter``1(ILNumerics.Core.MemoryLayer.MemoryHandle,ILNumerics.Size,ILNumerics.Core.MemoryLayer.MemoryHandle,ILNumerics.Size,ILNumerics.IIndexIterator[],System.UInt32,System.UInt32,System.Int64)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="destSize"></param>
            <param name="iterators"></param>
            <param name="nrIterDims"></param>
            <param name="sizeofT">Element size in bytes.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToBSDIterOperators.WriteTo_BSD_Iter_2(System.IntPtr,ILNumerics.Size,System.IntPtr,ILNumerics.Size,ILNumerics.IIndexIterator[],System.UInt32,System.Int64)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting on the right side only.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="iterators">iterator objects for each dimension addressed.</param>
            <param name="nrIterDims">nr. of addressed dimensions in <paramref name="iterators"/></param>
            <param name="destSize">modified (ML: reshaped) BSD according to output storage.</param>
            <param name="lastDimIterStride">if positive, take this as the stride for <paramref name="dest"/> at 
            the last dimension provided by <paramref name="nrIterDims"/>. This is required for ML style only.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToBSDIterOperators.WriteTo_BSD_Iter_16(System.IntPtr,ILNumerics.Size,System.IntPtr,ILNumerics.Size,ILNumerics.IIndexIterator[],System.UInt32,System.Int64)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting on the right side only.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="iterators">iterator objects for each dimension addressed.</param>
            <param name="nrIterDims">nr. of addressed dimensions in <paramref name="iterators"/></param>
            <param name="destSize">modified (ML: reshaped) BSD according to output storage.</param>
            <param name="lastDimIterStride">if positive, take this as the stride for <paramref name="dest"/> at 
            the last dimension provided by <paramref name="nrIterDims"/>. This is required for ML style only.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToBSDIterOperators.WriteTo_BSD_Iter_8(System.IntPtr,ILNumerics.Size,System.IntPtr,ILNumerics.Size,ILNumerics.IIndexIterator[],System.UInt32,System.Int64)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting on the right side only.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="iterators">iterator objects for each dimension addressed.</param>
            <param name="nrIterDims">nr. of addressed dimensions in <paramref name="iterators"/></param>
            <param name="destSize">modified (ML: reshaped) BSD according to output storage.</param>
            <param name="lastDimIterStride">if positive, take this as the stride for <paramref name="dest"/> at 
            the last dimension provided by <paramref name="nrIterDims"/>. This is required for ML style only.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToBSDIterOperators.WriteTo_BSD_Iter_4(System.IntPtr,ILNumerics.Size,System.IntPtr,ILNumerics.Size,ILNumerics.IIndexIterator[],System.UInt32,System.Int64)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting on the right side only.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="iterators">iterator objects for each dimension addressed.</param>
            <param name="nrIterDims">nr. of addressed dimensions in <paramref name="iterators"/></param>
            <param name="destSize">modified (ML: reshaped) BSD according to output storage.</param>
            <param name="lastDimIterStride">if positive, take this as the stride for <paramref name="dest"/> at 
            the last dimension provided by <paramref name="nrIterDims"/>. This is required for ML style only.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToBSDIterOperators.WriteTo_BSD_Iter_1(System.IntPtr,ILNumerics.Size,System.IntPtr,ILNumerics.Size,ILNumerics.IIndexIterator[],System.UInt32,System.Int64)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting on the right side only.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="iterators">iterator objects for each dimension addressed.</param>
            <param name="nrIterDims">nr. of addressed dimensions in <paramref name="iterators"/></param>
            <param name="destSize">modified (ML: reshaped) BSD according to output storage.</param>
            <param name="lastDimIterStride">if positive, take this as the stride for <paramref name="dest"/> at 
            the last dimension provided by <paramref name="nrIterDims"/>. This is required for ML style only.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToBSDIterOperators.WriteTo_BSD_Iter_Gen(System.IntPtr,ILNumerics.Size,System.IntPtr,ILNumerics.Size,ILNumerics.IIndexIterator[],System.UInt32,System.Int64,System.UInt32)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting on the right side only.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="iterators">iterator objects for each dimension addressed.</param>
            <param name="nrIterDims">nr. of addressed dimensions in <paramref name="iterators"/></param>
            <param name="destSize">modified (ML: reshaped) BSD according to output storage.</param>
            <param name="lastDimIterStride">if positive, take this as the stride for <paramref name="dest"/> at 
            the last dimension provided by <paramref name="nrIterDims"/>. This is required for ML style only.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToBSDIterOperators.WriteTo_BSD_Iter_T``1(``0[],ILNumerics.Size,``0[],ILNumerics.Size,ILNumerics.IIndexIterator[],System.UInt32,System.Int64)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting on the right side only.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="iterators">iterator objects for each dimension addressed.</param>
            <param name="nrIterDims">nr. of addressed dimensions in <paramref name="iterators"/></param>
            <param name="destSize">modified (ML: reshaped) BSD according to output storage.</param>
            <param name="lastDimIterStride">if positive, take this as the stride for <paramref name="dest"/> at 
            the last dimension provided by <paramref name="nrIterDims"/>. This is required for ML style only.</param>
        </member>
        <member name="M:ILNumerics.Core.Functions.Builtin.WriteToBSDIterOperators.WriteTo_BSD_Iter_Cell(ILNumerics.Core.StorageLayer.IStorage[],ILNumerics.Size,ILNumerics.Core.StorageLayer.IStorage[],ILNumerics.Size,ILNumerics.IIndexIterator[],System.UInt32,System.Int64)">
            <summary>
            Write content of src as addressed by inSize to the subarray of dest as addressed by outSize. No reshape (Matlab). Supports broadcasting on the right side only.
            </summary>
            <param name="src"></param>
            <param name="inSize"></param>
            <param name="dest"></param>
            <param name="iterators">iterator objects for each dimension addressed.</param>
            <param name="nrIterDims">nr. of addressed dimensions in <paramref name="iterators"/></param>
            <param name="destSize">modified (ML: reshaped) BSD according to output storage.</param>
            <param name="lastDimIterStride">if positive, take this as the stride for <paramref name="dest"/> at 
            the last dimension provided by <paramref name="nrIterDims"/>. This is required for ML style only.</param>
        </member>
        <member name="T:ILNumerics.Core.Misc.BucketSort">
            <summary>
            Bucket sort algorithm (for internal use)
            </summary>
            <remarks>This class is not intended to be used directly. Sorting functionality is supplied by <see cref="M:ILMath.sort(InArray{double})"/></remarks>
        </member>
        <member name="T:ILNumerics.Core.Misc.BucketSort.SortMethod">
            <summary>
            Sort method for bucket sorts
            </summary>
        </member>
        <member name="F:ILNumerics.Core.Misc.BucketSort.SortMethod.ConstantLength">
            <summary>
            Constant length
            </summary>
        </member>
        <member name="F:ILNumerics.Core.Misc.BucketSort.SortMethod.VariableLenth">
            <summary>
            Variable length
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.BucketSort.BucketSortDo``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``2},ILNumerics.Core.Misc.KeyMapper{``0,``1},ILNumerics.Core.Misc.BucketSort.SortMethod)">
            <summary>
            Bucket sort algorithm 
            </summary>
            <param name="input"></param>
            <param name="indices">Return corresponding source element indices</param>
            <param name="mapper"></param>
            <param name="method"></param>
        </member>
        <member name="T:ILNumerics.Core.Misc.KeyMapper`2">
            <summary>
            Key mapper class, to be overriden for user defined classes to be sorted with bucket sort
            </summary>
            <typeparam name="ElementType">Type of elements. Elements are constructed out of any number of subelements</typeparam>
            <typeparam name="SubelementType">Type of subelements</typeparam>
            <remarks>This class can be extended to enable sorting (bucket sort) for arbitrary types. The elements of those types may be devidable into subelements.
            <para>Examples of sortable classes:
            <list>
            <item>colors: number/type of subelements: 1/any (e.g. the color code). One should write a <![CDATA[ILKeyMapper<Color,int>]]>.</item>
            <item>strings: number/type of subelements: arbitrary/char. Here a sample ILASCIKeyMapper implementation exists already. This implementation is the default implementation used for bucket sort via ILMath.sort().</item>
            <item>trees: number/type of subelements: arbitrary/tree nodes. One should write a key mapper to map a node of a tree to a bucket number</item>
            <item>...</item></list></para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.KeyMapper`2.Map(`1)">
            <summary>
            Maps subelement types to bucket index
            </summary>
            <param name="inSubelement">Item</param>
            <returns>Bucket index</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.KeyMapper`2.Map(`0,System.Int32,System.Int32)">
            <summary>
            Map subelemt - provide fallback on error
            </summary>
            <param name="element">Element item</param>
            <param name="position">Position of subelement in element item to be mapped</param>
            <param name="fallback">If position is out of range, give back fallback</param>
            <returns>Mapped bucket for subelement or fallback on error</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.KeyMapper`2.SubelementsCount(`0)">
            <summary>
            Count subelements in an element
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.KeyMapper`2.GetSubelement(`0,System.Int32)">
            <summary>
            Get subelement from element item
            </summary>
            <param name="element">Element item</param>
            <param name="idx">Position of subitem in element</param>
            <returns>Subitem referenced</returns>
        </member>
        <member name="P:ILNumerics.Core.Misc.KeyMapper`2.NumberOfKeys">
            <summary>
            Maximum number of keys (different subitems)
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.KeyMapper`2.#ctor(System.Int32)">
            <summary>
            Construct key mapper
            </summary>
            <param name="NumberOfKeys">Maximm number of different subitems (keys)</param>
        </member>
        <member name="T:ILNumerics.Core.Misc.ASCIIKeyMapper">
            <summary>
            Concrete implementation of a key mapper for strings
            </summary>
            <remarks>this class is the default key mapper, used for bucket sort on strings</remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.ASCIIKeyMapper.Map(System.Char)">
            <summary>
            map subelement to bucket 
            </summary>
            <param name="inSubelement">subelement to be mapped</param>
            <returns>ASCII code of the subelement character</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.ASCIIKeyMapper.Map(System.String,System.Int32,System.Int32)">
            <summary>
            Map char out of string with fallback
            </summary>
            <param name="element">full string item</param>
            <param name="position">position of character in string</param>
            <param name="fallback">fallback bucket number, if position is out of range</param>
            <returns>ASCII code for character specified, fallback on error</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.ASCIIKeyMapper.GetSubelement(System.String,System.Int32)">
            <summary>
            give one char from string
            </summary>
            <param name="element">full string item</param>
            <param name="idx">character position in string</param>
            <returns>character in string</returns>
            <exception cref="T:System.IndexOutOfRangeException"> if idx is not within element ranges</exception>
        </member>
        <member name="M:ILNumerics.Core.Misc.ASCIIKeyMapper.SubelementsCount(System.String)">
            <summary>
            Count numer of characters in string
            </summary>
            <param name="element">element item</param>
            <returns>number of characters in string - length of string</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.ASCIIKeyMapper.#ctor">
            <summary>
            construct ASCII key mapper for 256 buckets
            </summary>
        </member>
        <member name="T:ILNumerics.Core.Misc.IntLimitedKeyMapper">
            <summary>
            Integer key mapper - sample implementation for bucket sort
            </summary>
            <remarks>This mapper may be used for sorting integers with bucketsort. 
            <para>The integers to be sorted must be positive and limited. It corresponds to the number of buckets to be created.</para>
            <para>This implementation serves as a sample implementation for bucket sort. You should consider using quicksort instead, which is implemented for ILMath.sort()</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.IntLimitedKeyMapper.GetSubelement(System.Int32,System.Int32)">
            <summary>
            Gives subelement - i.e. the element itself
            </summary>
            <param name="element">element</param>
            <param name="idx">(ignored)</param>
            <returns>element</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.IntLimitedKeyMapper.Map(System.Int32,System.Int32,System.Int32)">
            <summary>
            map element - ignoring position &amp; fallback
            </summary>
            <param name="element">integer element</param>
            <param name="position">(ignored)</param>
            <param name="fallback">(ignored)</param>
            <returns>integer element</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.IntLimitedKeyMapper.Map(System.Int32)">
            <summary>
            map (copy) subelement
            </summary>
            <param name="inSubelement">subelement</param>
            <returns>subelement</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.IntLimitedKeyMapper.SubelementsCount(System.Int32)">
            <summary>
            number of subelements in an element (Here: always 1)
            </summary>
            <param name="element">element</param>
            <returns>1</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.IntLimitedKeyMapper.#ctor(System.Int32)">
            <summary>
            construct integer key mapper
            </summary>
            <param name="limit">maximum number of buckets to be used</param>
        </member>
        <member name="T:ILNumerics.Core.Misc.QSChunkDefinition">
            <summary>
            This is used to store chunks left over from intermediate quick sort passes. 
            </summary>
        </member>
        <member name="T:ILNumerics.Core.Misc.ListItem`2">
            <summary>
            List items to be used in ILQueueList
            </summary>
            <typeparam name="T1">Data type</typeparam>
            <typeparam name="T2">Index type</typeparam>
            <remarks>This class is not intended to be used directly. Internally it serves as a helper class for sorting.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.ListItem`2.#ctor(`0)">
            <summary>
            construct list item by data
            </summary>
            <param name="item">item data</param>
            <remarks>the indet will be set to its default value</remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.ListItem`2.#ctor(`0,`1)">
            <summary>
            construct list item, takes item data and index
            </summary>
            <param name="item">item data</param>
            <param name="index">index</param>
        </member>
        <member name="P:ILNumerics.Core.Misc.ListItem`2.Index">
            <summary>
            index stored with this item
            </summary>
        </member>
        <member name="T:ILNumerics.Core.Misc.QueueList`2">
            <summary>
            Queuelist - a queue with partial list properties 
            </summary>
            <typeparam name="T1">data type</typeparam>
            <typeparam name="T2">index type</typeparam>
            <remarks>This class is not intended to be used directly. Internally it serves as a helper class for sorting.</remarks>
        </member>
        <member name="P:ILNumerics.Core.Misc.QueueList`2.Count">
            <summary>
            number of items currently in the queue (readonly)
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.QueueList`2.Enqueue(`0,`1)">
            <summary>
            add indexed item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.QueueList`2.Enqueue(`0)">
            <summary>
            add item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.QueueList`2.Enqueue(ILNumerics.Core.Misc.ListItem{`0,`1})">
            <summary>
            add item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.QueueList`2.Enqueue(ILNumerics.Core.Misc.QueueList{`0,`1})">
            <summary>
            add queue list to end of this queue list
            </summary>
            <param name="list">queue list to be added</param>
        </member>
        <member name="M:ILNumerics.Core.Misc.QueueList`2.Dequeue">
            <summary>
            Remove from start of queue
            </summary>
            <returns>item from start of queue</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QueueList`2.AddToStart(`0)">
            <summary>
            Add to start of queue
            </summary>
            <param name="item">item data to add to start of queue</param>
        </member>
        <member name="M:ILNumerics.Core.Misc.QueueList`2.AddToStart(ILNumerics.Core.Misc.QueueList{`0,`1})">
            <summary>
            concatenate 2 queuelists
            </summary>
            <param name="qlist">queue list to be added at start of this queuelist</param>
        </member>
        <member name="M:ILNumerics.Core.Misc.QueueList`2.Sort``1(ILNumerics.Core.Misc.KeyMapper{`0,``0})">
            <summary>
            sort utilizing bucket sort
            </summary>
            <typeparam name="SubelementType">subelement type</typeparam>
            <param name="mapper">keymapper mapping subelement items to buckets</param>
        </member>
        <member name="M:ILNumerics.Core.Misc.QueueList`2.ToArray">
            <summary>
            convert (copy) items to system array
            </summary>
            <returns>system array with items</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QueueList`2.Clear">
            <summary>
            Clear this queue list from all elements 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.QueueList`2.GetEnumerator">
            <summary>
            Create enumerator utilizing 'foreach'
            </summary>
            <returns>enumerator for contained elements</returns>
        </member>
        <member name="P:ILNumerics.Core.Misc.QueueList`2.ListItems">
            <summary>
            Gives enumerator for contained items (ILListItem)
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.QueueList`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            gives enumerator for internal list items (ILListItem)
            </summary>
            <returns>ILListItem's</returns>
        </member>
        <member name="T:ILNumerics.Core.Misc.QuickSort">
            <summary>
            the class provides a number of one dimensional quicksort implementations for several datatypes/ properties
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscST(System.Double*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescST(System.Double*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscIDXST(System.Double*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescIDXST(System.Double*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscST(System.UInt64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescST(System.UInt64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscIDXST(System.UInt64*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescIDXST(System.UInt64*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscST(System.UInt32*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescST(System.UInt32*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscIDXST(System.UInt32*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescIDXST(System.UInt32*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscST(System.UInt16*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescST(System.UInt16*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscIDXST(System.UInt16*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescIDXST(System.UInt16*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscST(System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescST(System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscIDXST(System.Int64*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescIDXST(System.Int64*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscST(System.Int32*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescST(System.Int32*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscIDXST(System.Int32*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescIDXST(System.Int32*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscST(System.Int16*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescST(System.Int16*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscIDXST(System.Int16*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescIDXST(System.Int16*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscST(System.Single*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescST(System.Single*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscIDXST(System.Single*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescIDXST(System.Single*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscST(ILNumerics.fcomplex*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescST(ILNumerics.fcomplex*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscIDXST(ILNumerics.fcomplex*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescIDXST(ILNumerics.fcomplex*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscST(ILNumerics.complex*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescST(ILNumerics.complex*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscIDXST(ILNumerics.complex*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescIDXST(ILNumerics.complex*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscST(System.Char*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescST(System.Char*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscIDXST(System.Char*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescIDXST(System.Char*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscST(System.Byte*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescST(System.Byte*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscIDXST(System.Byte*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescIDXST(System.Byte*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscST(System.SByte*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescST(System.SByte*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortAscIDXST(System.SByte*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, ascending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.QuickSortDescIDXST(System.SByte*,System.Int64*,System.Int64,System.Int64,System.Int64)">
            <summary>
            One dimensional quick sort, inline, descending, arbitrary element spacing, indices aware.
            </summary>
            <param name="vec">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="vecIdx">indices vector, content will in-place be sorted along with <paramref name="vec"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNIDXAsc(System.Int64,System.Int64@,System.Int64,System.Int64*,System.Double*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNIDXDesc(System.Int64,System.Int64@,System.Int64,System.Int64*,System.Double*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNAsc(System.Int64,System.Int64@,System.Int64,System.Double*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNDesc(System.Int64,System.Int64@,System.Int64,System.Double*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNIDXAsc(System.Int64,System.Int64@,System.Int64,System.Int64*,System.Single*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNIDXDesc(System.Int64,System.Int64@,System.Int64,System.Int64*,System.Single*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNAsc(System.Int64,System.Int64@,System.Int64,System.Single*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNDesc(System.Int64,System.Int64@,System.Int64,System.Single*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNIDXAsc(System.Int64,System.Int64@,System.Int64,System.Int64*,ILNumerics.fcomplex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNIDXDesc(System.Int64,System.Int64@,System.Int64,System.Int64*,ILNumerics.fcomplex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNAsc(System.Int64,System.Int64@,System.Int64,ILNumerics.fcomplex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNDesc(System.Int64,System.Int64@,System.Int64,ILNumerics.fcomplex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNIDXAsc(System.Int64,System.Int64@,System.Int64,System.Int64*,ILNumerics.complex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNIDXDesc(System.Int64,System.Int64@,System.Int64,System.Int64*,ILNumerics.complex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNAsc(System.Int64,System.Int64@,System.Int64,ILNumerics.complex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.QuickSort.checkNaNDesc(System.Int64,System.Int64@,System.Int64,ILNumerics.complex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="T:ILNumerics.Core.Misc.QuickSortThreadingContext">
            <summary>
            This class provides a thread local set of helper data and is used by individual threads of the QuickSort algorithms.
            </summary>
        </member>
        <member name="T:ILNumerics.Core.Misc.ArrayVisualizerProxy">
            <summary>
            ILNumerics Visual Studio Array Visualizer Helper (do not use this class directly)
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.ArrayVisualizerProxy.CanVisualize">
            <summary>
            (not used)
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.ArrayVisualizerProxy.Size">
            <summary>
            The size of the array expression this proxy represents
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.ArrayVisualizerProxy.Address">
            <summary>
            The physical address of the storage array for the result. For managed arrays the _current_, unpinned address on the managed heap.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.ArrayVisualizerProxy.SystemArray">
            <summary>
            Property exposing the underlying System.Array for the expression result 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.ArrayVisualizerProxy.ElementType">
            <summary>
            String representation of the element types of the result
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.ArrayVisualizerProxy.Is64BitProcess">
            <summary>
            Helper for Array Visualizer process bitrate detection. This eases the determiniation of the appropriate memory read attempt during evaluations of array expressions in Visual Studio debug sessions. 
            </summary>
            <remarks>The reason why this has been (re)included is that it makes the info available at a point 
            where using the expression evaluator to query "Environment.Is64BitProcess" directly would be more demanding.</remarks>
        </member>
        <member name="P:ILNumerics.Core.Misc.ArrayVisualizerProxy.SourceType">
            <summary>
            string representation of the (array) type of the original expression result 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.ArrayVisualizerProxy.#ctor(System.Array,ILNumerics.Size,System.String)">
            <summary>
            Create a new proxy representing an Array vor visualizing in ILNumerics Array Visualizer
            </summary>
            <param name="array">the system array</param>
            <param name="size">the final n-dim array size</param>
            <param name="elementType">the name of the elements type</param>
        </member>
        <member name="M:ILNumerics.Core.Misc.ArrayVisualizerProxy.#ctor(System.UInt64,ILNumerics.Size,System.String)">
            <summary>
            Create a new proxy representing an Array for visualizing in ILNumerics Array Visualizer
            </summary>
            <param name="address">a pointer to array memory</param>
            <param name="size">the final n-dim array size</param>
            <param name="elementType">the name of the elements type</param>
        </member>
        <member name="M:ILNumerics.Core.Misc.ArrayVisualizerProxy.Create``1(ILNumerics.BaseArray{``0})">
            <summary>
            Create a new proxy for an existing ILNumerics array (of any kind)
            </summary>
            <typeparam name="T">The element type of the Array</typeparam>
            <param name="A">The n-dim Array to create a new proxy for</param>
            <returns>Array proxy</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.ArrayVisualizerProxy.Create(System.Array)">
            <summary>
            Create a new proxy for an existing Array (of any kind). Overload
            </summary>        
            <param name="A">The n-dim Array to create a new proxy for</param>
            <returns>Array proxy</returns>
        </member>
        <member name="M:ILNumerics.Core.Misc.ArrayVisualizerProxy.Create(System.ValueType)">
            <summary>
            Creates a new proxy for an existing scalar.
            </summary>        
        </member>
        <member name="T:ILNumerics.Core.Misc.CSVLinesProvider`1">
            <summary>
            Class to hide Stream / String passed behavior for reading CSV lines iteratively.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.CSVLinesProvider`1.GetNextLine(System.String@)">
            <summary>
            Gets the next line with hiding its origin.
            If it is null, the text is reached the end.
            </summary>
            <returns>Next trimmed line.</returns>
        </member>
        <member name="P:ILNumerics.Core.Misc.ThreadingContext`6.MultidimIterators">
            <summary>
            Thread local itarator array for np advanced indexing. Length <see cref="F:ILNumerics.Size.MaxNumberOfDimensions"/> + 1 (space for reordering).
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.ThreadingContext`6.TmpBuffer1000">
            <summary>
            Temp buffer of 1000 long elements. Used for numpy advanced indexing and others. Not for users use. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.ThreadingContext`6.GetStorage">
            <summary>
            Provide an uninitialized storage instance efficiently.
            </summary>
            <returns>Freely available storage object.</returns>
        </member>
        <member name="T:ILNumerics.Core.Misc.WMIInfo">
            <summary>
            Initializes a new instance of the ILWMIInfo class.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIInfo.RamInstalledBytes">
            <summary>
            Gets the total number of bytes RAM installed on the system. This is computed based on WMI. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIInfo.Processors">
            <summary>
            Returns a list of all available installed processors in system.
            </summary>
        </member>
        <member name="T:ILNumerics.Core.Misc.WMIProcessor">
            <summary>
            A maintenance object providing a comprehensive set of WMI (Windows Management Interface) information about the current system.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.WMIProcessor.#ctor(System.String,System.Int32)">
            <summary>
            Constructor defines the ILWMIProcessor.
            </summary>
            <param name="path">Setes the path of management object.</param>
            <param name="numberOfCores">Sets the number of cores.</param>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.AddressWidth">
            <summary>
            Processor address width in bits.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.Architecture">
            <summary>
            The Architecture property specifies the processor architecture used by this platform. 
            It returns one of the following integer values: 0 - x86, 1 - MIPS, 2 - Alpha, 3 - PowerPC, 6 - ia64, 9 - x64
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.Availability">
            <summary>
            The availability and status of the device.  For example, the Availability property indicates that the device is running and has full power (value=3), or is in a warning (4), test (5), degraded (10) or power save state (values 13-15 and 17). Regarding the power saving states, these are defined as follows: Value 13 ("Power Save - Unknown") indicates that the device is known to be in a power save mode, but its exact status in this mode is unknown; 14 ("Power Save - Low Power Mode") indicates that the device is in a power save state but still functioning, and may exhibit degraded performance; 15 ("Power Save - Standby") describes that the device is not functioning but could be brought to full power 'quickly'; and value 17 ("Power Save - Warning") indicates that the device is in a warning state, though also in a power save mode.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.Caption">
            <summary>
            The Caption property is a short textual description (one-line string) of the object.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.ConfigManagerErrorCode">
             <summary>
             Indicates the Win32 Configuration Manager error code. See remarks for a list of available values.
             </summary>
             <remarks> The following values may be returned: <list type="bullet">
            <item>0      This device is working properly.</item>
            <item>1      This device is not configured correctly.</item>
            <item>2      Windows cannot load the driver for this device.</item>
            <item>3      The driver for this device might be corrupted, or your system may be running low on memory or other resources. </item>
            <item>4      This device is not working properly.One of its drivers or your registry might be corrupted. </item>
            <item>5      The driver for this device needs a resource that Windows cannot manage. </item>
            <item>6      The boot configuration for this device conflicts with other devices.</item>
            <item>7      Cannot filter. </item>
            <item>8      The driver loader for the device is missing.</item>
            <item>9      This device is not working properly because the controlling firmware is reporting the resources for the device incorrectly.</item>
            <item>10     This device cannot start. </item>
            <item>11     This device failed.</item>
            <item>12     This device cannot find enough free resources that it can use.</item>
            <item>13     Windows cannot verify this device's resources. </item>
            <item>14     This device cannot work properly until you restart your computer. </item>
            <item>15     This device is not working properly because there is probably a re-enumeration problem. </item>
            <item>16     Windows cannot identify all the resources this device uses. </item>
            <item>17     This device is asking for an unknown resource type. </item>
            <item>18     Reinstall the drivers for this device.</item>
            <item>19     Your registry might be corrupted.</item>
            <item>20     Failure using the VxD loader.</item>
            <item>21     System failure: Try changing the driver for this device.If that does not work, see your hardware documentation. Windows is removing this device.</item>
            <item>22     This device is disabled.</item>
            <item>23     System failure: Try changing the driver for this device.If that doesn't work, see your hardware documentation. </item>
            <item>24     This device is not present, is not working properly, or does not have all its drivers installed. </item>
            <item>25     Windows is still setting up this device.</item>
            <item>26     Windows is still setting up this device.</item>
            <item>27     This device does not have valid log configuration. </item>
            <item>28     The drivers for this device are not installed. </item>
            <item>29     This device is disabled because the firmware of the device did not give it the required resources. </item>
            <item>30     This device is using an Interrupt Request(IRQ) resource that another device is using. </item>
            <item>31     This device is not working properly because Windows cannot load the drivers required for this device.</item></list>
             </remarks>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.ConfigManagerUserConfig">
            <summary>
            Indicates whether the device is using a user-defined configuration.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.CPUStatus">
            <summary>
            The CpuStatus property specifies the current status of the processor. Changes in status arise from processor usage, not the physical condition of the processor.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.CurrentClockSpeed">
            <summary>
            The current speed (in MHz) of this processor.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.CurrentVoltage">
            <summary>
            The CurrentVoltage specifies the voltage of the processor. 
            </summary>
            <remarks>bits 0-6 of the field contain the processor's current voltage times 10. This value is only set when SMBIOS designates a voltage value. For specific values, see VoltageCaps.
            <para>Example: field value for a processor voltage of 1.8 volts would be 92h = 80h + (1.8 x 10) = 80h + 18 = 80h + 12h.</para></remarks>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.DataWidth">
            <summary>
            Processor data width in bits.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.Description">
            <summary>
            The Description property provides a textual description of the WMI object.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.DeviceID">
            <summary>
            The DeviceID property contains a string uniquely identifying the processor with other devices on the system.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.Family">
            <summary>
            The processor family type. For example, values include "Pentium(R) processor with MMX(TM) technology" (14) and "68040" (96).
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.InstallDate">
            <summary>
            The InstallDate property is datetime value indicating when the object was installed. A lack of a value does not indicate that the object is not installed.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.L2CacheSize">
            <summary>
            The L2CacheSize property specifies the size of the processor's Level 2 cache. A Level 2 cache is an external memory area that has a faster access times than the main RAM memory.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.L3CacheSize">
            <summary>
            The L3CacheSize property specifies the size of the processor's Level 3 cache in kilo bytes. A Level 3 cache is an external memory area that has a faster access times than the main RAM memory.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.Level">
            <summary>
            The Level property further defines the processor type. The value  depends on the architecture of the processor.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.Manufacturer">
            <summary>
            The Manufacturer property specifies the name of the processor's manufacturer. Example: GenuineSilicon.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.MaxClockSpeed">
            <summary>
            The maximum speed (in MHz) of this processor.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.Name">
            <summary>
            The Name property defines the label by which the object is known. When subclassed, the Name property can be overridden to be a Key property.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.NumberOfCores">
            <summary>
            The NumberOfCores property contains a Processor's total number of cores. e.g dual core machine will have NumberOfCores = 2.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.NumberOfLogicalProcessors">
            <summary>
            The NumberOfLogicalProcessors property specifies the total number of logical processors. This typically corresponds to "System.Environment.ProcessorCount".
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.OtherFamilyDescription">
            <summary>
            A string describing the processor family type - used when the family property is set to 1 ("Other"). This string should be set to NULL when the family property is any value other than 1.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.PNPDeviceID">
            <summary>
            Indicates the Win32 Plug and Play device ID of the logical device.  Example: *PNP030b.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.PowerManagementSupported">
            <summary>
            Boolean indicating that the Device can be power managed - ie, put into a power save state. This boolean does not indicate that power management features are currently enabled, or if enabled, what features are supported. Refer to the PowerManagementCapabilities array for this information. If this boolean is false, the integer value 1, for the string, "Not Supported", should be the only entry in the PowerManagementCapabilities array.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.ProcessorId">
            <summary>
            The ProcessorId property contains processor-specific information that describes the processor's features. For x86 class CPUs, the field's format depends on the processor's support of the CPUID instruction. If the instruction is supported, the ProcessorId property contains two DWORD-formatted values. The first (offsets 08h-0Bh) is the EAX value returned by a CPUID instruction with input EAX set to 1. The second (offsets 0Ch-0Fh) is the EDX value returned by that instruction. Only the first two bytes of the ProcessorID property are significant (all others are set to 0) and contain (in WORD-format) the contents of the DX register at CPU reset.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.ProcessorType">
            <summary>
            The ProcessorType property specifies the processor's primary function.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.Revision">
            <summary>
            The Revision property specifies the system's architecture-dependent revision level. The meaning of this value depends on the architecture of the processor. It contains the same values as the "Version" member, but in a numerical format.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.Role">
            <summary>
            A free form string describing the role of the processor - for example, "Central Processor"' or "Math Processor".
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.SecondLevelAddressTranslationExtensions">
            <summary>
            The SecondLevelAddressTranslationExtensions property determines whether the processor supports address translation extensions used for virtualization.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.SocketDesignation">
            <summary>
            The SocketDesignation property contains the type of chip socket used on the circuit. Example: J202.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.Status">
            <summary>
            The Status property is a string indicating the current status of the object. Various operational and non-operational statuses can be defined. Operational statuses are "OK", "Degraded" and "Pred Fail". "Pred Fail" indicates that an element may be functioning properly but predicting a failure in the near future. An example is a SMART-enabled hard drive. Non-operational statuses can also be specified. These are "Error", "Starting", "Stopping" and "Service". The latter, "Service", could apply during mirror-resilvering of a disk, reload of a user permissions list, or other administrative work. Not all such work is on-line, yet the managed element is neither "OK" nor in one of the other states.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.StatusInfo">
            <summary>
            StatusInfo is a string indicating whether the logical device is in an enabled (value = 3), disabled (value = 4) or some other (1) or unknown (2) state. If this property does not apply to the logical device, the value, 5 ("Not Applicable"), should be used.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.Stepping">
            <summary>
            Stepping is a free-form string indicating the revision level of the processor within the processor family.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.SystemName">
            <summary>
            The System's Name where this processor is installed on.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.UniqueId">
            <summary>
            A globally unique identifier for the processor.  This identifier may only be unique within a processor family.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.UpgradeMethod">
            <summary>
            CPU socket information including data on how this Processor can be upgraded (if upgrades are supported). This property is an integer enumeration.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.Version">
            <summary>
            The Version property specifies an architecture-dependent processor revision number. Note: This member is not used in Windows 95. Example: Model 2, Stepping 12.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.VirtualizationFirmwareEnabled">
            <summary>
            The VirtualizationFirmwareEnabled property determines whether the Firmware has enabled virtualization extensions.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.VMMonitorModeExtensions">
            <summary>
            The VMMonitorModeExtensions property determines whether the processor supports Intel or AMD Virtual Machine Monitor extensions.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Misc.WMIProcessor.VoltageCaps">
            <summary>
            The VoltageCaps property specifies the voltage capabilities of the processor. Bits 0-3 of the field represent specific voltages that the processor socket can accept. All other bits should be set to zero. The socket is configurable if multiple bits are being set. For a range of voltages see CurrentVoltage. If the property is NULL, then the voltage capabilities are unknown.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.WMIProcessor.initAll">
            <summary>
            Method initializes all properties of ILWMIProcessor object.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Misc.WMIProcessor.Finalize">
            <summary>
            ILWMIProcessor object destructor.
            </summary>
        </member>
        <member name="T:ILNumerics.Core.MemoryLayer.AVLTree">
            <summary>
            AVL balanced search tree
            </summary>
            <remarks>The tree stores unique keys (type: <see cref="T:System.UInt64"/>, configurable via build) in an auto-balanced search tree.
            <para>The implementation is optimized for random seek access and consecutive write access - if no matching key found. 
            Also, the next higher key for a given query can be returned in O(1).</para>
            <para>The AVL tree class is not intended to be used directly. It supports the ILNumerics infrastructure (ILMemoryPool) 
            internally.</para></remarks>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.AVLTree.Count">
            <summary>
            Return number of keys currently existing in the tree
            </summary>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.AVLTree.Add(System.UInt64)">
            <summary>
            Check and add a key to the collection
            </summary>
            <param name="key">Key</param>
            <remarks>The function makes sure, the key is stored in the tree.</remarks>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.AVLTree.Remove(System.UInt64)">
            <summary>
            Remove key from tree
            </summary>
            <param name="key">Key to be removed</param>
            <remarks>The function makes sure that the tree does not contain a node with the given key.</remarks>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.AVLTree.Next(System.UInt64)">
            <summary>
            Find next higher key
            </summary>
            <param name="key">Key to find</param>
            <returns>The key with the next higher value compared with <paramref name="key"/>, or 0 if no such key exists</returns>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.AVLTree.Clear">
            <summary>
            Clear the tree from all keys
            </summary>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.AVLTree.CheckTree">
            <summary>
            check the consistency of the tree
            </summary>
            <returns></returns>
        </member>
        <member name="T:ILNumerics.Core.MemoryLayer.AVLTree.AVLTreeNode">
            <summary>
            an AVL tree node 
            </summary>
        </member>
        <member name="F:ILNumerics.Core.MemoryLayer.AVLTree.AVLTreeNode.key">
            <summary>
            Key
            </summary>
        </member>
        <member name="F:ILNumerics.Core.MemoryLayer.AVLTree.AVLTreeNode.right">
            <summary>
            Right child
            </summary>
        </member>
        <member name="F:ILNumerics.Core.MemoryLayer.AVLTree.AVLTreeNode.left">
            <summary>
            Left child
            </summary>
        </member>
        <member name="F:ILNumerics.Core.MemoryLayer.AVLTree.AVLTreeNode.balance">
            <summary>
            Balance factor for the node
            </summary>
        </member>
        <member name="F:ILNumerics.Core.MemoryLayer.AVLTree.AVLTreeNode.m_prevNodeinCache">
            <summary>
            Field building a linked list of cached unused nodes.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.AVLTree.AVLTreeNode.ToString">
            <summary>
            String representation of the node 
            </summary>
            <returns>String representation of the node</returns>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.BufferStateTuple.Clear">
            <summary>
             Clears / resets the tuple. 
            </summary>
        </member>
        <member name="T:ILNumerics.Core.MemoryLayer.IMemoryPool">
            <summary>
            This interface serves as the common API for all memory pools. It is used for maintenance of all pool types with a common interface. 
            </summary>
        </member>
        <member name="T:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1">
            <summary>
            A handle for managed reference type arrays. This class enables one to handle /store managed arrays with the same API as unmanaged memory. 
            </summary>
            <remarks>Since most computational arrays in ILNumerics host struct (value type) elements, managed heap memory is rarely used. 
            One important example is are cell arrays, which hold reference types as elements. These element arrays are 
            allocated on the managed heap by use of <see cref="T:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1"/>.</remarks>
            <typeparam name="T">The type of references hold in the internal <see cref="F:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.HostArray"/>.</typeparam>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.#ctor(System.UIntPtr,System.Boolean)">
            <summary>
            Create a new managed memory handle on the host, capable of storing <paramref name="length">_elements_</paramref> of type <typeparamref name="T"/>. 
            </summary>
            <param name="length">The number of <i>elements</i> (not bytes) of the new managed array.</param>
            <param name="clear">[Optional] This parameter is ignored.</param>
            <remarks><para>The <paramref name="clear"/> parameter has no effect. The new handle will be acquired by creating 
            a new array of <typeparamref name="T"/> from the managed heap. The CLR will ensure that its elements are 
            cleared.</para>
            <para>The new handle returned will host <paramref name="length"/> elements. However, the <see cref="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Length"/> property 
            of the new handle will reflect the <i>number of bytes</i> consumed by the array to store these elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.#ctor(`0[])">
            <summary>
            Create a managed host handle based on an existing managed <see cref="T:System.Array"/>. 
            </summary>
            <param name="source">The preallocated <see cref="T:System.Array"/>.</param>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.IsInvalid">
            <summary>
            Determine if this handle is a valid handle. Returns false, preventing from finalization.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.ID">
            <summary>
            Returns an identifier for this managed host handle.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.ReleaseResource(System.IntPtr)">
            <summary>
            Release the handle. For managed arrays this is a NOP. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.Pointer">
            <summary>
            Acquire a pointer to the first element of the <see cref="F:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.HostArray"/>. 
            </summary>
            <remarks>When requesing the <see cref="P:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.Pointer"/> for the first time during the lifetime of the handle
            the <see cref="F:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.HostArray"/> will be fixed in memory and remain fixed until the handle is disposed.</remarks>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.CopyTo(System.UInt32,ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt32,System.UInt64,System.IntPtr)">
            <summary>
            Copy elements. 
            </summary>
            <param name="sourceDevice"></param>
            <param name="target">Target handle</param>
            <param name="targetDevice"></param>
            <param name="start">start</param>
            <param name="length">!! Nr of ELEMENTS to copy! This intentionally deviates from the API of the base class!!</param>
        </member>
        <member name="T:ILNumerics.Core.MemoryLayer.ManagedHostPool`1">
            <summary>
            A memory pool allocating memory on the managed heap. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.ManagedHostPool`1.AllocateInternal(System.UIntPtr)">
            <summary>
            Create new ManagedHostHandle 
            </summary>
            <param name="length">Byte length!! (not element count!!) </param>
            <returns></returns>
        </member>
        <member name="T:ILNumerics.Core.MemoryLayer.MemoryHandle">
            <summary>
            <para>Base class for memory resources. All types handling memory in various ways derive 
            from <see cref="T:ILNumerics.Core.MemoryLayer.MemoryHandle"/>. This class either wraps a simple pointer to unmanaged 
            memory or a reference to a managed array of various element types. Instances are subject 
            of garbage collection (as a fallback only), perform reference counting and are happy to 
            be used in a multithreaded consumer / provider scenario.</para>
            <para>Typically, <see cref="T:ILNumerics.Core.MemoryLayer.MemoryHandle"/> is allocated, stored and maintained by a 
            corresponding <see cref="T:ILNumerics.Core.MemoryLayer.MemoryPool`1"/>.</para>
            </summary>
        </member>
        <member name="F:ILNumerics.Core.MemoryLayer.MemoryHandle.m_referenceCount">
            <summary>
            Gets the number of objects currently referencing this handle. Readonly. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Device">
            <summary>
            The memory pool of the device this handle belongs to. Used for freeing the handle.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.MemoryHandle.ID">
            <summary>
            An identifier for this memory object.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Pointer">
            <summary>
            The memory address of host (unmanaged heap) memory represented by this memory handle. 
            </summary>
            <remarks><para>The pointer returned is only valid on host devices and only as long as the current thread 
            does not enqueue any new asynchronous operations (involving this same memory handle). Typically, 
            you acquire the pointer, immediately perform some (low level) operations on its memory, and - as the program 
            proceeds with new array operations - forget about its value.</para></remarks>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Length">
            <summary>
            Number of bytes referenced by this handle.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.MemoryHandle.IsInvalid">
            <summary>
            Determine if this handle is a valid handle. Neglects the reference counter.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryHandle.#ctor">
            <summary>
            Note: this constructor is called from the CLR in P/Invoke calls. Make sure to fill all required attributes afterwards! 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryHandle.Retain(System.Boolean)">
            <summary>
            Register a reference to this handle. This method is threadsafe. 
            </summary>
            <param name="acquireWriteLockSynchronously">[Optional] Synchronous operations may acquire a write lock based on the number of references currently existing for this buffer. Default: false.</param>
            <remarks><para>Note that the write lock acquired by <paramref name="acquireWriteLockSynchronously"/>is only valid on this 
            (main) thread and only in synchronous operations on buffer / handles. It is solely based on the number of references to this handle and will not prevent 
            asynchronous operations (segments, copies) to access the handle for writing! Such operations rely on other synchronization methods (events). The method will 
            fail if <paramref name="acquireWriteLockSynchronously"/> is true but the number of references pointing to this handle is not suited for writing. Expected 
            number of references: 2 (one for hosting array, one for caller operation)</para> </remarks>
            <exception cref="T:System.InvalidOperationException">if a write lock was requested but could not be acquired.</exception>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryHandle.Release">
            <summary>
            Releases one reference to this handle. May causes the handle to be returned to the pool if this is the last reference pointing to the handle. This method is threadsafe. 
            </summary>
            <remarks>This method may be called by the base class' finalizer! </remarks>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryHandle.Dispose(System.Boolean)">
            <summary>
            Attempt to release this handle, neglecting any ref counting. This method really gives up the unmanaged resources and is called during finalization of CriticalHandle (among others). 
            </summary>
            <param name="manual">False when called in finalization.</param>
            <remarks><para><see cref="M:ILNumerics.Core.MemoryLayer.MemoryHandle.Dispose(System.Boolean)"/> is implemented in a way that the <b>first</b> thread executing this 
            method is releasing the underlying resource and marks this handle as invalid. Note, that <see cref="M:ILNumerics.Core.MemoryLayer.MemoryHandle.ReleaseResource(System.IntPtr)"/>
            is called exactly once (by this first thread only). Care must be taken if the resource is managed by reference 
            counting and multiple references exist.</para>
            <para>This method is threadsafe.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryHandle.Cache(ILNumerics.Core.MemoryLayer.MemoryPool{ILNumerics.Core.MemoryLayer.MemoryHandle})">
            <summary>
            Cache this handle 
            </summary>
            <param name="pool"></param>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryHandle.ReleaseResource(System.IntPtr)">
            <summary>
            Derived, concrete classes implement this method in order to perform actual release of the managed resource hosted on by this handle. 
            </summary>
            <param name="handle">The handle to give back to the OS / device. This may or may not be the same as the internal pointer stored by this handle!</param>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryHandle.CopyTo(System.UInt32,ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt32,System.UInt64,System.IntPtr)">
            <summary>
            Copy memory.
            </summary>
            <param name="sourceDevice"></param>
            <param name="target"></param>
            <param name="targetDevice"></param>
            <param name="start">offset to the src memory address in bytes.</param>
            <param name="length">number of bytes to copy. Note: derived types may expect 'nr of elements' here!</param>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryHandle.Clear">
            <summary>
            Clears the memory of this handle, set all bytes to 0.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryHandle.Clone">
            <summary>
            Returns a new memory handle of the same type with a shallow copy of all elements of this handle. 
            </summary>
            <returns>MemoryHandle of the same concrete type.</returns>
        </member>
        <member name="T:ILNumerics.Core.MemoryLayer.MemoryPool`1">
            <summary>
            The memory pool base class is a quantizing memory pool for fast (re-)allocating chunks of memory. 
            </summary>
        </member>
        <member name="F:ILNumerics.Core.MemoryLayer.MemoryPool`1.m_device">
            <summary>
            The device this memory pool belongs to. 
            </summary>
        </member>
        <member name="F:ILNumerics.Core.MemoryLayer.MemoryPool`1.m_memoryType">
            <summary>
            Internal use
            </summary>
        </member>
        <member name="F:ILNumerics.Core.MemoryLayer.MemoryPool`1.m_threadID">
            <summary>
            Internal use
            </summary>
        </member>
        <member name="F:ILNumerics.Core.MemoryLayer.MemoryPool`1.s_processPools">
            <summary>
            Internal use
            </summary>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.ThreadID">
            <summary>
            The managed thread ID of the thread this pool was created by/for. All (non-readonly) requests to the memory pools must be made from this thread only! 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.MemoryType">
            <summary>
            The memory type managed by this pool [readonly]. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.ShrinkCount">
            <summary>
            Number of shrinking operations performed by the pool so far. 
            </summary>
            <remarks><para>A high number of shrinking operations indicate an suboptimal memory 
            configuration for the current problem size / system memory. In such a situation 
            (at least some) memory chunks are not optimally reused and the performance 
            of the application may be low. </para>
            <para>During the run of the algorithm the pool will try to adopt itself to 
            the required memory allocation pattern. This means the pool is shrinked and expanded 
            as required dynamically. </para>
            </remarks>
            <seealso cref="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.MaxSize"/>
            <seealso cref="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.OOMCount"/>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.OOMCount">
            <summary>
            Number of OOMs catched (and handled) during allocation requests.
            </summary>
            <remarks><para>A high number of OOM exceptions caught during the run of the algorithms may 
            indicate insufficient memory on your system for the particular problem size. Try to limit the 
            memory used by other processes and /or threads and to increase the memory available to the thread 
            this pool is associated with.</para>
            <para>Try to increase the physical RAM available on your system.</para>
            <para>OOM exceptions cause the memory pool to decrease its overall storage limit so that 
            fewer objects are kept alive by the pool.</para>
            </remarks>
            <seealso cref="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.MaxSize"/>
            <seealso cref="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.ShrinkCount"/>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.MaxSize">
            <summary>
            A hard limit of a number of bytes the memory pool is able to hold. 
            </summary>
            <remarks><para>The memory pool limits the amount of memory hold alive to the number of bytes determined 
            by <see cref="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.MaxSize"/>. No memory chunk greater than <see cref="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.MaxSize"/> can be stored in the pool. </para></remarks>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.Size">
            <summary>
            The sum in bytes of all objects currently hold in the pool.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.Count">
            <summary>
            The number of objects currently stored in this pool.
            </summary>
            <remarks><para>In order to acquire the object count 
            the pool iterates its objects which may introduces a significant cost. </para>
            <para>This API is not thread safe! Make sure no other threads interfere 
            during the execution of this method.</para></remarks>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.Device">
            <summary>
            The device this pool is associated with. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryPool`1.New(System.UInt64,System.Boolean)">
            <summary>
            Request a memory chunk of at least length <paramref name="length"/>. 
            </summary>
            <param name="length">Minimal length requested in bytes.</param>
            <param name="init">[Optional] True: returned cleared memory (zeros, 0 values); False (default): do 
            not clear the memory.</param>
            <returns><see cref="T:ILNumerics.Core.MemoryLayer.MemoryHandle"/> to the memory chunk of (at least) the requested length.</returns>
            <remarks><para>The memory will be taken from the pool if a matching chunk is available in the pool. Otherwise, 
            a new chunk of memory is allocated from the <see cref="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.Device"/>'s memory allocator.</para>
            <para>'Matching' chunks are those chunks of memory stored in the pool which have the exact 
            <paramref name="length"/> requested or a higher length. The 
            <see cref="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Length"/> property informs about the length of the region the returned pointer refers to.</para>
            <para>During the retrieval / allocation of the requested memory chunk this function blocks other threads 
            from modifying the pools state (lockfree, though).</para>
            </remarks> 
            <exception cref="T:System.OutOfMemoryException"> if no matching memory chunk was found in the pool and no memory of the requested length could be allocated from device memory.</exception>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryPool`1.New(System.UIntPtr,System.Boolean)">
            <summary>
            Request a memory chunk of length <paramref name="length"/>. 
            </summary>
            <param name="length">Length requested in bytes.</param>
            <param name="init">[Optional] True: returned cleared memory (zeros, 0 values); False (default): do not clear the memory.</param>
            <returns><see cref="T:System.IntPtr"/> to the memory chunk.</returns>
            <remarks><para>The memory will be taken from the pool if a matching chunk is available in the pool. Otherwise, 
            a new chunk of memory is allocated from the <see cref="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.Device"/>'s memory allocator.</para>
            <para>'Matching' chunks are those chunks of memory stored in the pool which have the exact 
            <paramref name="length"/> requested or a higher length, within a certain interval. The <see cref="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Length"/> property
            informs about the actual allocated length of the allocated memory chunk the returned pointer refers to.</para>
            <para>During the retrieval / allocation of the requested memory chunk this function blocks other threads from modifying the pools state.
            This should not impose a performance issue, because access to all memory managment functions must happen <i>from the same thread</i>! I.e.: 
            a memory chunk acquired by <see cref="M:ILNumerics.Core.MemoryLayer.MemoryPool`1.New(System.UIntPtr,System.Boolean)"/> from thread A must be reclaimed with <see cref="M:ILNumerics.Core.MemoryLayer.MemoryPool`1.Free(`0)"/> <i>from the same thread A</i>.</para>
            <para>The reference count of the handle returned will be set to 0!</para>
            </remarks> 
            <exception cref="T:System.OutOfMemoryException"> if no matching memory chunk was found in the pool and no memory of the requested length could be allocated from device memory.</exception>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryPool`1.tryDetectIfRunningInDebugEvaluation">
            <summary>
            Attempt to determine if the function was called from the Immediate Window of from some 
            other non-standard debug places. Helps to prevent from death lock when waiting on non-running finalizer thread. 
            </summary>
            <returns>true if this thread is probably the only debugger thread running. False otherwise.</returns>
            <remarks>If this returns false this does not mean that the finalizer is really running / runnable! It is barely 
            more than a hint and should be taken as such.</remarks>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryPool`1.Free(`0)">
            <summary>
            Returns a chunk of memory back to the pool.
            </summary>
            <param name="handle"><typeparamref name="HandleT"/> refering to the memory chunk.</param>
            <remarks><para>The pool will try to hold on to the memory pointed to by <paramref name="handle"/>. If 
            the handles memory length is too large and will not 'fit' into the pool (see: <see cref="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.MaxSize"/>) it will be 
            released back to the <see cref="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.Device"/> memory, disposing the handle.</para>
            <para>If the handles size is smaller than <see cref="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.MaxSize"/> but other objects currently stored 
            in the pool prevent to store <paramref name="handle"/> without exceeding <see cref="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.MaxSize"/> at least some of those  
            handles will be released until there is enough free space in the pool to fit the new handle into the pool. 
            This process (shrinking) may also involves the modification of the <see cref="P:ILNumerics.Core.MemoryLayer.MemoryPool`1.MaxSize"/> property of the pool.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryPool`1.Shrink(System.UInt64)">
            <summary>
            Shrinks the pool down to <paramref name="shrinkedSize"/> by releasing old objects.
            </summary>
            <param name="shrinkedSize">The target size in bytes of the pool. The pool will be shrinked, until its 
            size drops below this value.</param>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryPool`1.FindBin(System.UInt64)">
            <summary>
            map lengths to bins
            </summary>
            <param name="l">length of requested memory region</param>
            <returns>the index of the bin to look for the requested memory region</returns>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryPool`1.ToString">
            <summary>
            Produces statistical information about this memory pool instance for informal messages.
            </summary>
            <returns>Informal string.</returns>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryPool`1.Shrink_threadLocal(System.UInt64)">
            <summary>
            perform the shrinking - to be called from single thread only!
            </summary>
            <param name="shrinkedSize">ignored</param>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.MemoryPool`1.AllocateInternal(System.UIntPtr)">
            <summary>
            Allocates a new block of memory / resource according to <paramref name="length"/>. 
            </summary>
            <param name="length">Length of the new memory region in bytes.</param>
            <returns><see cref="T:System.IntPtr"/> handle to the newly allocated region.</returns>
            <remarks><para>The handle returned should be a valid handle. In case of failure throw <see cref="T:System.OutOfMemoryException"/> or another, more adequate exception.</para></remarks>
        </member>
        <member name="T:ILNumerics.Core.MemoryLayer.NativeHostHandle">
            <summary>
            Handle representing unmanaged host memory in a robust (self-disposing) way. Aligned in certain cases.
            </summary>
            <remarks>The pointer to native memory wrapped inside this handle will be acquired from the unmanaged heap. For performance reason
            the acquiring class / method is responsible for initializing new handles with required data: Length and Pointer. 
            <para>In case of <see cref="T:ILNumerics.Core.MemoryLayer.NativeHostPool"/> <see cref="P:ILNumerics.Core.MemoryLayer.NativeHostHandle.Pointer"/> will present the lowest address within the allocated memory region 
            which fulfills the alignment and length requirements of Intel's OpenCL buffer sharing (CPU / Integrated GPU). See: <see cref="F:ILNumerics.Core.MemoryLayer.NativeHostPool.MEMORY_ALIGNMENT_BYTES"/> which determines the needed alignment (4K). 
            The length of the buffer </para>
            <para><b>Note, that alignment for <see cref="T:ILNumerics.Core.MemoryLayer.NativeHostHandle"/> is only guaranteed for handles pointing to memory regions larger than <see cref="F:ILNumerics.Core.MemoryLayer.NativeHostPool.MEMORY_ALIGNMENT_BYTES"/></b>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.NativeHostHandle.#ctor">
            <summary>
            Create a new host memory handle. This will be used by P/Invoke methods having <see cref="T:ILNumerics.Core.MemoryLayer.NativeHostHandle"/> as return type. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.NativeHostHandle.#ctor(System.IntPtr)">
            <summary>
            Create a new host memory handle. This will be used by P/Invoke methods having <see cref="T:ILNumerics.Core.MemoryLayer.NativeHostHandle"/> as return type. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.NativeHostHandle.Pointer">
            <summary>
            Address of the payload memory region for this handle. This respects alignment requirements and is different to <see cref="P:ILNumerics.Core.MemoryLayer.NativeHostHandle.Handle"/> which points to the beginning of the memory region originally allocated from the OS. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.NativeHostHandle.ID">
            <summary>
            The <see cref="P:ILNumerics.Core.MemoryLayer.NativeHostHandle.Pointer"/> value with the aligned memory address this handle is pointing to.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.MemoryLayer.NativeHostHandle.Handle">
            <summary>
            The address originally provided by the OS in result of the memory allocation request. This address is not aligned and must be kept unchanged for freeing the handle later. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.NativeHostHandle.Release">
            <summary>
            Releases one reference to this handle. May causes the handle to be returned to the pool if this is the last reference 
            pointing to the handle. This method is threadsafe. 
            </summary>
            <remarks>This method may be called by a base class finalizer! </remarks>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.NativeHostHandle.ReleaseResource(System.IntPtr)">
            <summary>
            Release the handles resource, neglecting reference counting. This releases the memory back to the OS.
            </summary>
        </member>
        <member name="T:ILNumerics.Core.MemoryLayer.NativeHostPool">
            <summary>
            A memory pool responsible for creating and caching memory chunks on (unmanaged) host memory. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.MemoryLayer.NativeHostPool.#ctor(ILNumerics.Core.DeviceManagement.Device)">
            <summary>
            Create a new memory pool for the host device (CLR). 
            </summary>
            <param name="device">The host device.</param>
        </member>
        <member name="F:ILNumerics.Core.CountableArray.m_handles">
            <summary>
            The array of device specific memory. Host memory, by specification is stored at index 0. 
            </summary>
            <remarks>Order of devices: 0 - process memory (CLR host), 1 - CPU OpenCL device, 2 - integr. GPU (SVM, if available), 3 -... GPU / others</remarks>
        </member>
        <member name="F:ILNumerics.Core.CountableArray.m_referenceCount">
            <summary>
            The count of storages currently referencing this <see cref="T:ILNumerics.Core.CountableArray"/>.
            </summary>
        </member>
        <member name="F:ILNumerics.Core.CountableArray.m_previous">
            <summary>
            Linked list item reference holder.
            </summary>
        </member>
        <member name="F:ILNumerics.Core.CountableArray.m_currentDeviceIdx">
            <summary>
            The index of the device which was last used to write data associated with this <see cref="T:ILNumerics.Core.CountableArray"/> to. This device currently holds the most up-to date copy of the data.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.CountableArray.CurrentDeviceIdx">
            <summary>
            Gets the index of the device where the most up-to-date data of this <see cref="T:ILNumerics.Core.CountableArray"/> are stored or -1 if no data are available.
            </summary>
        </member>
        <member name="P:ILNumerics.Core.CountableArray.ReferenceCount">
            <summary>
            The current value of the counter of references to this <see cref="T:ILNumerics.Core.CountableArray"/>. This is readonly and <em>not</em> threadsafe.
            </summary>
            <remarks>In order to in-/decrease the reference counter, use 
            the <see cref="M:ILNumerics.Core.CountableArray.Retain"/>
            and <see cref="M:ILNumerics.Core.CountableArray.Release"/> functions.</remarks>
        </member>
        <member name="P:ILNumerics.Core.CountableArray.Item(System.UInt32)">
            <summary>
            Gets the memory handle of the device referenced by <paramref name="i"/> or sets it. 
            </summary>
            <param name="i">Device ID</param>
            <returns>MemoryHandle of the specified device.</returns>
        </member>
        <member name="M:ILNumerics.Core.CountableArray.Create">
            <summary>
            Provide a countable array for a new storage. Reference count will be 1 (no need to Retain()!). 
            </summary>
            <returns><see cref="T:ILNumerics.Core.CountableArray"/> for further use.</returns>
        </member>
        <member name="M:ILNumerics.Core.CountableArray.New``1(System.UInt64,System.UInt32,System.Boolean)">
            <summary>
            Allocate new memory for utilization on specified device. 
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="elementsCount">Number of elements to allocate.</param>
            <param name="deviceId">Positive index of the allocation device. This must be in range of <see cref="M:ILNumerics.Core.DeviceManagement.DeviceManager.GetDeviceCount"/>.</param>
            <param name="clear">[Optional] Flag indicating if the new memory region should be filled with 0. Default: (false) the memory may contain old data.</param>
        </member>
        <member name="M:ILNumerics.Core.CountableArray.Retain">
            <summary>
            Registers the caller as user of this <see cref="T:ILNumerics.Core.CountableArray"/>. Increase the reference counter. 
            </summary>
            <returns>The value of the internal reference counter after registering the caller.</returns>
            <seealso cref="M:ILNumerics.Core.CountableArray.Release"/>
        </member>
        <member name="M:ILNumerics.Core.CountableArray.Release">
            <summary>
            Decrease the reference counter. Release resources and cache this object when reference counter reaches 0.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.CountableArray.Clone``1(ILNumerics.Size,System.UInt32,System.UInt32)">
            <summary>
            Copies the most up-to-date memory from this <see cref="T:ILNumerics.Core.CountableArray"/> to the <paramref name="targetDeviceIdx"/> of a new <see cref="T:ILNumerics.Core.CountableArray"/>. 
            </summary>
            <param name="targetDeviceIdx">The 0-based index of the device which is going to hold the (only) reference to the copied memory.</param>
            <param name="size">The size descriptor. Used to read the required region to copy.</param>
            <remarks><para>The memory is copied from the 'current' handle, i.e.: from the device the data of this <see cref="T:ILNumerics.Core.CountableArray"/>
            were last written to.</para></remarks>
            <returns>A new <see cref="T:ILNumerics.Core.CountableArray"/> holding the most current data in its <paramref name="targetDeviceIdx"/> slot.</returns>
        </member>
        <member name="M:ILNumerics.Core.CountableArray.SetOrReplace(System.Int32,ILNumerics.Core.MemoryLayer.MemoryHandle)">
            <summary>
            Stores an existing handle into an existing slot of this <see cref="T:ILNumerics.Core.CountableArray"/>. Considers reference counting. Does not affect other slots.
            </summary>
            <param name="index">Slot (/device) index.</param>
            <param name="buffer">The handle to be stored.</param>
        </member>
        <member name="M:ILNumerics.Core.CountableArray.GetHandlesArray">
            <summary>
            Returns the plain array used internally to hold the handles. Used for EnsureBuffer(), debugging and as visualization helper only! 
            </summary>
            <returns>Reference to the internal handles array. Do use with care!</returns>
            <remarks>Do not use this method unless you know what you are doing! Use the indexer of <see cref="T:ILNumerics.Core.CountableArray"/> instead!</remarks>
        </member>
        <member name="M:ILNumerics.Core.CountableArray.FindDevice">
            <summary>
            Finds the first device memory referenced by this <see cref="T:ILNumerics.Core.CountableArray"/>, starting with examining host memory (index 0). 
            </summary>
            <returns>On success the 0-based index of the first referenced device memory found is returned. If no such device 
            exists an exception is thrown.</returns>
            <exception cref="T:System.InvalidOperationException">if no device memory handle was found.</exception>
        </member>
        <member name="M:ILNumerics.Core.CountableArray.GetHashCode">
            <summary>
            Gets a hash code of the handles _and its content_ currently stored in this object.
            </summary>
            <returns>Hash code recognizing this object and its content.</returns>
        </member>
        <member name="M:ILNumerics.Core.CountableArray.ReleaseHandles">
            <summary>
            Releases any handles currently stored in this countable array.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.CountableArray.Finish">
            <summary>
            Waits for any pending operation on a handle of this array.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.CountableArray.IsOnDevice(System.Int32)">
            <summary>
            Checks whether this countable array maintains a current copy of its data on the specified device. 
            </summary>
            <param name="v">Index of the device to test.</param>
            <returns>true if this data is on the specified device. False otherwise.</returns>
        </member>
        <member name="T:ILNumerics.Core.Native.IFFT">
            <summary>
            Interface for all FFT methods supported
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTBackward(ILNumerics.InArray{ILNumerics.complex},System.UInt32)">
            <summary>
            performs backward n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTBackward(ILNumerics.InArray{ILNumerics.fcomplex},System.UInt32)">
            <summary>
            performs backward n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTBackward1D(ILNumerics.InArray{ILNumerics.fcomplex},System.UInt32)">
            <summary>
            performs backward 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTBackward1D(ILNumerics.InArray{ILNumerics.complex},System.UInt32)">
            <summary>
            performs backward 1-dimensional fft 
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTBackwSym(ILNumerics.InArray{ILNumerics.fcomplex},System.UInt32)">
            <summary>
            performs backward n-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTBackwSym(ILNumerics.InArray{ILNumerics.complex},System.UInt32)">
            <summary>
            performs backward n-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTBackwSym1D(ILNumerics.InArray{ILNumerics.fcomplex},System.UInt32)">
            <summary>
            performs backward 1-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTBackwSym1D(ILNumerics.InArray{ILNumerics.complex},System.UInt32)">
            <summary>
            performs backward 1-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTForward(ILNumerics.InArray{ILNumerics.fcomplex},System.UInt32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTForward(ILNumerics.InArray{System.Double},System.UInt32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTForward(ILNumerics.InArray{ILNumerics.complex},System.UInt32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTForward(ILNumerics.InArray{System.Single},System.UInt32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTForward1D(ILNumerics.InArray{ILNumerics.complex},System.UInt32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTForward1D(ILNumerics.InArray{System.Double},System.UInt32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTForward1D(ILNumerics.InArray{ILNumerics.fcomplex},System.UInt32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FFTForward1D(ILNumerics.InArray{System.Single},System.UInt32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="P:ILNumerics.Core.Native.IFFT.CachePlans">
            <summary>
            true, if the implementation caches plans between subsequent calls
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.IFFT.FreePlans">
            <summary>
            Clear all currently cached plans. Tasks like FreePlans should be left to the ILNumerics memory management. Calling the method manually (without good reasons) may lead to poor performance! 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Native.IFFT.SpeedyHermitian">
            <summary>
            true, if the implementation efficiently transforms from/to hermitian sequences (hermitian symmetry). 
            </summary>
            <remarks>If this property returns 'true', the implementation brings increased performance. 
            If not, the symmetry methods will bring no performance advantage over the 1D transforms. </remarks>
        </member>
        <member name="T:ILNumerics.Core.Native.MKLFFT">
            <summary>
            Wrapper for FFT interface using MKL 10_03
            </summary>
        </member>
        <member name="P:ILNumerics.Core.Native.MKLFFT.CachePlans">
            <summary>
            (True) Informs about the capability of this <see cref="T:ILNumerics.Core.Native.IFFT"/> implementation to optimize subsequent transforms of similar data (regarding shape and type).
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.MKLFFT.FreePlans">
            <summary>
            Invalidates the currently cached fft descriptor for this thread.
            </summary>
            <remarks><para>Calling this method manually may help in situations where multithreading was 
            triggered manually and many threads are involved. Note that
            FFT plans are cached on a thread level! Therefore, if you have created fft transforms on multiple 
            threads, make sure to dispose the descriptor on each thread individually.</para>
            <para>FFT descriptors carry information about the last FFT transform and reuse it for subsequent, 
            similar transforms on the same thread. This saves the re-creation of intermediate data during the 
            transforms. Only the descriptor of the last FFT transform is cached. Hence, in a single threaded 
            scenario (default) disposing the FFT descriptor data manually is rarely required.</para></remarks>
        </member>
        <member name="P:ILNumerics.Core.Native.MKLFFT.SpeedyHermitian">
            <summary>
            (True) Informs about the capability of this <see cref="T:ILNumerics.Core.Native.IFFT"/> implementation to perform optimized transforms for symmetric / hermitian data.
            </summary>
        </member>
        <member name="T:ILNumerics.Core.Native.ILapack">
            <summary>
            Interface for LAPACK/BLAS functions. 
            </summary>
            <remarks>Each native module must implement this interface explicitly. Calls 
            to native functions are made by calling functions of this interface.
            Therefore the user can transparently call any function regardless of the 
            plattform the assymbly (currently) runs on. The native modules implementing
            this interface take care of the details of implementation. 
            <para>Usually users of the library will not have to handle with this interface. 
            Its functions will be used from inside built in functions and are therefore wrapped 
            (mainly from inside <see cref="T:ILNumerics.ILMath">ILNumerics.ILMath</see>).</para>
            <para>Every LAPACK/BLAS function is explicitly implemented for any type supported.
            e.g. IILLapack includes four functions doing general matrix multiply: dgemm, zgemm, cgemm and sgemm - 
            for all four floating point datatypes supported from the LAPACK package.</para>
            <para>LAPACK is an open source linear algebra functions package optimized for 
            use together with highly natively optimized BLAS functions. A LAPACK guide is 
            available here: <see href="http://www.netlib.org/lapack">www.netlib.org</see>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.Double*,System.Int32,System.Double*,System.Int32,System.Double,System.Double*,System.Int32)">
            <summary>
            Wrapper implementiation for BLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplication factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.Single*,System.Int32,System.Single*,System.Int32,System.Single,System.Single*,System.Int32)">
            <summary>
            Wrapper implementiation for BLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex*,System.Int32,ILNumerics.fcomplex*,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex*,System.Int32)">
            <summary>
            Wrapper implementiation for BLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,ILNumerics.complex*,System.Int32,ILNumerics.complex*,System.Int32,ILNumerics.complex,ILNumerics.complex*,System.Int32)">
            <summary>
            Wrapper implementiation for BLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.dgesdd(System.Char,System.Int32,System.Int32,System.Double*,System.Int32,System.Double*,System.Double*,System.Int32,System.Double*,System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.sgesdd(System.Char,System.Int32,System.Int32,System.Single*,System.Int32,System.Single*,System.Single*,System.Int32,System.Single*,System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.cgesdd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex*,System.Int32,System.Single*,ILNumerics.fcomplex*,System.Int32,ILNumerics.fcomplex*,System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.zgesdd(System.Char,System.Int32,System.Int32,ILNumerics.complex*,System.Int32,System.Double*,ILNumerics.complex*,System.Int32,ILNumerics.complex*,System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.dgesvd(System.Char,System.Int32,System.Int32,System.Double*,System.Int32,System.Double*,System.Double*,System.Int32,System.Double*,System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.sgesvd(System.Char,System.Int32,System.Int32,System.Single*,System.Int32,System.Single*,System.Single*,System.Int32,System.Single*,System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex*,System.Int32,System.Single*,ILNumerics.fcomplex*,System.Int32,ILNumerics.fcomplex*,System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex*,System.Int32,System.Double*,ILNumerics.complex*,System.Int32,ILNumerics.complex*,System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.dpotrf(System.Char,System.Int32,System.Double*,System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.spotrf(System.Char,System.Int32,System.Single*,System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.cpotrf(System.Char,System.Int32,ILNumerics.fcomplex*,System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.zpotrf(System.Char,System.Int32,ILNumerics.complex*,System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.dpotri(System.Char,System.Int32,System.Double*,System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.spotri(System.Char,System.Int32,System.Single*,System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.cpotri(System.Char,System.Int32,ILNumerics.fcomplex*,System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.zpotri(System.Char,System.Int32,ILNumerics.complex*,System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.dpotrs(System.Char,System.Int32,System.Int32,System.Double*,System.Int32,System.Double*,System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.spotrs(System.Char,System.Int32,System.Int32,System.Single*,System.Int32,System.Single*,System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.cpotrs(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex*,System.Int32,ILNumerics.fcomplex*,System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.zpotrs(System.Char,System.Int32,System.Int32,ILNumerics.complex*,System.Int32,ILNumerics.complex*,System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.dgetrf(System.Int32,System.Int32,System.Double*,System.Int32,System.Int32*,System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.sgetrf(System.Int32,System.Int32,System.Single*,System.Int32,System.Int32*,System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.cgetrf(System.Int32,System.Int32,ILNumerics.fcomplex*,System.Int32,System.Int32*,System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.zgetrf(System.Int32,System.Int32,ILNumerics.complex*,System.Int32,System.Int32*,System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.dgetri(System.Int32,System.Double*,System.Int32,System.Int32*,System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.sgetri(System.Int32,System.Single*,System.Int32,System.Int32*,System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.cgetri(System.Int32,ILNumerics.fcomplex*,System.Int32,System.Int32*,System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.zgetri(System.Int32,ILNumerics.complex*,System.Int32,System.Int32*,System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.dorgqr(System.Int32,System.Int32,System.Int32,System.Double*,System.Int32,System.Double*,System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.sorgqr(System.Int32,System.Int32,System.Int32,System.Single*,System.Int32,System.Single*,System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.cungqr(System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex*,System.Int32,ILNumerics.fcomplex*,System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.zungqr(System.Int32,System.Int32,System.Int32,ILNumerics.complex*,System.Int32,ILNumerics.complex*,System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.dgeqrf(System.Int32,System.Int32,System.Double*,System.Int32,System.Double*,System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.sgeqrf(System.Int32,System.Int32,System.Single*,System.Int32,System.Single*,System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.cgeqrf(System.Int32,System.Int32,ILNumerics.fcomplex*,System.Int32,ILNumerics.fcomplex*,System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.zgeqrf(System.Int32,System.Int32,ILNumerics.complex*,System.Int32,ILNumerics.complex*,System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.dgeqp3(System.Int32,System.Int32,System.Double*,System.Int32,System.Int32*,System.Double*,System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.sgeqp3(System.Int32,System.Int32,System.Single*,System.Int32,System.Int32*,System.Single*,System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.cgeqp3(System.Int32,System.Int32,ILNumerics.fcomplex*,System.Int32,System.Int32*,ILNumerics.fcomplex*,System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.zgeqp3(System.Int32,System.Int32,ILNumerics.complex*,System.Int32,System.Int32*,ILNumerics.complex*,System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.dormqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double*,System.Int32,System.Double*,System.Double*,System.Int32,System.Int32@)">
            <summary>
            multipliation for general matrix with QR decomposition factor
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.sormqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single*,System.Int32,System.Single*,System.Single*,System.Int32,System.Int32@)">
            <summary>
            multipliation for general matrix with QR decomposition factor
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.dtrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Double*,System.Int32,System.Double*,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.strtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Single*,System.Int32,System.Single*,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.ctrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,ILNumerics.fcomplex*,System.Int32,ILNumerics.fcomplex*,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.ztrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,ILNumerics.complex*,System.Int32,ILNumerics.complex*,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.dgetrs(System.Char,System.Int32,System.Int32,System.Double*,System.Int32,System.Int32*,System.Double*,System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.sgetrs(System.Char,System.Int32,System.Int32,System.Single*,System.Int32,System.Int32*,System.Single*,System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.cgetrs(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex*,System.Int32,System.Int32*,ILNumerics.fcomplex*,System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="M:ILNumerics.Core.Native.ILapack.zgetrs(System.Char,System.Int32,System.Int32,ILNumerics.complex*,System.Int32,System.Int32*,ILNumerics.complex*,System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="T:ILNumerics.Core.Native.LapackMKL10_0">
            <summary>
            LAPACK interface implementation, specialized for Intel's (R) MKL (R).
            </summary>
            
        </member>
        <member name="M:ILNumerics.Core.Native.LapackMKL10_0.FreeBuffers">
            <summary>
            Free all buffers from the MKL Fast Memory Management. Use sparingly and carefully! 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.LapackMKL10_0.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.Double*,System.Int32,System.Double*,System.Int32,System.Double,System.Double*,System.Int32)">
            <summary>
            Implement wrapper for BLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.LapackMKL10_0.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.Single*,System.Int32,System.Single*,System.Int32,System.Single,System.Single*,System.Int32)">
            <summary>
            Implement wrapper for BLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.LapackMKL10_0.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex*,System.Int32,ILNumerics.fcomplex*,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex*,System.Int32)">
            <summary>
            Implement wrapper for BLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.LapackMKL10_0.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,ILNumerics.complex*,System.Int32,ILNumerics.complex*,System.Int32,ILNumerics.complex,ILNumerics.complex*,System.Int32)">
            <summary>
            Implement wrapper for BLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Core.Native.LapackMKL10_0.dgesvd(System.Char,System.Int32,System.Int32,System.Double*,System.Int32,System.Double*,System.Double*,System.Int32,System.Double*,System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Core.Native.LapackMKL10_0.sgesvd(System.Char,System.Int32,System.Int32,System.Single*,System.Int32,System.Single*,System.Single*,System.Int32,System.Single*,System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Core.Native.LapackMKL10_0.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex*,System.Int32,System.Double*,ILNumerics.complex*,System.Int32,ILNumerics.complex*,System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Core.Native.LapackMKL10_0.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex*,System.Int32,System.Single*,ILNumerics.fcomplex*,System.Int32,ILNumerics.fcomplex*,System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="T:ILNumerics.Core.Native.MKLImports">
            <summary>
            import functions (pinvoke)
            </summary>
        </member>
        <member name="M:ILNumerics.Core.Native.MKLImports.DftiComputeForward(System.IntPtr,System.Double[],System.Double[])">
            DFTI native DftiComputeForward declaration 
        </member>
        <member name="M:ILNumerics.Core.Native.MKLImports.DftiComputeBackward(System.IntPtr,System.Double[],System.Double[])">
            DFTI native DftiComputeBackward declaration 
        </member>
        <member name="T:ILNumerics.Core.Native.MKLParameter">
            <summary>
            MKL configuration parameters (constant definitions)
            </summary>
        </member>
        <member name="T:ILNumerics.Core.Native.MKLValues">
            <summary>
            MKL configuration values (constant definitions) 
            </summary>
        </member>
        <member name="T:ILNumerics.Core.Native.NativeMethods">
            <summary>
            Static helper class for PInvoke definitions of native function imports.
            </summary>
        </member>
        <member name="T:ILNumerics.Core.StorageLayer.BaseStorage`6">
            <summary>
            Generic base class for all ILNumerics arrays. This class is used internally. 
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.CopyTo(ILNumerics.Core.MemoryLayer.MemoryHandle,ILNumerics.Size,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Copy the data of this array to another memory region, specify element storage order for writing. 
            </summary>
            <param name="dest">Pointer to a memory region, large enough to store all elements of this array in the storage layout given by <paramref name="layout"/>.</param>
            <param name="outSize">[Output] On return the size descriptor holds the dimension lengths and strides according to the size of this array and the specified <paramref name="layout"/>.</param>
            <param name="layout">[Optional] The storage order used to write the elements to <paramref name="dest"/>. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <remarks><para><paramref name="outSize"/> can be <c>null</c> on entry in which case it will be ignored.</para>
            <para>If <paramref name="layout"/> is <c>null</c> or <see cref="F:ILNumerics.StorageOrders.Other"/> the storage layout of the array 
            returned will be automatically determined based on the current storage layout: copying from continous storages will keep 
            the source storage layout (column- or row major layout). Copying from non-continous storages creates a storage according to 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>. </para>
            <para>If <paramref name="layout"/> is one of <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/> the 
            elements are stored into <paramref name="dest"/> with this layout.</para>
            <para>Make sure that the memory region addressed by <paramref name="dest"/> is large enough, even if the current storage layout 
            corresponds to non-continously stored elements! Note further, that 
            any potentially existing holes in the element storage layout will not be cleared!</para>
            </remarks>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.BaseStorage`6.SizeOfT">
            <summary>
            Number of bytes used to store a single element of type <typeparamref name="T"/> in memory [readonly].
            </summary>
            <remarks><para><see cref="F:ILNumerics.Core.StorageLayer.BaseStorage`6.SizeOfT"/> corresponds to the <i>unmanged</i> size of a single element of this array. 
            This size corresponds to <see cref="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)"/>. Its value is cached here for performance reasons.</para>
            <para>Note that the size of blittable types is the same on the managed as well as on the unmanaged part. For example, 
            every element of type <see cref="T:System.Int32"/> consumes 4 bytes in the unmanaged heap or on the managed stack. </para>
            <para>(At least) one exception exists: <see cref="T:System.Boolean"/> elements in .NET are represented by 4 bytes on the managed 
            side. ILNumerics, however, stores them more efficiently as single <see cref="T:System.Byte"/> in memory.</para></remarks>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.BaseStorage`6.m_array">
            <summary>
            The local array of this storage.
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.BaseStorage`6.m_inArray">
            <summary>
            The input array of this storage.
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.BaseStorage`6.m_retArray">
            <summary>
            The return array of this storage.
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.BaseStorage`6.m_outArray">
            <summary>
            The output array of this storage. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.StorageLayer.BaseStorage`6.LocalArray">
            <summary>
            Gives the local array of this storage. This is used when the storage is referenced by a local array type. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.StorageLayer.BaseStorage`6.InArray">
            <summary>
            The input array of this storage. This is used when the storage is referenced to by an input array type. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.StorageLayer.BaseStorage`6.RetArray">
            <summary>
            The return array of this storage. This is used when the storage is referenced to by a return array type. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.StorageLayer.BaseStorage`6.OutArray">
            <summary>
            The output array of this storage. This is used when the storage is referenced to by an output array type. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.StorageLayer.BaseStorage`6.Context">
            <summary>
            Gives the thread specific context object for caching operations. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.StorageLayer.BaseStorage`6.ScopeState">
            <summary>
            Gets the state of this storage: 0 - outside any scope, 1 - prepared to enter scope, 2 - waiting for leaving a scope &amp; for Release().
            </summary>
            <remarks>THIS IS NOT USED IN VERSION 5 SCOPING. IT IS LEFT IN HERE BECAUSE WE NEED IT FOR VERSION 6 SCOPING
            ONCE WE HAVE COMPILER SUPPORT.</remarks>
        </member>
        <member name="P:ILNumerics.Core.StorageLayer.BaseStorage`6.ReferenceCount">
            <summary>
            Gets the number of arrays published for this storage. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.ShortInfo">
            <summary>
            Gives a short description about the type, shape and a few element values of this storage.
            </summary>
            <returns>String with short description of this storage.</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.ShortInfo(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gives a short description. Allows to disable individual info.
            </summary>
            <returns>String with short description of this storage.</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.LeaveScope">
            <summary>
            Internal use. Indicates to the arrays storage that an scope block is left. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.copyUpperTriangle(System.Int64)">
            <summary>
            Copy upper triangular matrix from this storage into a new array.
            </summary>
            <param name="n">Length of first dimension of destination array.</param>
            <returns>Column major array of size [n x n] with the upper triangular part of this array.</returns>
            <remarks><para>This function works with value element types (struct) only.</para></remarks>
            <exception cref="T:System.InvalidOperationException"> if <typeparamref name="T"/> is not a value type.</exception>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.ILNumerics#Core#StorageLayer#IStorage#GetBaseArrayClone">
            <summary>
            Gives a shallow clone of this array: new array object, same memory. 
            </summary>
            <returns>Clone of this array as <typeparamref name="RetT"/>.</returns>
            <remarks>For Storage{T} this creates a shallow clone. For cells the object returned must be cloned manually.</remarks>
            <see cref="M:ILNumerics.BaseArray.IsOfType``1"/>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.ILNumerics#Core#StorageLayer#IStorage#GetBaseArray">
            <summary>
            Gets a BaseArray instance (RetArray) corresponding to this storage.
            </summary>
            <returns>RetArray of this cell storage.</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.ILNumerics#Core#StorageLayer#IStorage#GetCellContentDirect(System.Int64*,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the cell _content_ of the cell addressed by <paramref name="indices"/> without cloning. 
            </summary>
            <param name="indices">Vector of the full index path, from root cell to the target element.</param>
            <param name="lenIndices">Number of indices stored in <paramref name="indices"/>.</param>
            <param name="start">First index in <paramref name="indices"/> to be considered.</param>
            <returns>The storage object found at <paramref name="indices"/>, potentially wrapped into a scalar <see cref="T:ILNumerics.Core.StorageLayer.Storage`1"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.ILNumerics#Core#StorageLayer#IStorage#SetCellContentDirect(ILNumerics.Core.StorageLayer.IStorage,System.Int64*,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Sets a new value at the element as defined by <paramref name="indices"/>.
            </summary>
            <param name="value">The new value to be set directly. No clone will be made!</param>
            <param name="indices">Vector of the full index path, from root cell to the target element.</param>
            <param name="lenIndices">Number of indices stored in <paramref name="indices"/>.</param>
            <param name="start">First index in <paramref name="indices"/> to be considered.</param>
            <param name="allowExpand">Flag indicating which expansion mode to apply (numpy=false, ILNumericsV4=true).</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Clone">
            <summary>
            Creates a shallow copy of this storage. Does not copy the handles but only the storage object.
            </summary>
            <returns>Clone of this storage, sharing the memory handles with this storage.</returns>
            <remarks><para>The storage returned has an array reference count of 0. Reference
            counts for the (shared) handles are increased accordingly.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.New(System.UInt64,System.Boolean)">
            <summary>
            Create a new memory handle of <paramref name="elementLength"/> elements of the natural element type of this storage. 
            </summary>
            <param name="elementLength">Number of elements for the new handle.</param>
            <param name="clear">[optional] clear the new memory. Default: false.</param>
            <returns>The new handle according to the storage's internal element type.</returns>
            <remarks><para>This method is overriden for derived, specialized storages, where the actual element type used in memory differs from <typeparamref name="T"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.StorageLayer.LogicalStorage.New(System.UInt64,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Create(System.Int64,System.Boolean)">
            <summary>
            Extract quick scalar from this storage instance.
            </summary>
            <param name="v">BaseOffset for the new scalar.</param>
            <param name="fromRetArray">True: mutate this instance into a scalar, false: return a new storage.</param>
            <returns>Storage referencing a single element of this storage.</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Create(ILNumerics.Core.CountableArray)">
            <summary>
            Creates an <i>uninitialized</i> storage which remains in an <span color="red">INCONSISTENT STATE</span> until configured! Only Size &amp; m_handles are created.
            </summary>
            <param name="handles">[Optional] existing handles to be shared with the new storage. Reference counter is NOT changed!</param>
            <returns>INCONSTISTENT storage - needs configuration of host memory handle and size!</returns>
            <remarks><para>If <paramref name="handles"/> is provided, the storage returned holds these handles without changing its reference count. If no <paramref name="handles"/> 
            are provided the handles array of the returned storage will have a reference count of 1!</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Create(`0)">
            <summary>
            Provide a scalar storage with the value of <paramref name="scalar"/>.
            </summary>
            <param name="scalar">Value of the element of the new storage.</param>
            <returns>Storage of size 1x1, storing a single element with the value <paramref name="scalar"/>.</returns>
            <remarks><para>This will get the storage from the storage pool if possible. A new storage 
            is returned only if no matching  storage was available in the pool.</para>
            <para>The storage is created as column major storage. The number and lengths of the created 
            dimensions depend on the value of the configuration setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. 
            By default, this value is 2 and all arrays have at least two dimensions. In this case a #
            matrix of size [1, 1] is created. If the configured value for <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>
            is smaller than 2 a vector with the length [1] or a scalar array (ndims==0, nelem==1; numpy mode) is created.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Create(`0,System.UInt32)">
            <summary>
            Provide a storage for the provided scalar value.
            </summary>
            <param name="scalar">Value of the element of the new storage.</param>
            <param name="ndims">Number of (singleton) dimensions for the new array returned.</param>
            <returns>Storage of size as specified by <paramref name="ndims"/>, storing a single element 
            with the value <paramref name="scalar"/>.</returns>
            <remarks><para>The storage is created as column major storage. The number and lengths of the created 
            dimensions depend on the value of the configuration setting <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. 
            By default, this value is 2 and all arrays have at least two dimensions. In this case a #
            matrix of size [1, 1] is created. If the configured value for <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>
            is smaller than 2 a vector with the length [1] is created.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Create(ILNumerics.Core.CountableArray,ILNumerics.Size)">
            <summary>
            Povide a storage based on an existing <see cref="T:ILNumerics.Core.CountableArray"/> and a given size. 
            </summary>
            <param name="countablearray">The <see cref="T:ILNumerics.Core.CountableArray"/> to be used in the storage returned.</param>
            <param name="size">The source size to be copied. This object will not be altered. </param>
            <returns>A storage with the provided <paramref name="countablearray"/> and a size as given by <paramref name="size"/>.</returns>
            <remarks><para>The <see cref="T:ILNumerics.Core.CountableArray"/> <paramref name="countablearray"/> will be retained. The <paramref name="size"/>
            will be copied to the size structure of the returned storage.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Create(ILNumerics.Size,ILNumerics.StorageOrders,System.Int64)">
            <summary>
            Provide a storage according to the given <paramref name="size"/> and <paramref name="storageOrder"/>.
            </summary>
            <param name="size">The incoming size descriptor. This object will not be altered. It provides the dimension number and lengths only.</param>
            <param name="baseOffset">[Optional] Element base offset for the new storage. Default: 0.</param>
            <param name="storageOrder">The target storage order for this returned storage. Continous storage orders take preceedance over the actual storage order of <paramref name="size"/>.</param>
            <returns>Initialized storage with uninitialized memory accoriding to <paramref name="size"/> and <paramref name="storageOrder"/> to be filled with values in own algorithms.</returns>
            <remarks><para>If <paramref name="storageOrder"/> is <see cref="F:ILNumerics.StorageOrders.Other"/> the returned storage 
            has the same strides as <paramref name="size"/>. Otherwise <paramref name="storageOrder"/> is either <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/> and the new storage will be in that order, too.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.GetEnumerator(System.Nullable{ILNumerics.StorageOrders},System.Boolean)">
            <summary>
            Enumerator returning elements as T.
            </summary>
            <param name="dispose">If this parameter is true the storage will release itself after the enumerator has ended.</param>
            <remarks><para>This enumerator is yet to be optimized for speed!</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.GetHashCode">
            <summary>
            Generate a hash code based on the current element values.
            </summary>
            <returns>The hash code.</returns>
            <remarks>The hash code is generated by taking the values currently stored in the array into account.
            Therefore, the function must iterate over all elements in the array - which makes it a somehow expensive 
            operation. Take this into account when considering to use large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.</remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Detach(System.UInt32)">
            <summary>
            Makes sure that this array / storage can be written to without affecting any other arrays may sharing data, enabling write access. 
            </summary>
            <param name="targetDeviceID">[Optional] The device the current data of this storages device specific memory shall be copied onto.</param>
            <remarks>This function ensures that...
            <list type="bullet">
            <item>this storage uses memory which is not shared by other storages. If memory is currently shared, the 
            memorys data is copied to a new memory region which is then current to this storage.</item>
            </list>
            <para>Note that this function does not check whether this storage is shared by multiple arrays 
            (InArray, local array, output arrays, return arrays). While during common use and when accessing 
            a local array this local array will be the only array referencing the storage there are situations 
            when other arrays may reference a storage. Examples include the handling of input array types and 
            when local arrays (<see cref="T:ILNumerics.Array`1"/>) are defined as attributes of classes. Therefore, it is recommended
            to ensure that no other arrays currently exist which share this storage: <see cref="P:ILNumerics.Core.StorageLayer.BaseStorage`6.ReferenceCount"/> == 1. 
            If required, create a new local array and assign this array to it. If this storage was accessed through a 
            local array (<see cref="T:ILNumerics.Array`1"/>), assign by 
            <see cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/> as the right side of the assignment. 
            </para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Dispose">
            <summary>
            Disposes this storage. This releases all attached objects and transfers the storage and associated objects to the pools.
            </summary>
            <remarks><para>This expects the internal array counter to have the value 0, indicating that no array 
            is around anymore to reference this storage.</para>
            <para>In order to finish working with an ILNumerics array, one should call <see cref="M:ILNumerics.BaseArray.Release"/> on it.
            This <see cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Dispose"/> function is called internally. Users should not call it explicitly.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.GetSizeFromSystemArray(System.Array,ILNumerics.Size)">
            <summary>
            Configures <paramref name="size">input size</paramref> with the size according to the dimensions of A. 
            </summary>        
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.ToString">
            <summary>
            Create a textual representation of this storage.
            </summary>
            <returns>String containing general information about the current instance of 
            Storage and the formatted elements' values.</returns>
            <remarks>If the length of printed elements exceeds a certain value for a row, the printout will be abreviated.</remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.checkAdjustLimits(System.UInt32@,System.UInt32@,ILNumerics.StorageOrders)">
            <summary>
            Checks and adjusts the limits used for ToString()
            </summary>
            <param name="maxNumberElementsPerDim">[In/Out] Upper limit of elements displayed per dimension.</param>
            <param name="maxNumberElements">[In/Out] upper, hard limit of all elements displayed. </param>
            <param name="order">The storage order for the output. Row- /Column order.</param>
            <returns>The number of dimensions to be displayed. Any or both ref parameters may also be adjusted.</returns>
            <remarks><para>If the number of dimensions is too high and the actual number of elements per dimension would 
            lead to too many elements being shown the hard limit <paramref name="maxNumberElements"/> takes preceedence. 
            The number of dimension to be displayed is successively decreased until the resulting overall number of elements 
            drops below <paramref name="maxNumberElements"/>. For <paramref name="order"/> equal to <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            the last dimensions are skipped first. For <paramref name="order"/> equal to <see cref="F:ILNumerics.StorageOrders.RowMajor"/>
            first dimensions are skipped first. I.e: the 'important' dimensions are preferred for display.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)">
            <summary>
            Create new storage with the elements of this storage and <paramref name="other"/> storage concatenated along dimension <paramref name="dim"/>.
            </summary>
            <param name="other">The other storage. </param>
            <param name="dim">Dimension index to align both storages along.</param>
            <returns>New storage with elements of this and of the <paramref name="other"/> storage.</returns>
            <remarks><para>The size of both storages must match. This means that all but the dimension <paramref name="dim"/>
            must have the same lengths.</para></remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="dim"/> is not within the range of valid dimensions of any of both storages.</exception>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.EnsureStorageOrder(ILNumerics.StorageOrders,System.Boolean)">
            <summary>
            Ensures elements of this storage being layed out into a specific, continous storage order. 
            </summary>
            <param name="order"></param>
            <param name="forceCopy">Copy the elements to new memory, no matter if the order is correct already. (used by Detach()).</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.GetValue(System.Int64)">
            <summary>
            Retrieves the element at sequential position <paramref name="elementIndex"/>, assuming column major storage. 
            </summary>
            <param name="elementIndex">Linear index into the array. Matlab indexing style.</param>
            <returns>Copy of the value found.</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.GetValueSeq(System.Int64)">
            <summary>
            (Inefficiently) retrieves the element value of type <typeparamref name="T"/> at the memory position indicated by <paramref name="offset"/>.
            </summary>
            <param name="offset">Offset <i>in ELEMENTS</i> relative to the memory handle pointer <see cref="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Pointer"/> to start reading the element value.</param>
            <returns>The value found at the position <paramref name="offset"/>.</returns>
            <remarks><para>This method is provided for compatibility reasons only. It is recommended to use the closed type method extensions on <see cref="T:ILNumerics.Core.Arrays.ConcreteArray`6"/> 
            in order to prevent from having to copy arbitrary <typeparamref name="T"/> values.</para>
            <para>This method acts as a memory barrier. It waits (blocks) until all asynchronous operations <em>writing</em> to this storage have finished.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Repmat(ILNumerics.InArray{System.Int64})">
            <summary>
            Replicates this array along specified dimensions.
            </summary>
            <param name="rep">Array specifying the repetition factors along each dimension.</param>
            <returns>New storage with elements of this array being repeatedly copied as specified by <paramref name="rep"/>.</returns>
            <remarks></remarks>
            <exception cref="T:System.ArgumentNullException">If <paramref name="rep"/> is null.</exception>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.CreateSelf4Reshape(System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Prepares the return storage. Commonly, this copies the values if needed or gives a self-reference. This function is here to enable CellStorage to override.
            </summary>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.UInt32,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create flattened / reshaped version of this storage.
            </summary>
            <param name="d0">Length of vector/ number of elements.</param>
            <param name="order">Storage order of the output array.</param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.UInt32,System.UInt32,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 1.</param>
            <param name="d1">Number of elements along dim 2.</param>
            <param name="order">Storage order of the output array.</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.UInt32,System.UInt32,System.UInt32,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 1.</param>
            <param name="d1">Number of elements along dim 2.</param>
            <param name="d2">Number of elements along dim 3.</param>
            <param name="order">Storage order of the output array.</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 1.</param>
            <param name="d1">Number of elements along dim 2.</param>
            <param name="d2">Number of elements along dim 3.</param>
            <param name="d3">Number of elements along dim 4.</param>
            <param name="order">Storage order of the output array.</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 1.</param>
            <param name="d1">Number of elements along dim 2.</param>
            <param name="d2">Number of elements along dim 3.</param>
            <param name="d3">Number of elements along dim 4.</param>
            <param name="d4">Number of elements along dim 5.</param>
            <param name="order">Storage order of the output array.</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 1.</param>
            <param name="d1">Number of elements along dim 2.</param>
            <param name="d2">Number of elements along dim 3.</param>
            <param name="d3">Number of elements along dim 4.</param>
            <param name="d4">Number of elements along dim 5.</param>
            <param name="d5">Number of elements along dim 6.</param>
            <param name="order">Storage order of the output array.</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 1.</param>
            <param name="d1">Number of elements along dim 2.</param>
            <param name="d2">Number of elements along dim 3.</param>
            <param name="d3">Number of elements along dim 4.</param>
            <param name="d4">Number of elements along dim 5.</param>
            <param name="d5">Number of elements along dim 6.</param>
            <param name="d6">Number of elements along dim 7.</param>
            <param name="order">Storage order of the output array.</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Nullable{System.UInt32})">
            <summary>
            Create flattened / reshaped version of this storage. Allows one dimension length to be infered.
            </summary>
            <param name="d0">Length of vector/ number of elements.</param>
            <param name="order">Storage order of the output array.</param>
            <param name="minDims">[Optional] Minimum number of array dimensions. Default: null (<see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>).</param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Nullable{System.UInt32})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 1.</param>
            <param name="d1">Number of elements along dim 2.</param>
            <param name="order">Storage order of the output array.</param>
            <param name="minDims">[Optional] Minimum number of array dimensions. Default: null (<see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Nullable{System.UInt32})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 1.</param>
            <param name="d1">Number of elements along dim 2.</param>
            <param name="d2">Number of elements along dim 3.</param>
            <param name="order">Storage order of the output array.</param>
            <param name="minDims">[Optional] Minimum number of array dimensions. Default: null (<see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Nullable{System.UInt32})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 1.</param>
            <param name="d1">Number of elements along dim 2.</param>
            <param name="d2">Number of elements along dim 3.</param>
            <param name="d3">Number of elements along dim 4.</param>
            <param name="order">Storage order of the output array.</param>
            <param name="minDims">[Optional] Minimum number of array dimensions. Default: null (<see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Nullable{System.UInt32})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 1.</param>
            <param name="d1">Number of elements along dim 2.</param>
            <param name="d2">Number of elements along dim 3.</param>
            <param name="d3">Number of elements along dim 4.</param>
            <param name="d4">Number of elements along dim 5.</param>
            <param name="order">Storage order of the output array.</param>
            <param name="minDims">[Optional] Minimum number of array dimensions. Default: null (<see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Nullable{System.UInt32})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 1.</param>
            <param name="d1">Number of elements along dim 2.</param>
            <param name="d2">Number of elements along dim 3.</param>
            <param name="d3">Number of elements along dim 4.</param>
            <param name="d4">Number of elements along dim 5.</param>
            <param name="d5">Number of elements along dim 6.</param>
            <param name="order">Storage order of the output array.</param>
            <param name="minDims">[Optional] Minimum number of array dimensions. Default: null (<see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders},System.Nullable{System.UInt32})">
            <summary>
            Create reshaped version of this storage.
            </summary>
            <param name="d0">Number of elements along dim 1.</param>
            <param name="d1">Number of elements along dim 2.</param>
            <param name="d2">Number of elements along dim 3.</param>
            <param name="d3">Number of elements along dim 4.</param>
            <param name="d4">Number of elements along dim 5.</param>
            <param name="d5">Number of elements along dim 6.</param>
            <param name="d6">Number of elements along dim 7.</param>
            <param name="order">Storage order of the output array.</param>
            <param name="minDims">[Optional] Minimum number of array dimensions. Default: null (<see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>).</param>
            <returns>Reshaped array.</returns>
            <remarks><para>The storage order for both: the order for reading 
            the elements from this array and storing the element into the reshaped array is 
            determined as follows: </para>
            <list type="bullets">
            <item>If <paramref name="order"/> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>
            or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>) its value is used for the output. A copy is 
            made only if really needed.</item>
            <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> determins the 
            target storage order.</item>
            </list>
            <para>A copy of the elements is required for non-continous arrays and - except for 
            vector shaped arrays - for unmatching order settings.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.UInt32[],System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Reshape from lengths array.
            </summary>
            <param name="dimLengths">dimension lengths</param>
            <param name="order">target storage order</param>
            <returns>reshaped array</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Reshape(System.Int64[],System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Reshape from 'lengths' array.
            </summary>
            <param name="dimLengths">New dimension lengths.</param>
            <param name="order">Target storage order.</param>
            <returns>Reshaped array.</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.SetValue(`0,System.Int64*,System.UInt32,System.Boolean)">
            <summary>
            Helper method delegating array (long*) indices to individual SetValue(d0,d1,..) dimensional indices. Used by Cells deep indexing. 
            </summary>
            <param name="value"></param>
            <param name="indices"></param>
            <param name="lenIndices"></param>
            <param name="allowExpand"></param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.SetValueSeq(`0,System.Int64)">
            <summary>
            Sets a single value, generic version. This is not optimized for performance. Use SetValue(this A) extensions for speed!
            </summary>
            <param name="value">Generic value.</param>
            <param name="byteIdx">BYTE index of the handle's storage to store <paramref name="value"/> into. This must include any base offset and striding. See notes for ref types!</param>
            <remarks><para><paramref name="byteIdx"/> is scaled by the element size as acquired from <see cref="F:ILNumerics.Core.StorageLayer.BaseStorage`6.SizeOfT"/>. For value types this gived (mostly) the 
            result of <see cref="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)"/>. For reference types, however, <see cref="F:ILNumerics.Core.StorageLayer.BaseStorage`6.SizeOfT"/> gives 1. Hence, the scaling 
            expected here is the byte offset for value types and the element offset for reference types! !</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Swapaxis(System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Swaps 2 axes. 
            </summary>
            <param name="axis1">The first axis.</param>
            <param name="axis2">the second axis.</param>
            <param name="inplace">optimization flag. true: performs the swapping on this instance. False: return a new instance.</param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Expand(System.Int64[])">
            <summary>
            Creates a new storage similar to this storage with the given dimensions expanded to the specified lengths. 
            </summary>
            <param name="lengths">params(!) array with 0...[Size.MaxNumberOfDimensions] dimension lengths.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.GetRange_ML(ILNumerics.BaseArray,System.Boolean)">
            <summary>
            This must be virtual for CellStorage override. All other versions of GetRange_ML use iterateSubarrayML which is overridden by CellStorage also. 
            </summary>
            <param name="d0"></param>
            <param name="fromRetT"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.iterateSubarray_np(System.Int32,ILNumerics.Core.StorageLayer.Iterators.MultidimIterator*,System.Int32,System.Int64,System.Int64*,System.Int64**)">
            <summary>
            
            </summary>
            <param name="nIters">Number of multidim iterators in <paramref name="iterators"/>.</param>
            <param name="iterators">MultidimIterators according to the indices provided.</param>
            <param name="buffer">temp buffer, may used for additional, trailing MultidimIterators.</param>
            <param name="firstIDXArrayPos">Index of the first occurence of an index array in the list of iterators.</param>
            <param name="nrIdxOutDims">Number of dimensions stored in the array of index space dimension lenghts <paramref name="idxOutDims"/>.</param>
            <param name="idxOutDims">Index space dimension lengths of length <paramref name="nrIdxOutDims"/>.</param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.CopyTo_2_np(`5,`5,ILNumerics.Core.StorageLayer.Iterators.MultidimIterator*,System.UInt32,System.Int64)">
            <summary>
            
            </summary>
            <param name="srcStorage"></param>
            <param name="destStorage"></param>
            <param name="itP">prepared array of iterators.</param>
            <param name="nIter"></param>
            <param name="baseOffset">Base offset in element unit.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.CopyTo_16_np(`5,`5,ILNumerics.Core.StorageLayer.Iterators.MultidimIterator*,System.UInt32,System.Int64)">
            <summary>
            
            </summary>
            <param name="srcStorage"></param>
            <param name="destStorage"></param>
            <param name="itP">prepared array of iterators.</param>
            <param name="nIter"></param>
            <param name="baseOffset">Base offset in element unit.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.CopyTo_8_np(`5,`5,ILNumerics.Core.StorageLayer.Iterators.MultidimIterator*,System.UInt32,System.Int64)">
            <summary>
            
            </summary>
            <param name="srcStorage"></param>
            <param name="destStorage"></param>
            <param name="itP">prepared array of iterators.</param>
            <param name="nIter"></param>
            <param name="baseOffset">Base offset in element unit.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.CopyTo_4_np(`5,`5,ILNumerics.Core.StorageLayer.Iterators.MultidimIterator*,System.UInt32,System.Int64)">
            <summary>
            
            </summary>
            <param name="srcStorage"></param>
            <param name="destStorage"></param>
            <param name="itP">prepared array of iterators.</param>
            <param name="nIter"></param>
            <param name="baseOffset">Base offset in element unit.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.CopyTo_1_np(`5,`5,ILNumerics.Core.StorageLayer.Iterators.MultidimIterator*,System.UInt32,System.Int64)">
            <summary>
            
            </summary>
            <param name="srcStorage"></param>
            <param name="destStorage"></param>
            <param name="itP">prepared array of iterators.</param>
            <param name="nIter"></param>
            <param name="baseOffset">Base offset in element unit.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.CopyTo_Arbitrary_np(`5,`5,ILNumerics.Core.StorageLayer.Iterators.MultidimIterator*,System.UInt32,System.Int64,System.UInt32)">
            <summary>
            
            </summary>
            <param name="srcStorage"></param>
            <param name="destStorage"></param>
            <param name="itP">prepared array of iterators.</param>
            <param name="nIter"></param>
            <param name="baseOffset">Base offset in element unit.</param>
            <param name="elementSize">Size of a single element in bytes</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.createMultidimIteratorBool(ILNumerics.Core.StorageLayer.LogicalStorage,System.UInt32,System.UInt32*,System.UInt32*,System.Int64*,System.Int64*,System.Int64**,ILNumerics.Core.StorageLayer.Iterators.MultidimIterator@,System.Int64,System.UInt32)">
            <summary>
            Setup multidim iterator for one dimension of a given boolean array.
            </summary>
            <param name="A"></param>
            <param name="index">The dimension index of the bool index array this iterator it to be set up for. </param>
            <param name="setCount"></param>
            <param name="nrIdxOutDims"></param>
            <param name="idxOutDims"></param>
            <param name="idxCurPos"></param>
            <param name="buffer"></param>
            <param name="iter"></param>
            <param name="lastDimIdx"></param>
            <param name="inputDimIdx"></param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.SetFullOptim(`5)">
            <summary>
            like Assign, take strides but keep current size
            </summary>
            <param name="value">right side of assignment</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_ML_IterIter_2(`5,ILNumerics.IIndexIterator[],System.UInt32)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage determined by <paramref name="outIterators"/>. No broadcasting!
            </summary>
            <param name="value"></param>
            <param name="outIterators"></param>
            <param name="ndimsOut">Number of iterators in <paramref name="outIterators"/> to consider.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_ML_BSDIter_2(`5,System.Int64*)">
            <summary>
            Copies values from <paramref name="value"/>, to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting!
            </summary>
            <param name="value">src values of the copy. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_ML_IterIter_16(`5,ILNumerics.IIndexIterator[],System.UInt32)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage determined by <paramref name="outIterators"/>. No broadcasting!
            </summary>
            <param name="value"></param>
            <param name="outIterators"></param>
            <param name="ndimsOut">Number of iterators in <paramref name="outIterators"/> to consider.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_ML_BSDIter_16(`5,System.Int64*)">
            <summary>
            Copies values from <paramref name="value"/>, to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting!
            </summary>
            <param name="value">src values of the copy. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_ML_IterIter_8(`5,ILNumerics.IIndexIterator[],System.UInt32)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage determined by <paramref name="outIterators"/>. No broadcasting!
            </summary>
            <param name="value"></param>
            <param name="outIterators"></param>
            <param name="ndimsOut">Number of iterators in <paramref name="outIterators"/> to consider.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_ML_BSDIter_8(`5,System.Int64*)">
            <summary>
            Copies values from <paramref name="value"/>, to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting!
            </summary>
            <param name="value">src values of the copy. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_ML_IterIter_4(`5,ILNumerics.IIndexIterator[],System.UInt32)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage determined by <paramref name="outIterators"/>. No broadcasting!
            </summary>
            <param name="value"></param>
            <param name="outIterators"></param>
            <param name="ndimsOut">Number of iterators in <paramref name="outIterators"/> to consider.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_ML_BSDIter_4(`5,System.Int64*)">
            <summary>
            Copies values from <paramref name="value"/>, to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting!
            </summary>
            <param name="value">src values of the copy. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_ML_IterIter_1(`5,ILNumerics.IIndexIterator[],System.UInt32)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage determined by <paramref name="outIterators"/>. No broadcasting!
            </summary>
            <param name="value"></param>
            <param name="outIterators"></param>
            <param name="ndimsOut">Number of iterators in <paramref name="outIterators"/> to consider.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_ML_BSDIter_1(`5,System.Int64*)">
            <summary>
            Copies values from <paramref name="value"/>, to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting!
            </summary>
            <param name="value">src values of the copy. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_ML_IterIter_Arbitrary(`5,ILNumerics.IIndexIterator[],System.UInt32,System.UInt32)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage determined by <paramref name="outIterators"/>. No broadcasting!
            </summary>
            <param name="value"></param>
            <param name="outIterators"></param>
            <param name="ndimsOut">Number of iterators in <paramref name="outIterators"/> to consider.</param>
            <param name="elementSize">single element size in bytes</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_ML_BSDIter_Arbitrary(System.Byte*,`5,System.Int64*,System.UInt32)">
            <summary>
            Copies values from <paramref name="value"/>, to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting!
            </summary>
            <param name="value">src values of the copy. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
            <param name="elementSize">Single element size in bytes.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_ML_BSDIter_T(`5,System.Int64*)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting!
            </summary>
            <param name="value">src values of the copy. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_np_IterIter_2(`5,ILNumerics.IIndexIterator[],System.UInt32)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage determined by <paramref name="outIterators"/>. No broadcasting!
            </summary>
            <param name="value"></param>
            <param name="outIterators"></param>
            <param name="ndimsOut">Number of iterators in <paramref name="outIterators"/> to consider.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_np_BSDIter_2(`5,System.Int64*)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting!
            </summary>
            <param name="value">src values of the copy. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_np_IterIter_16(`5,ILNumerics.IIndexIterator[],System.UInt32)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage determined by <paramref name="outIterators"/>. No broadcasting!
            </summary>
            <param name="value"></param>
            <param name="outIterators"></param>
            <param name="ndimsOut">Number of iterators in <paramref name="outIterators"/> to consider.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_np_BSDIter_16(`5,System.Int64*)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting!
            </summary>
            <param name="value">src values of the copy. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_np_IterIter_8(`5,ILNumerics.IIndexIterator[],System.UInt32)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage determined by <paramref name="outIterators"/>. No broadcasting!
            </summary>
            <param name="value"></param>
            <param name="outIterators"></param>
            <param name="ndimsOut">Number of iterators in <paramref name="outIterators"/> to consider.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_np_BSDIter_8(`5,System.Int64*)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting!
            </summary>
            <param name="value">src values of the copy. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_np_IterIter_4(`5,ILNumerics.IIndexIterator[],System.UInt32)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage determined by <paramref name="outIterators"/>. No broadcasting!
            </summary>
            <param name="value"></param>
            <param name="outIterators"></param>
            <param name="ndimsOut">Number of iterators in <paramref name="outIterators"/> to consider.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_np_BSDIter_4(`5,System.Int64*)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting!
            </summary>
            <param name="value">src values of the copy. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_np_IterIter_1(`5,ILNumerics.IIndexIterator[],System.UInt32)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage determined by <paramref name="outIterators"/>. No broadcasting!
            </summary>
            <param name="value"></param>
            <param name="outIterators"></param>
            <param name="ndimsOut">Number of iterators in <paramref name="outIterators"/> to consider.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_np_BSDIter_1(`5,System.Int64*)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting!
            </summary>
            <param name="value">src values of the copy. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_np_BSDIter_Arbitrary(`5,System.Int64*,System.UInt32)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting!
            </summary>
            <param name="value">src values of the copy. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
            <param name="elementSize">Single element size in bytes.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_np_IterIter_Arbitrary(`5,ILNumerics.IIndexIterator[],System.UInt32,System.UInt32)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage determined by <paramref name="outIterators"/>. No broadcasting!
            </summary>
            <param name="value"></param>
            <param name="outIterators"></param>
            <param name="ndimsOut">Number of iterators in <paramref name="outIterators"/> to consider.</param>
            <param name="elementSize">Single element size in bytes.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_np_BSDIter_T(`5,System.Int64*)">
            <summary>
            Copies values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting!
            </summary>
            <param name="value">src values of the copy. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_2_np(`5,`5,ILNumerics.Core.StorageLayer.Iterators.MultidimIterator*,System.Int64*,System.UInt32,System.UInt32,System.Int64,System.Int64**)">
            <summary>
            
            </summary>
            <param name="srcStorage"></param>
            <param name="destStorage"></param>
            <param name="itP">prepared array of iterators.</param>
            <param name="nIter"></param>
            <param name="outDims"></param>
            <param name="buffer"></param>
            <param name="nOutDims"></param>
            <param name="outBaseOffset"></param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_16_np(`5,`5,ILNumerics.Core.StorageLayer.Iterators.MultidimIterator*,System.Int64*,System.UInt32,System.UInt32,System.Int64,System.Int64**)">
            <summary>
            
            </summary>
            <param name="srcStorage"></param>
            <param name="destStorage"></param>
            <param name="itP">prepared array of iterators.</param>
            <param name="nIter"></param>
            <param name="outDims"></param>
            <param name="buffer"></param>
            <param name="nOutDims"></param>
            <param name="outBaseOffset"></param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_8_np(`5,`5,ILNumerics.Core.StorageLayer.Iterators.MultidimIterator*,System.Int64*,System.UInt32,System.UInt32,System.Int64,System.Int64**)">
            <summary>
            
            </summary>
            <param name="srcStorage"></param>
            <param name="destStorage"></param>
            <param name="itP">prepared array of iterators.</param>
            <param name="nIter"></param>
            <param name="outDims"></param>
            <param name="buffer"></param>
            <param name="nOutDims"></param>
            <param name="outBaseOffset"></param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_4_np(`5,`5,ILNumerics.Core.StorageLayer.Iterators.MultidimIterator*,System.Int64*,System.UInt32,System.UInt32,System.Int64,System.Int64**)">
            <summary>
            
            </summary>
            <param name="srcStorage"></param>
            <param name="destStorage"></param>
            <param name="itP">prepared array of iterators.</param>
            <param name="nIter"></param>
            <param name="outDims"></param>
            <param name="buffer"></param>
            <param name="nOutDims"></param>
            <param name="outBaseOffset"></param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_1_np(`5,`5,ILNumerics.Core.StorageLayer.Iterators.MultidimIterator*,System.Int64*,System.UInt32,System.UInt32,System.Int64,System.Int64**)">
            <summary>
            
            </summary>
            <param name="srcStorage"></param>
            <param name="destStorage"></param>
            <param name="itP">prepared array of iterators.</param>
            <param name="nIter"></param>
            <param name="outDims"></param>
            <param name="buffer"></param>
            <param name="nOutDims"></param>
            <param name="outBaseOffset"></param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.BaseStorage`6.WriteTo_Arbitrary_np(`5,`5,ILNumerics.Core.StorageLayer.Iterators.MultidimIterator*,System.Int64*,System.UInt32,System.UInt32,System.Int64,System.Int64**,System.UInt32)">
            <summary>
            
            </summary>
            <param name="srcStorage"></param>
            <param name="destStorage"></param>
            <param name="itP">prepared array of iterators.</param>
            <param name="nIter"></param>
            <param name="outDims"></param>
            <param name="buffer"></param>
            <param name="nOutDims"></param>
            <param name="outBaseOffset"></param>
            <param name="elementSize">Single element size in bytes.</param>
        </member>
        <member name="T:ILNumerics.Core.StorageLayer.ExtensionMethods">
            <summary>
            Extension methods on base arrays.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.ExtensionMethods.GetLimits(ILNumerics.Core.StorageLayer.BaseStorage{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Double@,System.Double@,System.Boolean)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="storage"/>, optionally ignoring special floating point values.
            </summary>
            <param name="storage">Input storage.</param>
            <param name="min">[Output] The minimum value in <paramref name="storage"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="storage"/>.</param>
            <param name="ignoreInfinity">[Optional] When true only non-infinity and non-NaN values will be considered as regular values. Default: false.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input 
            <paramref name="storage"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="storage"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            <para>The optional parameter <paramref name="ignoreInfinity"/> is useful, for example, to determine the 
            minimum and maximum values stored inside this storage in order to find scaling factors and for 
            normalization purposes. Here, <see cref="F:System.Double.NegativeInfinity"/> and <see cref="F:System.Double.PositiveInfinity"/>
            can be ignored since they would be not useful as scaling factors. For the default value ('false')
            infinity values are considered regular values and contribute to the result.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="storage"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.ExtensionMethods.GetLimits(ILNumerics.Core.StorageLayer.BaseStorage{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Single@,System.Single@,System.Boolean)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="storage"/>, optionally ignoring special floating point values.
            </summary>
            <param name="storage">Input storage.</param>
            <param name="min">[Output] The minimum value in <paramref name="storage"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="storage"/>.</param>
            <param name="ignoreInfinity">[Optional] When true only non-infinity and non-NaN values will be considered as regular values. Default: false.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input 
            <paramref name="storage"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="storage"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            <para>The optional parameter <paramref name="ignoreInfinity"/> is useful, for example, to determine the 
            minimum and maximum values stored inside this storage in order to find scaling factors and for 
            normalization purposes. Here, <see cref="F:System.Single.NegativeInfinity"/> and <see cref="F:System.Single.PositiveInfinity"/>
            can be ignored since they would be not useful as scaling factors. For the default value ('false')
            infinity values are considered regular values and contribute to the result.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="storage"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.ExtensionMethods.GetLimits(ILNumerics.Core.StorageLayer.BaseStorage{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.complex@,ILNumerics.complex@,System.Boolean)">
            <summary>
            Finds the minimum and maximum values among the real parts and the imaginary parts of all elements of <paramref name="storage"/>, optionally ignoring special floating point values.
            </summary>
            <param name="storage">Input storage.</param>
            <param name="min">[Output] The minimum value in <paramref name="storage"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="storage"/>.</param>
            <param name="ignoreInfinity">[Optional] When true only non-infinity and non-NaN values will be considered as regular values. Default: false.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input 
            <paramref name="storage"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="storage"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            <para>The optional parameter <paramref name="ignoreInfinity"/> is useful, for example, to determine the 
            minimum and maximum values stored inside this storage in order to find scaling factors and for 
            normalization purposes. Here, <see cref="F:System.Double.NegativeInfinity"/> and <see cref="F:System.Double.PositiveInfinity"/>
            can be ignored since they would be not useful as scaling factors. For the default value ('false')
            infinity values are considered regular values and contribute to the result.</para>
            <para>If the method returns false the values of the real parts of the output parameters <paramref name="min"/> 
            and <paramref name="max"/> are <see cref="F:System.Double.NaN"/> if no limit could have been computed for the real parts. Similarly, 
            the imaginary parts are <see cref="F:System.Double.NaN"/> if no limit could be found among the imaginary parts. If only one valid range could 
            be found (either among the real parts or among the imaginary parts) the corresponding part of  <paramref name="min"/> 
            and <paramref name="max"/> carry the limits found and the other part will be <see cref="F:System.Double.NaN"/>.</para> 
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="storage"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.ExtensionMethods.GetLimits(ILNumerics.Core.StorageLayer.BaseStorage{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.fcomplex@,ILNumerics.fcomplex@,System.Boolean)">
            <summary>
            Finds the minimum and maximum values among the real parts and the imaginary parts of all elements of <paramref name="storage"/>, optionally ignoring special floating point values.
            </summary>
            <param name="storage">Input storage.</param>
            <param name="min">[Output] The minimum value in <paramref name="storage"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="storage"/>.</param>
            <param name="ignoreInfinity">[Optional] When true only non-infinity and non-NaN values will be considered as regular values. Default: false.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input 
            <paramref name="storage"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="storage"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            <para>The optional parameter <paramref name="ignoreInfinity"/> is useful, for example, to determine the 
            minimum and maximum values stored inside this storage in order to find scaling factors and for 
            normalization purposes. Here, <see cref="F:System.Double.NegativeInfinity"/> and <see cref="F:System.Double.PositiveInfinity"/>
            can be ignored since they would be not useful as scaling factors. For the default value ('false')
            infinity values are considered regular values and contribute to the result.</para>
            <para>If the method returns false the values of the real parts of the output parameters <paramref name="min"/> 
            and <paramref name="max"/> are <see cref="F:System.Double.NaN"/> if no limit could have been computed for the real parts. Similarly, 
            the imaginary parts are <see cref="F:System.Double.NaN"/> if no limit could be found among the imaginary parts. If only one valid range could 
            be found (either among the real parts or among the imaginary parts) the corresponding part of  <paramref name="min"/> 
            and <paramref name="max"/> carry the limits found and the other part will be <see cref="F:System.Double.NaN"/>.</para> 
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="storage"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.ExtensionMethods.GetLimits(ILNumerics.Core.StorageLayer.BaseStorage{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.SByte@,System.SByte@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="storage"/>.
            </summary>
            <param name="storage">Input storage.</param>
            <param name="min">[Output] The minimum value in <paramref name="storage"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="storage"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input 
            <paramref name="storage"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="storage"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="storage"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.ExtensionMethods.GetLimits(ILNumerics.Core.StorageLayer.BaseStorage{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.UInt64@,System.UInt64@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="storage"/>.
            </summary>
            <param name="storage">Input storage.</param>
            <param name="min">[Output] The minimum value in <paramref name="storage"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="storage"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input 
            <paramref name="storage"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="storage"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="storage"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.ExtensionMethods.GetLimits(ILNumerics.Core.StorageLayer.BaseStorage{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int64@,System.Int64@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="storage"/>.
            </summary>
            <param name="storage">Input storage.</param>
            <param name="min">[Output] The minimum value in <paramref name="storage"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="storage"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input 
            <paramref name="storage"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="storage"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="storage"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.ExtensionMethods.GetLimits(ILNumerics.Core.StorageLayer.BaseStorage{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.UInt32@,System.UInt32@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="storage"/>.
            </summary>
            <param name="storage">Input storage.</param>
            <param name="min">[Output] The minimum value in <paramref name="storage"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="storage"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input 
            <paramref name="storage"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="storage"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="storage"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.ExtensionMethods.GetLimits(ILNumerics.Core.StorageLayer.BaseStorage{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.UInt16@,System.UInt16@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="storage"/>.
            </summary>
            <param name="storage">Input storage.</param>
            <param name="min">[Output] The minimum value in <paramref name="storage"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="storage"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input 
            <paramref name="storage"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="storage"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="storage"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.ExtensionMethods.GetLimits(ILNumerics.Core.StorageLayer.BaseStorage{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int16@,System.Int16@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="storage"/>.
            </summary>
            <param name="storage">Input storage.</param>
            <param name="min">[Output] The minimum value in <paramref name="storage"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="storage"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input 
            <paramref name="storage"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="storage"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="storage"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.ExtensionMethods.GetLimits(ILNumerics.Core.StorageLayer.BaseStorage{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Byte@,System.Byte@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="storage"/>.
            </summary>
            <param name="storage">Input storage.</param>
            <param name="min">[Output] The minimum value in <paramref name="storage"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="storage"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input 
            <paramref name="storage"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="storage"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="storage"/> is empty.</exception>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.ExtensionMethods.GetLimits(ILNumerics.Core.StorageLayer.BaseStorage{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32@,System.Int32@)">
            <summary>
            Finds the minimum and maximum values among all elements of <paramref name="storage"/>.
            </summary>
            <param name="storage">Input storage.</param>
            <param name="min">[Output] The minimum value in <paramref name="storage"/>.</param>
            <param name="max">[Output] The maximum value in <paramref name="storage"/>.</param>
            <returns>True, if the minimum and maximum values could be computed. False otherwise.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input 
            <paramref name="storage"/> in a single run.</para>
            <para>The operation is performed in multiple threads, according to the current settings 
            of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input <paramref name="storage"/> is not altered.</para>
            <para>The function always succeeds and returns <c>true</c> for non-empty arrays of integer 
            (non-floating point) element types. Overloads for floating point element types:
            the function succeeds on non-empty arrays which have at least one element other than NaN.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="storage"/> is empty.</exception>
        </member>
        <member name="T:ILNumerics.Core.StorageLayer.Iterators.BoolIndexIterator_ML">
            <summary>
            Specialized iterator for ML logical indexing. Does not work with numpy scalars or empty arrays.
            </summary>
            <remarks>
            <para>This iterator takes an n-dim logical index array and iterates over the <i>sequential indices</i> of 
            its true elements in <i>column major order</i>. No support for numeric index arrays. No support for shared index arrays in the same index space set.</para>
            <para>This struct is derived from MultidimIterators_np (implementation wise). It is NOT a struct 
            since it will always be used boxed into a IIndexIterator interface (ML style subarray expressions involving Logical arrays -> see: GetRange_ML / SetRange_ML). 
            The iterator is capable of iterating over the bool storage without a consolidating index array for the element
            positions of the true elements. It performs best for small bool indides and when the bool index does not need 
            to be iterated over multiple times.</para>
            <para>No checks are made for the length of dimensions / indices being within an allowed range etc. All checks must be made 
            by the user of the class.</para>
            <para>Implementation notes: Similar to MultidimIterator_np this logical iterator DOES NOT accept numpy scalars (0 dim)
            bool arrays. This should naturally happen rarely: such scalars are created 
            in numpy ArrayStyle only. However, we are working around this as follows: numpy scalars are presented as 1D arrays by 
            providing strides and dims pointer which point to the '1' describing "Number of Elements" in the original BSD[1] element. 
            The m_nrDims attribute of this isterator is set to 1 than and the original strides and dims pointer from the arrays 
            BSD can be reused in the iterator. Hence, the iterator really ever sees arrays with 1D or more.</para></remarks>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.BoolIndexIterator_ML.m_indexArrayBase">
            <summary>
            byte pointer to index array storage, if any
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.BoolIndexIterator_ML.m_nrDims">
            <summary>
            number of dimensions of this indexing array and the broadcasted result _for this input dimension_, number of entries in m_curPos and m_outDims.
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.BoolIndexIterator_ML.m_offset">
            <summary>
            Offset in elements unit for the initial first element regarding the base offset (if exists, otherwise - for slices and scalars - regarding 0).
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.BoolIndexIterator_ML.m_strides">
            <summary>
            Strides of all m_nrDims index array dimensions, in bytes(!). This is individual for each index array in a set. (while curPos &amp; outDims are shared.) For slices this holds the bsd and other supporting data for iterating the actual bool array (instead of the 'virtual' index arrays derived from it). Element size unit.
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.BoolIndexIterator_ML.m_outDims">
            <summary>
            Result shape this index array must be broadcasted to. These values may change after initialization - but before iteration starts. 
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.BoolIndexIterator_ML.m_curPos">
            <summary>
            Current position in the iteration. Shared between all index arrays in a set. 
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.BoolIndexIterator_ML.m_maxIdx">
            <summary>
            the last index in the source dimension. Used for translating neg. index values during iteration. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.Iterators.BoolIndexIterator_ML.#ctor(System.Byte*,System.UInt32,System.Int64*,System.Int64*,System.Int64*,System.Int64,ILNumerics.Core.Arrays.IVolatile,System.Int64,System.Int64)">
            <summary>
            Initialize existing multi dim iterator struct for another array
            </summary>
            <param name="baseP">base pointer address as byte* pointer, including any base offset.</param>
            <param name="nrDims">Lengths of strides, outDims and curPos. Greater or equal to 1.</param>
            <param name="outDims">broadcasted size of target iteration shape, in bytes(!). This may change after initialization but before the iteration starts.</param>
            <param name="strides">Strides of the arrays dimensions.</param>
            <param name="curPos">temp position buffer of length according to <paramref name="nrDims"/>.Subject to change before iteration starts.</param>
            <param name="lastDimIdx">Index of the last element in the dimension this iterator will be applied to. </param>
        </member>
        <member name="P:ILNumerics.Core.StorageLayer.Iterators.BoolIndexIterator_ML.Current">
            <summary>
            Gets the current value this iterator points to. This must be called only, when MoveNext() had been succeeded.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.Iterators.BoolIndexIterator_ML.MoveNext">
            <summary>
            Moves the iterators cursor to the next position. Column major order.  
            </summary>
            <returns>True if the iterator was successfully incremented. Otherwise false is returned.</returns>
            <remarks>The iterator remains in consistent state, regardless of the result. If false is returned <see cref="P:ILNumerics.Core.StorageLayer.Iterators.BoolIndexIterator_ML.Current"/> remains on the last element of the collection.</remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.Iterators.BoolIndexIterator_ML.Reset">
            <summary>
            Resets this iterator and all other iterators sharing the same curPos buffer to initial state (before first position).
            </summary>
        </member>
        <member name="T:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator">
            <summary>
            Specialized, unified iterator struct for numpy advanced indexing.
            </summary>
            <remarks><para>This struct is stored as item in an unmanaged array. The iterator is capable of iterating all supported index types without the need for virtual calls.</para></remarks>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.m_index">
            <summary>
            Index of the original(!) dimension this iterator is addressing. (may be reordered)
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.m_setCount">
            <summary>
            Gives the number of index arrays forming the set of advanced indices.  
            </summary>
            <remarks>Advanced indices are grouped and handled synchronously in MoveNext / Reset(). This 
            value determines the number of grouped members / adjacent iterators to be incremented at the same time.
            </remarks>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.m_indexArrayBase">
            <summary>
            byte pointer to index array storage, if any
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.m_elementType">
            <summary>
            element type of indices. None for slices. 
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.m_nrDims">
            <summary>
            number of dimensions of this indexing array and the broadcasted result _for this input dimension_, number of entries in m_curPos and m_outDims.
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.m_offset">
            <summary>
            Offset in elements unit for the initial first element regarding the base offset (if exists, otherwise - for slices and scalars - regarding 0).
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.m_strides">
            <summary>
            Strides of all m_nrDims index array dimensions, in bytes(!). This is individual for each index array in a set. (while curPos &amp; outDims are shared.) For slices this holds the bsd and other supporting data for iterating the actual bool array (instead of the 'virtual' index arrays derived from it). Element size unit.
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.m_outDims">
            <summary>
            Result shape this index array must be broadcasted to. These values may change after initialization - but before iteration starts. 
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.m_curPos">
            <summary>
            Current position in the iteration. Shared between all index arrays in a set. 
            </summary>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.m_inStride">
            <summary>
            The stride between elements of this dimension in the input array being indexed, in elements unit(!).
            </summary>
            <remarks>This value is cached here for convenient access during iteration and so that it is re-sorted with the advanced indices if required.</remarks>
        </member>
        <member name="F:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.m_lastDimIdx">
            <summary>
            the last index in the source dimension. Used for translating neg. index values during iteration. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.Set(ILNumerics.Core.StorageLayer.Iterators.MultidimIterator@,System.UInt32,System.Byte*,ILNumerics.NumericType,System.UInt32*,System.Int64,System.Int64*,System.Int64*,System.Int64*,System.Int64,System.UInt32*,System.Int64)">
            <summary>
            Initialize existing multi dim iterator struct for another array
            </summary>
            <param name="it">target iterator struct</param>
            <param name="baseP">base pointer address as byte* pointer, including any base offset.</param>
            <param name="elementType">numeric element type code</param>
            <param name="nrDims">Lengths of strides, outDims and curPos. Greater or equal to 1. Subject to change before iteration starts!</param>
            <param name="outDims">broadcasted size of target iteration shape, in bytes(!). This may change after initialization but before the iteration starts.</param>
            <param name="strides">Strides of the arrays dimensions.</param>
            <param name="curPos">temp position buffer of length according to <paramref name="nrDims"/>.Subject to change before iteration starts.</param>
            <param name="lastDimIdx">Index of the last element in the dimension this iterator will be applied to. </param>
            <param name="setCount">Pointer to the variable counting the number of advanced indices. Subject to change before iteration starts. </param>
            <param name="index">Index of (input) dimension. Used for error reporting only. Bool array: index of the subspace dimension spaned by the index bool array.</param>
            <param name="outStride">Spacing between elements of the output array in the dimension addressed by <paramref name="index"/>, in elements(!).</param>
            <param name="offset">Offset of the first element relative to the baseP (if exists) or to 0 (slice, scalar), in bytes.</param>
        </member>
        <member name="P:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.Current">
            <summary>
            Gets the current value this iterator points to. This must be called only, when MoveNext() had been succeeded.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.MoveNext">
            <summary>
            Moves the iterators cursor to the next position. Column major order.  
            </summary>
            <returns>True if the iterator was successfully incremented. Otherwise false is returned.</returns>
            <remarks>The iterator remains in consistent state, regardless of the result. If false is returned <see cref="P:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.Current"/> remains on the last element of the collection.</remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.Iterators.MultidimIterator.Reset">
            <summary>
            Resets this iterator and all other iterators sharing the same curPos buffer to initial state (before first position).
            </summary>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.Iterators.BroadcastingSizeRowMajorIterator.#ctor(ILNumerics.Size,System.Int64*,System.UInt32,System.Int64**)">
            <summary>
            Create a new broadcasting iterator for the given shapes / sizes. 
            </summary>
            <param name="size">Size object of the array to iterate.</param>
            <param name="bcSize">[In] required broadcasting size.</param>
            <param name="nrOutDims">Number of dimensions given in <paramref name="bcSize"/>. This can be different from <see cref="P:ILNumerics.Size.NumberOfDimensions"></see>.</param>
            <param name="buffer">pointer to address space of min length <paramref name="nrOutDims"/> * 3.</param>
        </member>
        <member name="T:ILNumerics.Core.StorageLayer.CellStorage">
            <summary>
            Internal class, storage container for generic, partially typed ILNumerics arrays. This class is used internally. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.Create(ILNumerics.Size)">
            <summary>
            Create new storage for the given size. Elements are uninitialized! 
            </summary>
            <param name="size">Size for the new storage.</param>
            <returns>Storage, capable of storing an array of a size according to <paramref name="size"/>.</returns>
            <remarks><para>This will get the storage from the storage pool if possible. A new storage 
            is returned only if no matchine storage was available in the pool.</para>
            <para>The storage is created as column major storage. Only the number and lengths of <paramref name="size"/>
            are considered. Striding is recreated (column major) and base offset will be 0.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.Create(System.Int64,System.Boolean)">
            <summary>
            Extract (not so) quick scalar from this cell storage.
            </summary>
            <param name="v">BaseOffset for the new scalar.</param>
            <param name="fromRetArray">ignored</param>
            <returns>New storage referencing a clone made from a single element of this storage.</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.New(System.UInt64,System.Boolean)">
            <summary>
            Create a new memory handle of <paramref name="elementLength"/> elements of the <see cref="T:ILNumerics.Core.StorageLayer.IStorage"/> element type. 
            </summary>
            <param name="elementLength">Number of elements for the new handle.</param>
            <param name="clear">[optional] clear the new memory. Default: false.</param>
            <returns>The new handle according to the storage's internal element type.</returns>
            <remarks><para>This method is overriden for derived, specialized storages, where the actual element type used in memory differs from <typeparamref name="T"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.StorageLayer.LogicalStorage.New(System.UInt64,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.StorageLayer.CellStorage.New(System.UInt64,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.CreateSelf4Reshape(System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Prepares the return storage. Commonly, this copies the values if needed or gives a self-reference. CellStorage overrides it to ensure proper cloning.
            </summary>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.SetValueSeq(ILNumerics.BaseArray,System.Int64)">
            <summary>
            Replaces a single element of this cell storage with a clone of <paramref name="value"/>.
            </summary>
            <param name="value">Array to be cloned and stored. This method does not release <paramref name="value"/>!</param>
            <param name="byteIdx">BYTE offset of the storage element position. This will be transformed into an element offset in the method.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.GetValueSeq(System.Int64)">
            <summary>
            Retrieves a clone of the cell content at sequential position <paramref name="offset"/>.
            </summary>
            <param name="offset">Element position as element offset relative to the base address, including strides.</param>
            <returns>Clone of the element as position <paramref name="offset"/> or null.</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.WriteTo_ML_BSDIter_T(ILNumerics.Core.StorageLayer.CellStorage,System.Int64*)">
            <summary>
            Clones cell values from <paramref name="value"/>, regardless of shape(!) to the parts of this storage as determined by <paramref name="outBSD"/>. No broadcasting! 
            </summary>
            <param name="value">src values of the cell. The right side of the assignment.</param>
            <param name="outBSD">set of BSD describing the parts to be overwritten.</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.ILNumerics#Core#StorageLayer#IStorage#GetBaseArrayClone">
            <summary>
            Gives a shallow clone of this array: new array object, same memory. 
            </summary>
            <returns>Clone of this array as return type array.</returns>
            <see cref="M:ILNumerics.BaseArray.IsOfType``1"/>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.Clone">
            <summary>
            Creates a shallow copy of this storage. It copies the cells recursively but shares the memory of arrays in cell elements.
            </summary>
            <returns>Clone of this storage, sharing the memory handles with this storage.</returns>
            <remarks><para>The storage returned has an array reference count of 0. Reference
            counts for the (shared) handles are increased accordingly.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.CopyTo(ILNumerics.Core.MemoryLayer.MemoryHandle,ILNumerics.Size,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Copy the data of this array to another memory region, specify element storage order for writing. 
            </summary>
            <param name="dest">Pointer to a memory region, large enough to store all elements of this array in the storage layout given by <paramref name="layout"/>.</param>
            <param name="outSize">[Output] On return the size descriptor holds the dimension lengths and strides according to the size of this array and the specified <paramref name="layout"/>.</param>
            <param name="layout">[Optional] The storage order used to write the elements to <paramref name="dest"/>. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <remarks><para><paramref name="outSize"/> can be <c>null</c> on entry in which case it will be ignored.</para>
            <para>If <paramref name="layout"/> is <c>null</c> or <see cref="F:ILNumerics.StorageOrders.Other"/> the storage layout of the array 
            returned will be automatically determined based on the current storage layout: copying from continous storages will keep 
            the source storage layout (column- or row major layout). Copying from non-continous storages creates a storage according to 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/>. </para>
            <para>If <paramref name="layout"/> is one of <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/> the 
            elements are stored into <paramref name="dest"/> with this layout.</para>
            <para>Make sure that the memory region addressed by <paramref name="dest"/> is large enough, even if the current storage layout 
            corresponds to non-continously stored elements! Note further, that 
            any potentially existing holes in the element storage layout will not be cleared!</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.ILNumerics#Core#StorageLayer#IStorage#GetCellContentDirect(System.Int64*,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the cell _content_ of the cell addressed by <paramref name="indices"/> without cloning. 
            </summary>
            <param name="indices">Vector of the full index path, from root cell to the target element.</param>
            <param name="lenIndices">Number of indices stored in <paramref name="indices"/>.</param>
            <param name="start">First index in <paramref name="indices"/> to be considered.</param>
            <returns>The storage object found at <paramref name="indices"/>, potentially wrapped into a scalar <see cref="T:ILNumerics.Core.StorageLayer.Storage`1"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.ILNumerics#Core#StorageLayer#IStorage#SetCellContentDirect(ILNumerics.Core.StorageLayer.IStorage,System.Int64*,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Sets a new value at the element / cell element as defined by <paramref name="indices"/>.
            </summary>
            <param name="value">The new value to be set directly. No clone will be made!</param>
            <param name="indices">Vector of the full index path, from root cell to the target element.</param>
            <param name="lenIndices">Number of indices stored in <paramref name="indices"/>.</param>
            <param name="start">First index in <paramref name="indices"/> to be considered.</param>
            <param name="allowExpand">Flag indicating which expansion mode to apply (numpy=false, ILNumericsV4=true).</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.GetCell4Indexer_DeepIndex(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.UInt32)">
            <summary>
            Wraps deep indexing value into a cell for returning in Indexers.
            </summary>
            <param name="d0"></param>
            <param name="d1"></param>
            <param name="d2"></param>
            <param name="d3"></param>
            <param name="d4"></param>
            <param name="d5"></param>
            <param name="d6"></param>
            <param name="len"></param>
            <returns>Cell wrapping the addressed value.</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.GetValue_DeepIndex(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.UInt32)">
            <summary>
            Returns deep indexed value for returning in GetValue extensions.
            </summary>
            <param name="d0"></param>
            <param name="d1"></param>
            <param name="d2"></param>
            <param name="d3"></param>
            <param name="d4"></param>
            <param name="d5"></param>
            <param name="d6"></param>
            <param name="len"></param>
            <returns>Cell wrapping the addressed value.</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.CellStorage.IsTypeOf``1(ILNumerics.InArray{System.Int64})">
            <summary>
            Tests if a cell element is of the given array kind/element type. 
            </summary>
            <typeparam name="T">The array element type to probe the cell element for.</typeparam>
            <param name="indices">Dimensional indices defining the position of the cell element to be probed.</param>
            <returns>true if the element found at the given position is an array of the given element type <typeparamref name="T"/>, false otherwise.</returns>
            <remarks><para>The method is helpful in order to investigate the contents of a cell array. If you are not sure about the 
            types of elements in the cell, this function can be used to make sure that elements actually are of the expected type before attempting to retrieve them.</para>
            <para>In most situations, elements of a cell are stored arrays of a distinct element type. That element type is given to <see cref="M:ILNumerics.Core.StorageLayer.CellStorage.IsTypeOf``1(ILNumerics.InArray{System.Int64})"/> as 
            typeparameter <typeparamref name="T"/>. That means, in order to find out, if the first cell element stores an array of int 
            <c><![CDATA[cell.IsTypeOf<int>(0)]]></c> is used.</para>
            <para>In order to test for cell element type <typeparamref name="T"/> can be <see cref="T:ILNumerics.Cell"/> or <see cref="T:ILNumerics.BaseArray"/>: <c><![CDATA[cell.IsTypeOf<Cell>(0)]]></c>.</para>
            <para>In order to test for logical element type <typeparamref name="T"/> must be <see cref="T:System.Boolean"/>: <c><![CDATA[cell.IsTypeOf<bool>(0)]]></c>.</para>
            </remarks>
            <example>
            <para>In the following example a Cell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code>Cell cell = ILMath.cell(new Size(3, 2) 
                                 , "first element"
                                 , 2.0
                                 , ILMath.cell(Math.PI, 100f)
                                 , ILMath.create&lt;short>(1, 2, 3, 4, 5, 6)
                                 , new double[] {-1.4, -1.5, -1.6});
            </code>
            The cell is now: 
            <code>Cell [3,2]
                     &lt;String>      first element  &lt;Int16> [2,3,4,5,6] 
                     &lt;Double>          2          Cell [1,3]           
                     Cell [2,1]                                    (null)	
            </code>
            We test the element type of each element in the cell: 
            <code>
            Console.Out.WriteLine("cell[0,0] is of type 'string': {0}", cell.IsTypeOf&lt;string>(0));
            Console.Out.WriteLine("cell[0,0] is of type 'double': {0}", cell.IsTypeOf&lt;double>(0));
                                                 
            Console.Out.WriteLine("cell[1,0] is of type 'double': {0}", cell.IsTypeOf&lt;double>(1));
            Console.Out.WriteLine("cell[2,0] is of type 'Cell': {0}", cell.IsTypeOf&lt;Cell>(2));
                                                                                    
            Console.Out.WriteLine("cell[0,1] is of type 'short': {0}", cell.IsTypeOf&lt;short>(0, 1));
            Console.Out.WriteLine("cell[1,1] is of type 'Cell': {0}", cell.IsTypeOf&lt;Cell>(1, 1));
            Console.Out.WriteLine("cell[2,1] is of type 'double': {0}", cell.IsTypeOf&lt;double>(2, 1));
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'Cell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'Cell': True
            cell[2,1] is element type 'double': False  (element is null)
            </code></example>
        </member>
        <member name="T:ILNumerics.Core.StorageLayer.IStorage">
            <summary>
            Interface, supporting array hosting containers, like Cell. This type is used internally. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.IStorage.GetBaseArrayClone">
            <summary>
            Gets a BaseArray instance (RetArray) corresponding to a clone of this storage.
            </summary>
            <returns>A clone </returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.IStorage.GetBaseArray">
            <summary>
            Gets a BaseArray instance (RetArray) corresponding to this storage.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.IStorage.GetCellContentDirect(System.Int64*,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the cell _content_ of the cell addressed by <paramref name="indices"/> without cloning. 
            </summary>
            <param name="indices">Vector of the full index path, from root cell to the target element.</param>
            <param name="lenIndices">Number of indices stored in <paramref name="indices"/>.</param>
            <param name="start">First index in <paramref name="indices"/> to be considered.</param>
            <returns>The storage object found at <paramref name="indices"/>, potentially wrapped into a scalar <see cref="T:ILNumerics.Core.StorageLayer.Storage`1"/>.</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.IStorage.SetCellContentDirect(ILNumerics.Core.StorageLayer.IStorage,System.Int64*,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Sets the value of the element / cell element (==array) addressed by <paramref name="indices"/> without cloning. 
            </summary>
            <param name="value">New value for the element. Will be stored without creating a clone.</param>
            <param name="indices">Vector of the full index path, from root cell to the target element.</param>
            <param name="lenIndices">Number of indices stored in <paramref name="indices"/>.</param>
            <param name="start">First index in <paramref name="indices"/> to be considered.</param>
            <param name="allowExpand">Flag indicating which expansion mode to apply (numpy=false, ILNumericsV4=true).</param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.IStorage.Clone">
            <summary>
            Clone the storage. The clone will utilize distinct memory for all reference types and shared memory for value typed arrays.
            </summary>
            <returns>Shallow, lazy clone of this <see cref="T:ILNumerics.Core.StorageLayer.IStorage"/>.</returns>
        </member>
        <member name="T:ILNumerics.Core.StorageLayer.LogicalStorage">
            <summary>
            Internal storage container for logical arrays. This class is used internally. 
            </summary>
        </member>
        <member name="P:ILNumerics.Core.StorageLayer.LogicalStorage.NumberTrues">
            <summary>
            Gets or sets the number of boolean elements stored by this logical array, evaluating to 'true'.
            </summary>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.LogicalStorage.Create">
            <summary>
            Creates an <i>uninitialized</i> storage which remains in an INCONSISTENT STATE until configured! 
            </summary>
            <returns>INCONSTISTENT storage - needs configuration of host memory handle and size!</returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.LogicalStorage.New(System.UInt64,System.Boolean)">
            <summary>
            Create a new memory handle of <paramref name="elementLength"/> elements of the natural element type of this storage. 
            </summary>
            <param name="elementLength">Number of elements for the new handle.</param>
            <param name="clear">[optional] clear the new memory. Default: false.</param>
            <returns>The new handle according to the storage's internal element type.</returns>
            <remarks><para>This method is overriden for derived, specialized storages, where the actual element type used in memory differs from <typeparamref name="T"/>.</para></remarks>
            <seealso cref="M:ILNumerics.Core.StorageLayer.LogicalStorage.New(System.UInt64,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.StorageLayer.CellStorage.New(System.UInt64,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.LogicalStorage.Clone">
            <summary>
            Creates a shallow copy of this storage. Does not copy the handles but only the storage object.
            </summary>
            <returns>Clone of this storage, sharing the memory handles with this storage.</returns>
            <remarks><para>The storage returned has an array reference count of 0. Reference
            counts for the (shared) handles are increased accordingly.</para></remarks>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.LogicalStorage.SetValueSeq(System.Boolean,System.Int64)">
            <summary>
            This function covers all SetValue() invocations and updates <see cref="P:ILNumerics.Core.StorageLayer.LogicalStorage.NumberTrues"/> on changes. 
            </summary>
            <param name="value"></param>
            <param name="byteIdx"></param>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.LogicalStorage.ILNumerics#Core#StorageLayer#IStorage#SetCellContentDirect(ILNumerics.Core.StorageLayer.IStorage,System.Int64*,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Sets a new value at the element as defined by <paramref name="indices"/>.
            </summary>
            <param name="value">The new value to be set directly. No clone will be made!</param>
            <param name="indices">Vector of the full index path, from root cell to the target element.</param>
            <param name="lenIndices">Number of indices stored in <paramref name="indices"/>.</param>
            <param name="start">First index in <paramref name="indices"/> to be considered.</param>
            <param name="allowExpand">Flag indicating which expansion mode to apply (numpy=false, ILNumericsV4=true).</param>
        </member>
        <member name="T:ILNumerics.Core.StorageLayer.Storage`1">
            <summary>
            Main rectilinear storage object. This storage type is used by Array{T} &amp; Co internally.
            </summary>
            <typeparam name="T">Element type.</typeparam>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.Storage`1.#ctor">
            <summary>
            Creates new storage of undefined size.
            </summary>
        </member>
        <member name="T:ILNumerics.Core.StorageLayer.ScalarIndexIterator">
            <summary>
            This class internally supports the ILNumerics iterator infrastructure. 
            </summary>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.StringIndicesIterator.nextSubrange(System.Boolean)">
            <summary>
            increments to the next subrange and sets pointer to the last char of it
            </summary>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.StringIndicesIterator.GetLength">
            <summary>
            Gets the iteration length of the current subrange (if exists). 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.StringIndicesIterator.GetMaximum">
            <summary>
            Gets the end index of the current subrange (if exists). 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.StringIndicesIterator.GetMinimum">
            <summary>
            Gets the biginning index of the current subrange (if exists). 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.StorageLayer.StringIndicesIterator.GetStepSize">
            <summary>
            Gets the stepsize of the single range defined or null if multiple ranges exist.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimits.Double.Strided32(System.Byte*,System.Double*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimits.Single.Strided32(System.Byte*,System.Single*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimits.Complex.Strided32(System.Byte*,ILNumerics.complex*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimits.FComplex.Strided32(System.Byte*,ILNumerics.fcomplex*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimits.Sbyte.Strided32(System.Byte*,System.SByte*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimits.UInt64.Strided32(System.Byte*,System.UInt64*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimits.Int64.Strided32(System.Byte*,System.Int64*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimits.UInt32.Strided32(System.Byte*,System.UInt32*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimits.UInt16.Strided32(System.Byte*,System.UInt16*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimits.Int16.Strided32(System.Byte*,System.Int16*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimits.Byte.Strided32(System.Byte*,System.Byte*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimits.Int32.Strided32(System.Byte*,System.Int32*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimitsNoInf.Double.Strided32(System.Byte*,System.Double*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimitsNoInf.Single.Strided32(System.Byte*,System.Single*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimitsNoInf.Complex.Strided32(System.Byte*,ILNumerics.complex*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="M:ILNumerics.Core.InnerLoops.GetLimitsNoInf.FComplex.Strided32(System.Byte*,ILNumerics.fcomplex*,System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            Inner ACCUMALL loop for strided, general (non-huge) array.
            </summary>
            <param name="pSrc">pointer to first element to consider here.</param>
            <param name="pOut">Pointer to single element to store result.</param>
            <param name="start">First sequential element.</param>
            <param name="len">Number of sequential elements to process.</param>
            <param name="ordered_bytestrided_bsd">(Re-)ordered BSD of the source array. Strides indicate <i>byte spacings</i>.</param>
        </member>
        <member name="T:ILNumerics.InArray`1">
            <summary>
            Main input array type. Use this in a function signature indicating an immutable, dense input 
            array as function argument.
            </summary>
            <remarks>This </remarks>
            <typeparam name="T">Element type.</typeparam>
        </member>
        <member name="M:ILNumerics.InArray`1.op_Implicit(`0)~ILNumerics.InArray{`0}">
            <summary>
            Wraps single value into scalar array.
            </summary>
            <param name="a">System type.</param>
            <returns>New scalar array of type <see cref="T:ILNumerics.InArray`1"/>. 
            The only element has a value of <paramref name="a"/>.
            </returns>
            <remarks><para>The array returned will have a single element. However, the 
            number of dimensions depends on the current setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.
            By default (value: 2) the array returned will be of size [1 x 1].</para></remarks>
        </member>
        <member name="M:ILNumerics.InArray`1.op_Implicit(System.Array)~ILNumerics.InArray{`0}">
            <summary>
            Implicitly convert n-dimensional System.Array to ILNumerics array.
            </summary>
            <param name="A">System.Array of arbitrary size</param>
            <returns>If A is null: empty array. Otherwise a new ILNumerics array of the same size as A.</returns>
            <exception cref="T:System.InvalidCastException">If the type of the elements in A cannot get converted 
            to <typeparamref name="T"/>.</exception>
            <exception cref="T:System.InvalidOperationException">If the type of the elements in A is not supported.</exception>
            <remarks><para>Elements of A will be copied to elements of the output array (shallow copy). The following element types are 
            supported for <paramref name="A"/> and <typeparamref name="T"/>: double, float, int, uint, long, ulong, short, ushort, sbyte, byte.</para> 
            <para>Alternatively, <paramref name="A"/> may consists out of scalar Arrays (or RetArray, InArray, OutArray) of one of the above element types.</para>
            <para>The resulting Array will reflect all dimensions of A. Due to the fact that .NET System.Arrays are stored in row major order and 
            ILNumerics stores array in column major (for compatibility with e.g. Matlab and Fortran) the resulting Array will have its dimensions reverted!
            For matrices this corresponds to a matrix transpose.</para>
            <para>System.Convert is used for the conversion of elements in A to destination elements. This includes widening and narrowing conversions. When, for example, 
            array elements of type double are provided and <typeparamref name="T"/> is Int32 the conversion will <b>round</b> the 
            source elements. See the examples below.</para></remarks>
            <example>
            <code lang="VB" title="VB Code Example">
            '' Elements of System.Value types:
            Dim A1 As Array(Of Double) = { 1, 2, 3 }  ' provide int elements
            Dim A2 As Array(Of Double) = { 1.0, 2.9, 3.4, 5.12 }  ' provide double elements
            Dim A As Double = 5
            Dim B As Double = 6
            Dim C As Double = 7
            
            Dim A3 As Array(Of Double) = { A, B, C } ' provide double variables
            
            Dim A4 As Array(Of Double) = { ILMath.cos(A), ILMath.tan(B) * C, C, 3 } ' provide mixed element types, including scalar Array  
            </code>
            <code lang="C#" title="C# Code Example">
            <![CDATA[
            Array<double> A1 = new[] { 1, ILMath.cos(2.0), 3, 4 };
            double B = -1, C = 10;
            Array<double> A2 = new[] { ILMath.cos(A1[1]), ILMath.tan(B) * C, C, 3 };
            // create from multidimensional System.Array 
            Array<int> A3 = new[,] { { 11, 12, 13 }, { 21, 22, 23 } };
            // narrowing conversion: from double to int (note the rounding rules!)
            Array<int> A4 = new[,] { { 11.9, 12.1, 13 }, { 21.5, 22.5, 23 } };
            //<Int32> [3,2]
            //    12         22 
            //    12         22 
            //    13         23 ]]>
            </code></example>
        </member>
        <member name="M:ILNumerics.InArray`1.op_Implicit(ILNumerics.RetArray{`0})~ILNumerics.InArray{`0}">
            <summary>
            Convert temporary to input parameter array.
            </summary>
            <param name="array">Temp array</param>
            <returns>Input parameter array, will survive the current scope only</returns>
        </member>
        <member name="M:ILNumerics.InArray`1.op_Implicit(ILNumerics.Array{`0})~ILNumerics.InArray{`0}">
            <summary>
            Convert persistent to input parameter array
            </summary>
            <param name="array">Persistent array</param>
            <returns>Input parameter array, will survive the current scope only</returns>
        </member>
        <member name="M:ILNumerics.InArray`1.op_Implicit(ILNumerics.OutArray{`0})~ILNumerics.InArray{`0}">
            <summary>
            Convert output parameter array to input parameter array
            </summary>
            <param name="array">Output parameter array</param>
            <returns>Input parameter array, will survive the current scope only</returns>
        </member>
        <member name="T:ILNumerics.InCell">
            <summary>
            Input cell array type to be used as input parameter in user defined functions. 
            </summary>
        </member>
        <member name="M:ILNumerics.InCell.op_Implicit(ILNumerics.RetCell)~ILNumerics.InCell">
            <summary>
            Convert temporary to input parameter array.
            </summary>
            <param name="array">Temp array</param>
            <returns>Input parameter array, will survive the current scope only</returns>
        </member>
        <member name="M:ILNumerics.InCell.op_Implicit(ILNumerics.Cell)~ILNumerics.InCell">
            <summary>
            Convert persistent to input parameter array
            </summary>
            <param name="array">Persistent array</param>
            <returns>Input parameter array, will survive the current scope only</returns>
        </member>
        <member name="M:ILNumerics.InCell.op_Implicit(ILNumerics.OutCell)~ILNumerics.InCell">
            <summary>
            Convert output paramter array to input parameter array
            </summary>
            <param name="array">Output parameter array</param>
            <returns>Input parameter array, will survive the current scope only</returns>
        </member>
        <member name="T:ILNumerics.InLogical">
            <summary>
            Input logical array type to be used as input parameter in user defined functions. 
            </summary>
        </member>
        <member name="M:ILNumerics.InLogical.op_Implicit(System.Boolean)~ILNumerics.InLogical">
            <summary>
            Converts single value into scalar array.
            </summary>
            <param name="a">System type.</param>
            <returns>New scalar array of type <see cref="T:ILNumerics.InLogical"/>. 
            The only element has a value of <paramref name="a"/>.
            </returns>
            <remarks><para>The array returned will have a single element. However, the 
            number of dimensions depends on the current setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.
            By default (value: 2) the array returned will be of size [1 x 1].</para></remarks>
        </member>
        <member name="M:ILNumerics.InLogical.op_Implicit(System.Array)~ILNumerics.InLogical">
             <summary>
             Convert n-dimensional <see cref="T:System.Array"/> to ILNumerics array.
             </summary>
             <param name="A">System.Array of arbitrary size</param>
             <returns>If A is null: empty array. Otherwise a new ILNumerics array of the same size as A.</returns>
             <exception cref="T:System.InvalidCastException">If the type of the elements in A cannot get converted to <see cref="T:System.Boolean"/>.</exception>
             <exception cref="T:System.NotSupportedException">if As elements are reference types and A is a multidimensional array.</exception>
             <remarks><para>Elements of A will be converted to elements of the output array, where non-null elements (reference types) and 
             '!= 0' values (value types) in <paramref name="A"/> create 'true' values in the result. The following element types are 
             supported for <paramref name="A"/>: all <see cref="T:System.IConvertible"/> types (double, float, int, uint, long, ulong, short, ushort, sbyte, byte etc.),
             and reference types.</para> 
             <para>The resulting Array will reflect all dimensions of A. Due to the fact that .NET System.Arrays are stored in row major order 
             the storage layout of the resulting Array will be <see cref="F:ILNumerics.StorageOrders.RowMajor"/> also. Elements of an one-dimensional <paramref name="A"/> 
             will be ordered along the first dimension of the result. Hence, one-dimensional input arrays will produce column vectors.</para>
             <para><see cref="T:System.Convert"/> is used for the conversion of elements in A to bool elements.</para>
             <para>The current value of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is considered. Its default value of 2 will cause a 
             matrix to be produced, even though the input <paramref name="A"/> may be a one-dimensional array.</para>
             </remarks>
             <example>
             <code lang="C#" title="C# Code Example">
             <![CDATA[
                    // convert from bool[] array 
                    Logical A = new bool[] { true, true, false, true };
                    //A.T
                    //Logical[1, 4] True True ...
                    //[0]:     
                    
                    // convert from double[] array
                    Logical B = new double[] { 1, 2, 0, 4 };
                    //B.T
                    //Logical[1, 4] True True ...
                    //[0]:     
                    
                    // convert from 2dim float[,] array
                    Logical C = new float[,] {
                     { 9, 9, float.MaxValue, float.NegativeInfinity },
                     { 0, 0, float.NaN, 0 },
                    };
                    //C
                    //Logical[2, 4] True False ...
                    //[0]:     
                    //[1]:     
            
                    // convert from 2dim reference type array
                    Logical D = new[,] {
                     { new object(), new Double() + 1, new List<object>() },
                     { null, null, null }
                    };
                    //D
                    //Logical[2, 3] True False ...
                    //[0]:    
                    //[1]:     
             ]]>
             </code></example>
        </member>
        <member name="M:ILNumerics.InLogical.op_Implicit(ILNumerics.RetLogical)~ILNumerics.InLogical">
            <summary>
            Converts return type array to input array.
            </summary>
            <param name="array">Temporary array</param>
            <returns>Array converted to an input type.</returns>
            <remarks><para>No new memory is used for the returned array. The returned array 
            is commonly used as input parameter and immutable.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.InLogical.op_Implicit(ILNumerics.OutLogical)~ILNumerics.InLogical">
            <summary>
            Converts output array to an input array (immutable).
            </summary>
            <param name="array">Source array.</param>
            <returns>Input array.</returns>
        </member>
        <member name="M:ILNumerics.InLogical.op_Implicit(ILNumerics.Logical)~ILNumerics.InLogical">
            <summary>
            Converts local array to an input array (immutable).
            </summary>
            <param name="array">Source array.</param>
            <returns>Input array.</returns>
        </member>
        <member name="M:ILNumerics.InLogical.op_Implicit(ILNumerics.InLogical)~System.Boolean">
            <summary>
            Convert scalar <see cref="T:ILNumerics.Logical"/> array to <see cref="T:System.Boolean"/>.
            </summary>
            <param name="A">Source logical array. Must be scalar (i.e.: must have exactly one element).</param>
            <remarks><para>Empty arrays or null is also accepted for <paramref name="A"/>. <see langword="false"/> is returned in this case.</para></remarks>
        </member>
        <member name="P:ILNumerics.InLogical.NumberTrues">
            <summary>
            Gives the number of elements evaluating to true.
            </summary>
        </member>
        <member name="T:ILNumerics.Logical">
            <summary>
            Local logical array type to be used when defining local array variables in custom algorithms. 
            </summary>
            <remarks>Logical arrays can be converted to numeric arrays by help the function 'touint8()'.</remarks>
        </member>
        <member name="M:ILNumerics.Logical.op_Implicit(System.Boolean)~ILNumerics.Logical">
            <summary>
            Wraps single value into scalar array.
            </summary>
            <param name="a">System type.</param>
            <returns>New scalar array of type <see cref="T:ILNumerics.InArray`1"/>. 
            The only element has a value of <paramref name="a"/>.
            </returns>
            <remarks><para>The array returned will have a single element. However, the 
            number of dimensions depends on the current setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.
            By default (value: 2) the array returned will be of size [1 x 1].</para></remarks>
        </member>
        <member name="M:ILNumerics.Logical.op_Implicit(System.Array)~ILNumerics.Logical">
             <summary>
             Convert n-dimensional <see cref="T:System.Array"/> to ILNumerics array.
             </summary>
             <param name="A">System.Array of arbitrary size</param>
             <returns>If A is null: empty array. Otherwise a new ILNumerics array of the same size as A.</returns>
             <exception cref="T:System.InvalidCastException">If the type of the elements in A cannot get converted to <see cref="T:System.Boolean"/>.</exception>
             <exception cref="T:System.NotSupportedException">if As elements are reference types and A is a multidimensional array.</exception>
             <remarks><para>Elements of A will be converted to elements of the output array, where non-null elements (reference types) and 
             '!= 0' values (value types) in <paramref name="A"/> create 'true' values in the result. The following element types are 
             supported for <paramref name="A"/>: all <see cref="T:System.IConvertible"/> types (double, float, int, uint, long, ulong, short, ushort, sbyte, byte etc.),
             and reference types.</para> 
             <para>The resulting Array will reflect all dimensions of A. Due to the fact that .NET System.Arrays are stored in row major order 
             the storage layout of the resulting Array will be <see cref="F:ILNumerics.StorageOrders.RowMajor"/> also. Elements of an one-dimensional <paramref name="A"/> 
             will be ordered along the first dimension of the result. Hence, one-dimensional input arrays will produce column vectors.</para>
             <para><see cref="T:System.Convert"/> is used for the conversion of elements in A to bool elements.</para>
             <para>The current value of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is considered. Its default value of 2 will cause a 
             matrix to be produced, even though the input <paramref name="A"/> may be a one-dimensional array.</para>
             </remarks>
             <example>
             <code lang="C#" title="C# Code Example">
             <![CDATA[
                    // convert from bool[] array 
                    Logical A = new bool[] { true, true, false, true };
                    //A.T
                    //Logical[1, 4] True True ...
                    //[0]:     
                    
                    // convert from double[] array
                    Logical B = new double[] { 1, 2, 0, 4 };
                    //B.T
                    //Logical[1, 4] True True ...
                    //[0]:     
                    
                    // convert from 2dim float[,] array
                    Logical C = new float[,] {
                     { 9, 9, float.MaxValue, float.NegativeInfinity },
                     { 0, 0, float.NaN, 0 },
                    };
                    //C
                    //Logical[2, 4] True False ...
                    //[0]:     
                    //[1]:     
            
                    // convert from 2dim reference type array
                    Logical D = new[,] {
                     { new object(), new Double() + 1, new List<object>() },
                     { null, null, null }
                    };
                    //D
                    //Logical[2, 3] True False ...
                    //[0]:    
                    //[1]:    ]]>
             </code></example>
        </member>
        <member name="M:ILNumerics.Logical.op_Implicit(ILNumerics.RetLogical)~ILNumerics.Logical">
            <summary>
            "Persistence cast" turns a volatile array into a persistent variable for use with a local variable.
            </summary>
            <param name="A">Temporary array</param>
            <returns>Steady Array, will survive multiple usages</returns>
            <remarks><para>This casting conversion changes temporary 
            arrays from temporary (volatile) state to local Arrays with persistent state. The inner storage is kept and used for 
            the new array. The new array can then be used (referenced, accessed, modified) during the rest of the function scope. 
            In contrast to that, <see cref="T:ILNumerics.RetArray`1"/> is disposed off immediately after first use.</para> 
            <para>New memoy is only used for the new array storage and data elements are only copied from <paramref name="A"/> when 
            the returned array is altered later on. </para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Logical.op_Implicit(ILNumerics.InLogical)~ILNumerics.Logical">
            <summary>
            Convert input array (immutable) to local array (mutable).
            </summary>
            <param name="A">Input array</param>
            <returns>Local mutable array with lifespan corresponding to the current scope.</returns>
            <remarks>The new array is detached from the source array <paramref name="A"/>. The new array can 
            get used multiple times in the function scope and get altered without modifying the source array <paramref name="A"/>.</remarks>
        </member>
        <member name="M:ILNumerics.Logical.op_Implicit(ILNumerics.OutLogical)~ILNumerics.Logical">
            <summary>
            Convert output array to a new local array (mutable).
            </summary>
            <param name="A">Array of OutArray type.</param>
            <returns>Local mutable array, detached from the source array <paramref name="A"/>, with lifespan corresponding to the current scope.</returns>
            <remarks>The new array is detached from this array. The new array can 
            get used multiple times in the function scope and get altered without altering the source array.</remarks>
        </member>
        <member name="M:ILNumerics.Logical.op_Implicit(ILNumerics.Logical)~System.Boolean">
            <summary>
            Convert scalar <see cref="T:ILNumerics.Logical"/> array to <see cref="T:System.Boolean"/>.
            </summary>
            <param name="A">Source logical array. Must be scalar (i.e.: must have exactly one element).</param>
            <remarks><para>Empty arrays or null is also accepted for <paramref name="A"/>. <see langword="false"/> is returned in this case.</para></remarks>
        </member>
        <member name="M:ILNumerics.Logical.Dispose">
            <summary>
            Release this array after use. Cleans up on <see cref="T:ILNumerics.Array`1"/>, <see cref="T:ILNumerics.Cell"/> and <see cref="T:ILNumerics.Logical"/> arrays which are not inside a <see cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/> block.
            </summary>
            <remarks><para>This method is used in rare situations where no artificial scope exists around the current function body. Examples of 
            such situations are short <see cref="T:ILNumerics.Array`1"/>snippets in anonymous- or lambda functions, entry methods, or intended manual memory management.</para>
            <para>During 'normal' use the user places an artificial scope (<see cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/>) around the function body. All <see cref="T:ILNumerics.Array`1"/>, 
            <see cref="T:ILNumerics.Cell"/>, and <see cref="T:ILNumerics.Logical"/> arrays created within the scope block are automatically tracked and released once the scope block is left.</para>
            <para>Calling this method manually on local arrays as <see cref="T:ILNumerics.Array`1"/> &amp; Co. can be profitible in situations where no such scope block exists. 
            Otherwise, the memory would be reclaimed at a later point in time by the GC. <see cref="M:ILNumerics.Logical.Dispose"/> releases the array immediately. If no other 
            arrays are sharing the same memory, it will be released to the memory pool for immediate reusage.</para>
            <para>Note: failing to call <see cref="M:ILNumerics.Logical.Dispose"/> in such situations does not create a memory leak! But the array is only reclaimed 
            by the garbage collector and its memory is only freed by the finalization thread during the next GC collection. While this 
            is considered regular use, disposing the array manually is recommended in situations where high performance execution or 
            low memory consumption is required. </para>
            <para>Note further, that <see cref="M:ILNumerics.Logical.Dispose"/> is <b>not</b> required in 'common' array uses. I.e. when dealing with <see cref="T:ILNumerics.Array`1"/> 
            inside existing <see cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/> scope blocks or when a return value is utilized in some way (incl. assignment to <see cref="T:ILNumerics.Array`1"/>, 
            calling member functions on the return value or giving the return value to other functions as input parameter).</para></remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteRetArray`6.Dispose"/>
        </member>
        <member name="P:ILNumerics.Logical.NumberTrues">
            <summary>
            Gives the number of elements evaluating to true.
            </summary>
        </member>
        <member name="T:ILNumerics.OutArray`1">
            <summary>
            Input /output array type to be used as parameter in user defined functions with multiple return values. 
            </summary>
        </member>
        <member name="M:ILNumerics.OutArray`1.op_Implicit(ILNumerics.Array{`0})~ILNumerics.OutArray{`0}">
            <summary>
            Creates an output parameter type array from regular array
            </summary>
            <param name="A">Original array</param>
            <returns>Output parameter type array, references the original array</returns>
        </member>
        <member name="P:ILNumerics.OutArray`1.a">
            <summary>
            Assign another array to this array variable. This is an optional, yet more efficient alternative to using '=' for assigning to the array directly.
            </summary>
            <param name="value">The new array.</param>
            <remarks>By using this method, the storage of this array is immediately released to the memory pool and replaced by the new arrays content. In difference to that, 
            by using the common '=' assignment operator, the existing arrays storage is released only at the time, the current 
            <see cref="M:ILNumerics.Scope.Enter"/> block  is left. Therefeore, prefer this method if a 
            smaller memory pool is crucial.</remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.Mutable`6.Assign(ILNumerics.Core.Arrays.ConcreteArray{`0,`1,`2,`3,`4,`5})"/>
        </member>
        <member name="T:ILNumerics.OutCell">
            <summary>
            Input /output cell array type to be used as parameter in user defined functions with multiple return values. 
            </summary>
        </member>
        <member name="M:ILNumerics.OutCell.op_Implicit(ILNumerics.Cell)~ILNumerics.OutCell">
            <summary>
            Convert local array to output type array. 
            </summary>
            <param name="A">Local cell to be used as output argument.</param>
            <remarks><para>Just like for <see cref="T:ILNumerics.Array`1"/> to <see cref="T:ILNumerics.RetArray`1"/>
            conversions the <see cref="T:ILNumerics.OutCell"/> shares the same storage with <paramref name="A"/>
            and serves as a proxy to <paramref name="A"/>. Changing the output type cell in a function
            changes the associated local cell <paramref name="A"/> in the calling scope.</para></remarks>
        </member>
        <member name="T:ILNumerics.OutLogical">
            <summary>
            Input /output logical array type to be used as parameter in user defined functions with multiple return values. 
            </summary>
        </member>
        <member name="M:ILNumerics.OutLogical.op_Implicit(ILNumerics.Logical)~ILNumerics.OutLogical">
            <summary>
            Converts local array to an in/output array (proxy).
            </summary>
            <param name="A">Source array.</param>
            <returns>Input array.</returns>
        </member>
        <member name="M:ILNumerics.OutLogical.op_Implicit(ILNumerics.OutLogical)~System.Boolean">
            <summary>
            Convert scalar <see cref="T:ILNumerics.Logical"/> array to <see cref="T:System.Boolean"/>.
            </summary>
            <param name="A">Source logical array. Must be scalar (i.e.: must have exactly one element).</param>
            <remarks><para>Empty arrays or null is also accepted for <paramref name="A"/>. <see langword="false"/> is returned in this case.</para></remarks>
            <exception cref="T:System.InvalidCastException"> if <paramref name="A"/> has more than one element.</exception>
        </member>
        <member name="P:ILNumerics.OutLogical.NumberTrues">
            <summary>
            Gives the number of elements evaluating to true.
            </summary>
        </member>
        <member name="T:ILNumerics.RetArray`1">
            <summary>
            Array type to be used as return type for user defined functions. 
            </summary>
        </member>
        <member name="M:ILNumerics.RetArray`1.op_Implicit(ILNumerics.InArray{`0})~ILNumerics.RetArray{`0}">
            <summary>
            Convert input array to return type array. 
            </summary>
            <param name="A"></param>
        </member>
        <member name="M:ILNumerics.RetArray`1.op_Implicit(ILNumerics.Array{`0})~ILNumerics.RetArray{`0}">
            <summary>
            Convert local array type to return type array.
            </summary>
            <param name="A"></param>
        </member>
        <member name="M:ILNumerics.RetArray`1.op_Implicit(ILNumerics.OutArray{`0})~ILNumerics.RetArray{`0}">
            <summary>
            Convert output array type to return type array.
            </summary>
            <param name="A"></param>
        </member>
        <member name="M:ILNumerics.RetArray`1.op_Implicit(`0)~ILNumerics.RetArray{`0}">
            <summary>
            Implicitly convert scalar to array of size 1x1 (scalar).
            </summary>
            <param name="val">System type of size scalar</param>
            <returns>New Array of type Array <![CDATA[<typeof(val)>]]> of size 1x1 
            holding the only element with value of val.
            </returns>
        </member>
        <member name="M:ILNumerics.RetArray`1.op_Implicit(System.Array)~ILNumerics.RetArray{`0}">
            <summary>
            Implicitly convert n-dimensional System.Array to ILNumerics array.
            </summary>
            <param name="A">System.Array of arbitrary size</param>
            <returns>If A is null: empty array. Otherwise a new ILNumerics array of the same size as A.</returns>
            <exception cref="T:System.InvalidCastException">If the type of the elements in A cannot get converted to <typeparamref name="T1"/>.</exception>
            <exception cref="T:System.InvalidOperationException">If the type of the elements in A is not supported.</exception>
            <remarks><para>Elements of A will be copied to elements of the output array (shallow copy). The following element types are 
            supported for <paramref name="A"/> and <typeparamref name="T1"/>: double, float, int, uint, long, ulong, short, ushort, sbyte, byte.</para> 
            <para>Alternatively, <paramref name="A"/> may consists out of scalar Arrays (or RetArray, InArray, OutArray) of one of the above element types.</para>
            <para>The resulting Array will reflect all dimensions of A. Due to the fact that .NET System.Arrays are stored in row major order and 
            ILNumerics stores array in column major (for compatibility with e.g. Matlab and Fortran) the resulting Array will have its dimensions reverted!
            For matrices this corresponds to a matrix transpose.</para>
            <para>System.Convert is used for the conversion of elements in A to destination elements. This includes widening and narrowing conversions. When, for example, 
            array elements of type double are provided and <typeparamref name="T1"/> is Int32 the conversion will <b>round</b> the 
            source elements. See the examples below.</para></remarks>
            <example>
            <code lang="VB" title="VB Code Example">
            '' Elements of System.Value types:
            Dim A1 As Array(Of Double) = { 1, 2, 3 }  ' provide int elements
            Dim A2 As Array(Of Double) = { 1.0, 2.9, 3.4, 5.12 }  ' provide double elements
            Dim A As Double = 5
            Dim B As Double = 6
            Dim C As Double = 7
            
            Dim A3 As Array(Of Double) = { A, B, C } ' provide double variables
            
            Dim A4 As Array(Of Double) = { ILMath.cos(A), ILMath.tan(B) * C, C, 3 } ' provide mixed element types, including scalar Array  
            </code>
            <code lang="C#" title="C# Code Example">
            <![CDATA[
            Array<double> A1 = new[] { 1, ILMath.cos(2.0), 3, 4 };
            double B = -1, C = 10;
            Array<double> A2 = new[] { ILMath.cos(A1[1]), ILMath.tan(B) * C, C, 3 };
            // create from multidimensional System.Array 
            Array<int> A3 = new[,] { { 11, 12, 13 }, { 21, 22, 23 } };
            // narrowing conversion: from double to int (note the rounding rules!)
            Array<int> A4 = new[,] { { 11.9, 12.1, 13 }, { 21.5, 22.5, 23 } };
            //<Int32> [3,2]
            //    12         22 
            //    12         22 
            //    13         23 ]]>
            </code></example>
        </member>
        <member name="T:ILNumerics.RetCell">
            <summary>
            Cell array type to be used as return type for user defined functions. 
            </summary>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(System.Int32)~ILNumerics.RetCell">
            <summary>
            Convert primitive integer to a scalar temporary cell
            </summary>
            <param name="value">Primitive scalar int value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(System.UInt32)~ILNumerics.RetCell">
            <summary>
            Convert primitive integer to a scalar temporary cell
            </summary>
            <param name="value">Primitive scalar int value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(System.Int64)~ILNumerics.RetCell">
            <summary>
            Convert primitive integer to a scalar temporary cell
            </summary>
            <param name="value">Primitive scalar int value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(System.UInt64)~ILNumerics.RetCell">
            <summary>
            Convert primitive integer to a scalar temporary cell
            </summary>
            <param name="value">Primitive scalar int value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(System.Double)~ILNumerics.RetCell">
            <summary>
            Convert primitive double to a scalar temporary cell
            </summary>
            <param name="value">Primitive scalar double value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(System.Single)~ILNumerics.RetCell">
            <summary>
            Convert primitive float to a scalar temporary cell
            </summary>
            <param name="value">Primitive scalar float value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(System.Byte)~ILNumerics.RetCell">
            <summary>
            Convert primitive byte to a scalar temporary cell
            </summary>
            <param name="value">Primitive byte int value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(System.String)~ILNumerics.RetCell">
            <summary>
            Convert primitive byte to a scalar temporary cell
            </summary>
            <param name="value">Primitive byte int value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(System.UInt32[])~ILNumerics.RetCell">
            <summary>
            Encapsulates UInt32[] system array into a scalar temporary cell array. 
            </summary>
            <param name="value">System array with values for the only cell of the new scalar cell array.</param>
            <returns>New scalar temporary cell.</returns>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(System.Int64[])~ILNumerics.RetCell">
            <summary>
            Encapsulates Int64[] system array into a scalar temporary cell array. 
            </summary>
            <param name="value">System array with values for the only cell of the new scalar cell array.</param>
            <returns>New scalar temporary cell.</returns>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(System.Int32[])~ILNumerics.RetCell">
            <summary>
            Encapsulates Int32[] system array into a scalar temporary cell array. 
            </summary>
            <param name="value">System array with values for the only cell of the new scalar cell array.</param>
            <returns>New scalar temporary cell.</returns>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(System.Double[])~ILNumerics.RetCell">
            <summary>
            Encapsulates Int32[] system array into a scalar temporary cell array. 
            </summary>
            <param name="value">System array with values for the only cell of the new scalar cell array.</param>
            <returns>New scalar temporary cell.</returns>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(System.String[])~ILNumerics.RetCell">
            <summary>
            Encapsulate array of strings into a scalar temporary cell
            </summary>
            <param name="value">String array - no copy will be made!</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(ILNumerics.InCell)~ILNumerics.RetCell">
            <summary>
            Convert input array to return type array. 
            </summary>
            <param name="A">Input type cell to be converted.</param>
            <remarks><para>Just like for <see cref="T:ILNumerics.Array`1"/> to <see cref="T:ILNumerics.RetArray`1"/>
            conversions the returned <see cref="T:ILNumerics.RetCell"/> shares the same storage with <paramref name="A"/>. 
            Being an immutable type one cannot change the cell returned nor the source <paramref name="A"/>.</para></remarks>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(ILNumerics.Cell)~ILNumerics.RetCell">
            <summary>
            Convert local cell array to return type cell. 
            </summary>
            <param name="A">Local cell to be converted.</param>
            <remarks><para>Just like for <see cref="T:ILNumerics.InArray`1"/> to <see cref="T:ILNumerics.RetArray`1"/>
            conversions the returned <see cref="T:ILNumerics.RetCell"/> shares the same storage with <paramref name="A"/>. 
            Being an immutable type one cannot change the cell returned nor the source <paramref name="A"/> 
            via a <see cref="T:ILNumerics.RetCell"/>.</para></remarks>
        </member>
        <member name="M:ILNumerics.RetCell.op_Implicit(ILNumerics.OutCell)~ILNumerics.RetCell">
            <summary>
            Convert output cell array to return type cell. 
            </summary>
            <param name="A">Local cell to be converted.</param>
            <remarks><para>Just like for <see cref="T:ILNumerics.InArray`1"/> to <see cref="T:ILNumerics.RetArray`1"/>
            conversions the returned <see cref="T:ILNumerics.RetCell"/> shares the same storage with <paramref name="A"/>. 
            Being an immutable type one cannot change the cell returned nor the source <paramref name="A"/> 
            via a <see cref="T:ILNumerics.RetCell"/>.</para></remarks>
        </member>
        <member name="T:ILNumerics.RetLogical">
            <summary>
            Logical array type to be used as return type for user defined functions. 
            </summary>
        </member>
        <member name="M:ILNumerics.RetLogical.op_Implicit(System.Boolean)~ILNumerics.RetLogical">
            <summary>
            Converts single value into scalar array.
            </summary>
            <param name="a">Boolean system type.</param>
            <returns>New scalar array of type <see cref="T:ILNumerics.RetLogical"/>. 
            The only element has a value of <paramref name="a"/>.
            </returns>
            <remarks><para>The array returned will have a single element. However, the 
            number of dimensions depends on the current setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.
            By default (value: 2) the array returned will be of size [1 x 1].</para></remarks>
        </member>
        <member name="M:ILNumerics.RetLogical.op_Implicit(System.Array)~ILNumerics.RetLogical">
             <summary>
             Convert n-dimensional <see cref="T:System.Array"/> to ILNumerics array.
             </summary>
             <param name="A">System.Array of arbitrary size</param>
             <returns>If A is null: empty array. Otherwise a new ILNumerics array of the same size as A.</returns>
             <exception cref="T:System.InvalidCastException">If the type of the elements in A cannot get converted to <see cref="T:System.Boolean"/>.</exception>
             <exception cref="T:System.NotSupportedException">if As elements are reference types and A is a multidimensional array.</exception>
             <remarks><para>Elements of A will be converted to elements of the output array, where non-null elements (reference types) and 
             '!= 0' values (value types) in <paramref name="A"/> create 'true' values in the result. The following element types are 
             supported for <paramref name="A"/>: all <see cref="T:System.IConvertible"/> types (double, float, int, uint, long, ulong, short, ushort, sbyte, byte etc.),
             and reference types.</para> 
             <para>The resulting Array will reflect all dimensions of A. Due to the fact that .NET System.Arrays are stored in row major order 
             the storage layout of the resulting Array will be <see cref="F:ILNumerics.StorageOrders.RowMajor"/> also. Elements of an one-dimensional <paramref name="A"/> 
             will be ordered along the first dimension of the result. Hence, one-dimensional input arrays will produce column vectors.</para>
             <para><see cref="T:System.Convert"/> is used for the conversion of elements in A to bool elements.</para>
             <para>The current value of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is considered. Its default value of 2 will cause a 
             matrix to be produced, even though the input <paramref name="A"/> may be a one-dimensional array.</para>
             </remarks>
             <example>
             <code lang="C#" title="C# Code Example">
             <![CDATA[
                    // convert from bool[] array 
                    Logical A = new bool[] { true, true, false, true };
                    //A.T
                    //Logical[1, 4] True True ...
                    //[0]:     
                    
                    // convert from double[] array
                    Logical B = new double[] { 1, 2, 0, 4 };
                    //B.T
                    //Logical[1, 4] True True ...
                    //[0]:     
                    
                    // convert from 2dim float[,] array
                    Logical C = new float[,] {
                     { 9, 9, float.MaxValue, float.NegativeInfinity },
                     { 0, 0, float.NaN, 0 },
                    };
                    //C
                    //Logical[2, 4] True False ...
                    //[0]:     
                    //[1]:     
            
                    // convert from 2dim reference type array
                    Logical D = new[,] {
                     { new object(), new Double() + 1, new List<object>() },
                     { null, null, null }
                    };
                    //D
                    //Logical[2, 3] True False ...
                    //[0]:    
                    //[1]:    
             ]]>
             </code></example>
        </member>
        <member name="M:ILNumerics.RetLogical.op_Implicit(ILNumerics.InLogical)~ILNumerics.RetLogical">
            <summary>
            Converts input type array to return type array (volatile, immutable).
            </summary>
            <param name="A">Source array.</param>
            <returns>Converted array.</returns>
        </member>
        <member name="M:ILNumerics.RetLogical.op_Implicit(ILNumerics.OutLogical)~ILNumerics.RetLogical">
            <summary>
            Converts output array to an return type array (volatile, immutable).
            </summary>
            <param name="A">Source array.</param>
            <returns>Input array.</returns>
        </member>
        <member name="M:ILNumerics.RetLogical.op_Implicit(ILNumerics.Logical)~ILNumerics.RetLogical">
            <summary>
            Converts local array to a return type array (volatile, immutable).
            </summary>
            <param name="A">Source array.</param>
            <returns>Return type array.</returns>
        </member>
        <member name="M:ILNumerics.RetLogical.op_Implicit(ILNumerics.RetLogical)~System.Boolean">
            <summary>
            Convert scalar <see cref="T:ILNumerics.Logical"/> array to <see cref="T:System.Boolean"/>.
            </summary>
            <param name="A">Source logical array. Must be scalar (i.e.: must have exactly one element).</param>
            <remarks><para>Empty arrays or null is also accepted for <paramref name="A"/>. <see langword="false"/> is returned in this case.</para></remarks>
            <exception cref="T:System.InvalidCastException"> if <paramref name="A"/> has more than one element.</exception>
        </member>
        <member name="P:ILNumerics.RetLogical.NumberTrues">
            <summary>
            Gives the number of elements evaluating to true.
            </summary>
        </member>
        <member name="T:ILNumerics.Globals">
            <summary>
            Static class defining useful constants, shortcuts, aliases and functions for working with ILNumerics arrays. 
            </summary>
        </member>
        <member name="M:ILNumerics.Globals.BorrowPointer``1(System.IntPtr,System.Int64)">
            <summary>
            Creates a 1D vector by using the pre-allocated memory referenced by <paramref name="pointer"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="pointer">Pointer to the memory region to be used as storage for the new 1d ILNumerics <see cref="T:ILNumerics.Array`1"/>. The memory region must be large enough to fit at least as many elements of type <typeparamref name="T"/> into, as is specified by <paramref name="nrElements"/>.</param>
            <param name="nrElements">The number of elements for the new vector.</param>
            <returns>Vector of given <paramref name="nrElements"/> length using the memory region according to <paramref name="pointer"/> as storage.</returns>
            <remarks>As the name suggests the pointer is 'borrowed'! The array returned may be used, without restriction, for creating 
            subarrays, as argument in function invocations, as right side in assignments and so on. However, once all arrays referencing the internal storage 
            based on <paramref name="pointer"/> are released and the memory is no longer needed, it will not be deallocated or otherwise freed! Nor will the memory 
            be hold on by means of any ILNumerics memory pool! Instead, the memory ownership remains with you - the caller of this method. 
            <para>In order to determine, whether or not all references to the memory has been released, </para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Globals.eps">
            <summary>
            Double precision epsilon - the smallest absolute difference from 1.0, representable with "double" precision. 
            </summary>
        </member>
        <member name="P:ILNumerics.Globals.epsf">
            <summary>
            Single precision epsilon - the smallest absolute difference from 1.0f, representable as single precision floating point value.
            </summary>
        </member>
        <member name="P:ILNumerics.Globals.MachineParameterDouble">
            <summary>
            Give extensive numerical machine parameter informations - double precision
            </summary>
        </member>
        <member name="P:ILNumerics.Globals.MachineParameterSingle">
            <summary>
            Give extensive numerical machine parameter informations - single precision
            </summary>
        </member>
        <member name="T:ILNumerics.Globals.precisionHelper`1">
            <summary>
            Prevent JIT "optimizations" - force single precision to be applied
            </summary>
            <typeparam name="T">mainly float here</typeparam>
        </member>
        <member name="M:ILNumerics.Globals.macharF(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Determine machine specific parameter
            </summary>
            <remarks>Source: Numerical Recipes in C, p.892</remarks>
        </member>
        <member name="M:ILNumerics.Globals.macharD(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Determine machine specific parameter (double precision)
            </summary>
            <remarks>Source: Numerical Recipes in C, p.892</remarks>
        </member>
        <member name="F:ILNumerics.Globals.ellipsis">
            <summary>
            Addresses all unspecified dimension as ':' / 'full'.
            </summary>
        </member>
        <member name="F:ILNumerics.Globals.newaxis">
            <summary>
            Insert a new dimension. For <see cref="P:ILNumerics.Settings.ArrayStyle"/>=<see cref="F:ILNumerics.ArrayStyles.numpy"/> only.
            </summary>
        </member>
        <member name="F:ILNumerics.Globals.end">
            <summary>
            Identifier refering to the index of the last element in a dimension. Used in indexing expressions. 
            </summary>
        </member>
        <member name="P:ILNumerics.Globals.full">
            <summary>
            Addresses the full dimension, from 0 ... end, step size 1.
            </summary>
        </member>
        <member name="M:ILNumerics.Globals.r(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Range for indexing / subarray operations. ILNumericsV4 / Matlab / Octave / Julia style. 
            </summary>
            <param name="start">Inclusive start index.</param>
            <param name="step">Step size. Spacing between adjacent, selected elements.</param>
            <param name="end">Last element (inclusive).</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
        </member>
        <member name="M:ILNumerics.Globals.r(System.UInt32,System.UInt32)">
            <summary>
            Range for indexing / subarray operations. ILNumericsV4 / Matlab / Octave / Julia style. 
            </summary>
            <param name="start">Inclusive start index.</param>
            <param name="end">Last element (inclusive).</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
        </member>
        <member name="M:ILNumerics.Globals.r(System.Int64,System.Int64,System.Int64)">
            <summary>
            Range for indexing / subarray operations. ILNumericsV4 / Matlab / Octave / Julia style. 
            </summary>
            <param name="start">Inclusive start index.</param>
            <param name="step">Step size. Spacing between adjacent, selected elements.</param>
            <param name="end">Last element (inclusive).</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
        </member>
        <member name="M:ILNumerics.Globals.r(System.Int64,System.Int64)">
            <summary>
            Range for indexing / subarray operations. ILNumericsV4 / Matlab / Octave / Julia style. 
            </summary>
            <param name="start">Inclusive start index.</param>
            <param name="end">Last element (inclusive).</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
        </member>
        <member name="M:ILNumerics.Globals.r(ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Range for indexing / subarray operations. ILNumericsV4 / Matlab / Octave / Julia style. Step size: 1.
            </summary>
            <param name="start">Inclusive start index: scalar, numeric array with the starting index of this range.</param>
            <param name="end">Scalar, numeric array with the last index of the selected range (inclusive).</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
        </member>
        <member name="M:ILNumerics.Globals.r(ILNumerics.BaseArray,System.UInt64,ILNumerics.BaseArray)">
            <summary>
            Range for indexing / subarray operations. ILNumericsV4 / Matlab / Octave / Julia style.
            </summary>
            <param name="start">Inclusive start index: scalar, numeric array with the starting index of this range.</param>
            <param name="step">Step size between adjacent, selected elements.</param>
            <param name="end">Scalar, numeric array with the last index of this range (inclusive).</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/> array or <paramref name="end"/> array is not scalar or not numeric or if the conversion to a long value failed.</exception>
        </member>
        <member name="M:ILNumerics.Globals.r(ILNumerics.BaseArray,System.UInt64,ILNumerics.Core.Misc.ILExpression)">
            <summary>
            Range for indexing / subarray operations. ILNumericsV4 / Matlab / Octave / Julia style.
            </summary>
            <param name="start">Inclusive start index: scalar, numeric array with the starting index of this range.</param>
            <param name="step">Positive step size between adjacent elements. Unit: elements.</param>
            <param name="end">Inclusive end index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/> or <paramref name="end"/> are not scalar or not numeric or if the conversion to a long value failed.</exception>
            <exception cref="T:System.ArgumentException"> if <paramref name="step"/> is larger than <see cref="F:System.Int64.MaxValue"/>.</exception>
        </member>
        <member name="M:ILNumerics.Globals.r(ILNumerics.Core.Misc.ILExpression,System.UInt64,ILNumerics.Core.Misc.ILExpression)">
            <summary>
            Range for indexing / subarray operations. ILNumericsV4 / Matlab / Octave / Julia style.
            </summary>
            <param name="start">Inclusive start index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <param name="step">Positive step size between adjacent elements. Unit: elements.</param>
            <param name="end">Inclusive end index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="step"/> is larger than <see cref="F:System.Int64.MaxValue"/>.</exception>
        </member>
        <member name="M:ILNumerics.Globals.r(ILNumerics.Core.Misc.ILExpression,System.UInt64,ILNumerics.BaseArray)">
            <summary>
            Range for indexing / subarray operations. ILNumericsV4 / Matlab / Octave / Julia style.
            </summary>
            <param name="start">Inclusive start index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <param name="step">Positive step size between adjacent, selected elements.</param>
            <param name="end">Scalar, numeric array with the last index of this range.</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/> or <paramref name="end"/> are not scalar or not numeric or if the conversion to a long value failed.</exception>
            <exception cref="T:System.ArgumentException"> if <paramref name="step"/> is larger than <see cref="F:System.Int64.MaxValue"/>.</exception>
        </member>
        <member name="M:ILNumerics.Globals.r(ILNumerics.Core.Misc.ILExpression,ILNumerics.BaseArray)">
            <summary>
            Range for indexing / subarray operations. ILNumericsV4 / Matlab / Octave / Julia style. Step size: 1.
            </summary>
            <param name="start">Inclusive start index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <param name="end">Scalar, numeric array with the last index of this range.</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <seealso cref="M:ILNumerics.Globals.r(ILNumerics.Core.Misc.ILExpression,System.UInt64,ILNumerics.BaseArray)"/>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/> or <paramref name="end"/> are not scalar or not numeric or if the conversion to a long value failed.</exception>
        </member>
        <member name="M:ILNumerics.Globals.r(ILNumerics.Core.Misc.ILExpression,ILNumerics.Core.Misc.ILExpression)">
            <summary>
            Range for indexing / subarray operations. ILNumericsV4 / Matlab / Octave / Julia style. Step size: 1.
            </summary>
            <param name="start">Inclusive start index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <param name="end">Inclusive end index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/> or <paramref name="end"/> are not scalar or not numeric or if the conversion to a long value failed.</exception>
        </member>
        <member name="M:ILNumerics.Globals.r(ILNumerics.BaseArray,ILNumerics.Core.Misc.ILExpression)">
            <summary>
            Range for indexing / subarray operations. ILNumericsV4 / Matlab / Octave / Julia style. Step size: 1.
            </summary>
            <param name="start">Inclusive start index: scalar, numeric array with the starting index of this range.</param>
            <param name="end">Inclusive end index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/> array or <paramref name="end"/> expression is not scalar or not numeric or if the conversion to a long value failed.</exception>
        </member>
        <member name="M:ILNumerics.Globals.slice(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Slice for indexing / subarray operations. numpy style. 
            </summary>
            <param name="start">Start index of the selection.</param>
            <param name="step">Step size. Spacing between adjacent, selected elements.</param>
            <param name="end">Stopping index of the selection (exclusive).</param>
            <returns>Stepped slice to be used in indexing expressions.</returns>
        </member>
        <member name="M:ILNumerics.Globals.slice(System.UInt32,System.UInt32)">
            <summary>
            Slice for indexing / subarray operations. Step size: 1. numpy style. 
            </summary>
            <param name="start">First element index in this dimension.</param>
            <param name="end">Last element (exclusive).</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
        </member>
        <member name="M:ILNumerics.Globals.slice(System.Int64,System.Int64,System.Int64)">
            <summary>
            Slice for indexing / subarray operations. numpy style. 
            </summary>
            <param name="start">Start index of the selection.</param>
            <param name="step">Step size. Spacing between adjacent elements addressed.</param>
            <param name="end">Last element (exclusive).</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="step"/> is negative.</exception>
        </member>
        <member name="M:ILNumerics.Globals.slice(System.Int64,System.Int64)">
            <summary>
            Slice for indexing / subarray operations. numpy style. 
            </summary>
            <param name="start">Start index of the selection.</param>
            <param name="end">Last element (exclusive).</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
        </member>
        <member name="M:ILNumerics.Globals.slice(ILNumerics.BaseArray,ILNumerics.BaseArray)">
            <summary>
            Slice for indexing / subarray operations. numpy style. 
            </summary>
            <param name="start">Scalar, numeric array with the starting index of the selection.</param>
            <param name="end">Scalar, numeric array with the stopping index of this range.</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/> or <paramref name="end"/> are not scalar or not numeric or if the conversion to a long value failed.</exception>
        </member>
        <member name="M:ILNumerics.Globals.slice(ILNumerics.BaseArray,ILNumerics.BaseArray,System.UInt64)">
            <summary>
            Slice for indexing / subarray operations. numpy style. 
            </summary>
            <param name="start">Scalar, numeric array with the starting index of the selection.</param>
            <param name="step">Positive step size between adjacent elements. Unit: elements.</param>
            <param name="end">Scalar, numeric array with the stopping index of this range.</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/> or <paramref name="end"/> are not scalar or not numeric or if the conversion to a long value failed.</exception>
            <exception cref="T:System.ArgumentException"> if <paramref name="step"/> is larger than <see cref="F:System.Int64.MaxValue"/>.</exception>
        </member>
        <member name="M:ILNumerics.Globals.slice(ILNumerics.BaseArray,ILNumerics.Core.Misc.ILExpression,System.UInt64)">
            <summary>
            Slice for indexing / subarray operations. numpy style. 
            </summary>
            <param name="start">Scalar, numeric array with the starting index of the selection.</param>
            <param name="step">Positive step size between adjacent elements. Unit: elements.</param>
            <param name="end">(Exclusive) selection stopping index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/> or <paramref name="end"/> are not scalar or not numeric or if the conversion to a long value failed.</exception>
            <exception cref="T:System.ArgumentException"> if <paramref name="step"/> is larger than <see cref="F:System.Int64.MaxValue"/>.</exception>
        </member>
        <member name="M:ILNumerics.Globals.slice(ILNumerics.Core.Misc.ILExpression,ILNumerics.Core.Misc.ILExpression,System.UInt64)">
            <summary>
            Slice for indexing / subarray operations. numpy style. 
            </summary>
            <param name="start">Selection start index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <param name="step">Positive step size between adjacent elements. Unit: elements.</param>
            <param name="end">(Exclusive) selection stopping index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="step"/> is larger than <see cref="F:System.Int64.MaxValue"/>.</exception>
        </member>
        <member name="M:ILNumerics.Globals.slice(ILNumerics.Core.Misc.ILExpression,ILNumerics.BaseArray,System.UInt64)">
            <summary>
            Slice for indexing / subarray operations. numpy style. 
            </summary>
            <param name="start">Selection start index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <param name="step">Positive step size between adjacent elements. Unit: elements.</param>
            <param name="end">Scalar, numeric array with the stopping index of this range.</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/> or <paramref name="end"/> are not scalar or not numeric or if the conversion to a long value failed.</exception>
            <exception cref="T:System.ArgumentException"> if <paramref name="step"/> is larger than <see cref="F:System.Int64.MaxValue"/>.</exception>
        </member>
        <member name="M:ILNumerics.Globals.slice(ILNumerics.Core.Misc.ILExpression,ILNumerics.BaseArray)">
            <summary>
            Slice for indexing / subarray operations. numpy style. 
            </summary>
            <param name="start">Selection start index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <param name="end">Scalar, numeric array with the stopping index of this range.</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <seealso cref="M:ILNumerics.Globals.slice(ILNumerics.Core.Misc.ILExpression,ILNumerics.BaseArray,System.UInt64)"/>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/> or <paramref name="end"/> are not scalar or not numeric or if the conversion to a long value failed.</exception>
        </member>
        <member name="M:ILNumerics.Globals.slice(ILNumerics.Core.Misc.ILExpression,ILNumerics.Core.Misc.ILExpression)">
            <summary>
            Slice for indexing / subarray operations. numpy style. 
            </summary>
            <param name="start">Selection start index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <param name="end">(Exclusive) selection stopping index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <seealso cref="M:ILNumerics.Globals.r(ILNumerics.BaseArray,ILNumerics.Core.Misc.ILExpression)"/>
        </member>
        <member name="M:ILNumerics.Globals.slice(ILNumerics.BaseArray,ILNumerics.Core.Misc.ILExpression)">
            <summary>
            Slice for indexing / subarray operations. numpy style. 
            </summary>
            <param name="start">Scalar, numeric array with the starting index of the selection.</param>
            <param name="end">(Exclusiv) selection stopping index: simple computational expression (+,-,/,*) involving the <see cref="F:ILNumerics.Globals.end"/> specifier which evaluates to the last index in this dimension.</param>
            <returns>Stepped range to be used in indexing expressions.</returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="start"/> or <paramref name="end"/> are not scalar or not numeric or if the conversion to a long value failed.</exception>
            <seealso cref="M:ILNumerics.Globals.r(ILNumerics.BaseArray,ILNumerics.Core.Misc.ILExpression)"/>
        </member>
        <member name="P:ILNumerics.Globals.pi">
            <summary>
            The constant  as specified in <see cref="F:System.Math.PI"/>.
            </summary>
        </member>
        <member name="P:ILNumerics.Globals.pif">
            <summary>
            The constant  as specified in <see cref="F:System.Math.PI"/>, single precision.
            </summary>
        </member>
        <member name="P:ILNumerics.Globals.BuildDate">
            <summary>
            The date of the build of this module
            </summary>
        </member>
        <member name="P:ILNumerics.Globals.MachineKey">
            <summary>
            The machine key of the computer / current user account [readonly]. 
            </summary>
        </member>
        <member name="M:ILNumerics.F2NET.Array.Intrinsics.AsArray``1(System.IntPtr,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Wraps a 1D array (vector) around allocated memory.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="ptr">The pointer to allocated memory to be wrapped. Must be large enough to hold the specified number of elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="order">[Optional] Storage order. Default: (null) means <see cref = "F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
            <returns>Array as specified.</returns>
        </member>
        <member name="M:ILNumerics.F2NET.Array.Intrinsics.AsArray``1(System.IntPtr,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Create 1D array of arbitrary size without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="ptr">The pointer to allocated memory to be wrapped. Must be large enough to hold the specified number of elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array as specified.</returns>
        </member>
        <member name="M:ILNumerics.F2NET.Array.Intrinsics.AsArray``1(System.IntPtr,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Create 1D array of arbitrary size without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="ptr">The pointer to allocated memory to be wrapped. Must be large enough to hold the specified number of elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array as specified.</returns>
        </member>
        <member name="M:ILNumerics.F2NET.Array.Intrinsics.AsArray``1(System.IntPtr,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Create 1D array of arbitrary size without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="ptr">The pointer to allocated memory to be wrapped. Must be large enough to hold the specified number of elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array as specified.</returns>
        </member>
        <member name="M:ILNumerics.F2NET.Array.Intrinsics.AsArray``1(System.IntPtr,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Create 1D array of arbitrary size without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="ptr">The pointer to allocated memory to be wrapped. Must be large enough to hold the specified number of elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array as specified.</returns>
        </member>
        <member name="M:ILNumerics.F2NET.Array.Intrinsics.AsArray``1(System.IntPtr,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Create 1D array of arbitrary size without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="ptr">The pointer to allocated memory to be wrapped. Must be large enough to hold the specified number of elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array as specified.</returns>
        </member>
        <member name="M:ILNumerics.F2NET.Array.Intrinsics.AsArray``1(System.IntPtr,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            Create 1D array of arbitrary size without clearing the elements.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="ptr">The pointer to allocated memory to be wrapped. Must be large enough to hold the specified number of elements.</param>
            <param name="dim0">Length of dimension #0.</param>
            <param name="dim1">Length of dimension #1.</param>
            <param name="dim2">Length of dimension #2.</param>
            <param name="dim3">Length of dimension #3.</param>
            <param name="dim4">Length of dimension #4.</param>
            <param name="dim5">Length of dimension #5.</param>
            <param name="dim6">Length of dimension #6.</param>
            <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <returns>Array as specified.</returns> 
        </member>
        <member name="M:ILNumerics.DeviceHintAttribute.#ctor(System.Nullable{ILNumerics.DeviceTypes},System.Nullable{System.UInt32})">
            <summary>
            Create a hint for the selection of a suitable execution device. 
            </summary>
            <param name="kind">The category of the device. This allows to specify a <see cref="F:ILNumerics.DeviceTypes.GPU"/>, the <see cref="F:ILNumerics.DeviceTypes.CPU"/> OpenCL device or to restrict the execution onto the <see cref="F:ILNumerics.DeviceTypes.Host"/>.</param>
            <param name="deviceID">[Optional] If set and the value corresponds to an existing device at runtime this device is selected.</param>
            <returns>A hint structure with a device selection hint.</returns>
            <remarks><para>If both, valid values for <paramref name="deviceID"/> and for <paramref name="kind"/> are provided, <paramref name="deviceID"/> takes precedance.</para>
            <para>If neither <paramref name="kind"/> nor <paramref name="deviceID"/> have a valid values at runtime the <see cref="F:ILNumerics.DeviceTypes.Host"/> device is selected.</para>
            </remarks>
        </member>
        <member name="F:ILNumerics.BuildConfig.Debug">
            <summary>
            Clear text, Debugging! 
            </summary>
        </member>
        <member name="T:ILNumerics.LogVerbosityLevels">
            <summary>
            Available levels of logging information during run time. 
            </summary>
        </member>
        <member name="F:ILNumerics.LogVerbosityLevels.Minimal">
            <summary>
            Minimal information.
            </summary>
        </member>
        <member name="F:ILNumerics.LogVerbosityLevels.Regular">
            <summary>
            Regular information (default).
            </summary>
        </member>
        <member name="F:ILNumerics.LogVerbosityLevels.Detailed">
            <summary>
            More information. 
            </summary>
        </member>
        <member name="F:ILNumerics.LogVerbosityLevels.Diagnostic">
            <summary>
            All available information.
            </summary>
        </member>
        <member name="T:ILNumerics.DeviceTypes">
            <summary>
            All device types supported by OpenCL. These enum values match the official constants values according to the OpenCL spec 2.1. 
            </summary>
        </member>
        <member name="F:ILNumerics.DeviceTypes.CPU">
            <summary>
            An OpenCL device that is the host processor. The host processor runs the OpenCL implementations and is a single or multi-core CPU. This value is part of the OpenCL specification.
            </summary>
        </member>
        <member name="F:ILNumerics.DeviceTypes.GPU">
            <summary>\r\n HERE
            An OpenCL device that is a GPU. By this we mean that the device can also be used to accelerate a 3D API such as OpenGL or DirectX. This value is part of the OpenCL specification.
            </summary>
        </member>
        <member name="F:ILNumerics.DeviceTypes.Accelerator">
            <summary>
            Dedicated OpenCL accelerators (for example the IBM CELL Blade). These devices communicate with the host processor using a peripheral interconnect such as PCIe. This value is part of the OpenCL specification.
            </summary>
        </member>
        <member name="F:ILNumerics.DeviceTypes.Custom">
            <summary>
            Dedicated accelerators that do not support programs written in OpenCL C. This value is part of the OpenCL specification.
            </summary>
        </member>
        <member name="F:ILNumerics.DeviceTypes.Default">
            <summary>
            The default OpenCL device in the system. The default device cannot be a <see cref="F:ILNumerics.DeviceTypes.Custom"/> device.  This value is part of the OpenCL specification.
            </summary>
        </member>
        <member name="F:ILNumerics.DeviceTypes.ALL">
            <summary>
            All OpenCL devices available in the system except <see cref="F:ILNumerics.DeviceTypes.Custom"/> devices. This value is part of the OpenCL specification.
            </summary>
        </member>
        <member name="F:ILNumerics.DeviceTypes.Host">
            <summary>
            A (non - OpenCL) device representing the host platform. ILNumerics uses the CLR (.NET Framework) as host in version 7. This value was added to the official OpenCL enum values by ILNumerics.
            </summary>
        </member>
        <member name="T:ILNumerics.PutModes">
            <summary>
            [numpy API] Options for handling out-of-range indices in 'ILNumerics.numpy.put(A, B, C, mode)'.
            </summary>
        </member>
        <member name="F:ILNumerics.PutModes.Raise">
            <summary>
            [Default] throw an <see cref="T:System.IndexOutOfRangeException"/>.
            </summary>
        </member>
        <member name="F:ILNumerics.PutModes.Wrap">
            <summary>
            Indices are computed by applying the modulus of the allowed index range to the requested index. 
            </summary>
        </member>
        <member name="F:ILNumerics.PutModes.Clip">
            <summary>
            Too large indices are clipped into the allowed range.
            </summary>
        </member>
        <member name="T:ILNumerics.ArrayStyles">
            <summary>
            Options of array semantics. This enum is used to switch the behavior of <see cref="T:ILNumerics.Array`1"/> and Co. between ILNumerics version 4 (Matlab, Julia, etc.) and numpy mode.
            </summary>
        </member>
        <member name="F:ILNumerics.ArrayStyles.ILNumericsV4">
            <summary>
            Default indexing and array styles. Handles subarray / indexing expressions in the tradional way, similar to Matlab(R), octave and ILNumerics prior version 5. All arrays will be matrices.
            </summary>
            <remarks><para>When this setting is selected, unspecified trailing dimensions are (virtually) substituted with '0', addressing the first element in the dimension (Matlab(R) style subarrays).</para>
            <para>All arrays are created as matrices having at least 2 dimensions.</para>
            <para>Addressing the last dimension with ":" or <see cref="P:ILNumerics.Globals.full"/> in subarray expressions leads to a reshaping of the array and merging unspecified subsequent dimensions into the last dimension (linear index expansion).</para>
            <para>Arrays can be expanded, parts of arrays can be removed in subarray/ indexing expressions.</para>
            <para>The default storage order for new arrays is <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</para>
            </remarks>
        </member>
        <member name="F:ILNumerics.ArrayStyles.numpy">
            <summary>
            Array handling and subarray / indexing expressions are handled similar to numpy.
            </summary>
            <remarks><para>When this setting is selected, unspecified trailing dimensions are (virtually) substituted with ':', addressing all 
            of the trailing dimension ('ellipsis', numpy indexing).</para>
            <para>Arrays can have less than 2 dimensions. 1-dim vectors and 0-dim scalars are supported.</para>
            <para>Indexing parameters contribute to the dimensionality of the result. For scalars as index parameters this leads to a reduction of dimensions of the result.</para>
            <para>All indices provided must be in the range of valid indices for each dimension. No linear index expansion is supported!</para>
            <para>Arrays cannot be expanded, no parts of arrays can be removed in subarray/ indexing expressions.</para>
            <para>The default storage order for new arrays is <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</para>
            </remarks>
        </member>
        <member name="T:ILNumerics.Visibility">
            <summary>
            Attribute flag values for <see cref="T:ILNumerics.VisibilityAttribute"/>. 
            </summary>
        </member>
        <member name="F:ILNumerics.Visibility.Internal">
            <summary>
            Functions marked with this flag are not publicly available.
            </summary>
        </member>
        <member name="F:ILNumerics.Visibility.Public">
            <summary>
            Functions marked with this flag are publicly available.
            </summary>
        </member>
        <member name="T:ILNumerics.MemoryTypes">
            <summary>
            Individual types of memory available to store arrays and parts thereof. 
            </summary>
        </member>
        <member name="F:ILNumerics.MemoryTypes.Process">
            <summary>
            The process' native virtual memory, managed by the OS.
            </summary>
        </member>
        <member name="F:ILNumerics.MemoryTypes.Shared">
            <summary>
            Shared, virtual (native) memory.
            </summary>
        </member>
        <member name="F:ILNumerics.MemoryTypes.Managed">
            <summary>
            Memory on the managed heap, subject to garbage collection.
            </summary>
        </member>
        <member name="F:ILNumerics.MemoryTypes.Device">
            <summary>
            Device memory storage under control of a device specific interface, such as OpenCL. Ex: OpenCL device memory as GPU memory.  
            </summary>
            <remarks>Note, that <see cref="F:ILNumerics.MemoryTypes.Process"/>, <see cref="F:ILNumerics.MemoryTypes.Shared"/> and <see cref="F:ILNumerics.MemoryTypes.Device"/> may refer to the 
            same memory addresses. The distinction is made by the interface used to access the memory.</remarks>
        </member>
        <member name="T:ILNumerics.StorageOrders">
            <summary>
            Supported known storage orders for array elements.
            </summary>
        </member>
        <member name="F:ILNumerics.StorageOrders.ColumnMajor">
            <summary>
            Column major, or first-to-last dimension ordering. (FORTRAN, Matlab, ILNumerics v4, Julia). 
            </summary>
        </member>
        <member name="F:ILNumerics.StorageOrders.RowMajor">
            <summary>
            Row major, or last-to-first dimension ordering. (C-style, Java, .NET multi-dim).
            </summary>
        </member>
        <member name="F:ILNumerics.StorageOrders.Other">
            <summary>
            Other storage formats and any non-contiguous storages. 
            </summary>
        </member>
        <member name="T:ILNumerics.GenEigenType">
            <summary>
            Specifies the type of eigen problem, as defined by Lapack. 
            </summary>
            <remarks>The enumeration lists possible problem definitions for generalized eigenproblems:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list></remarks>
        </member>
        <member name="F:ILNumerics.GenEigenType.Ax_eq_lambBx">
            <summary>
            A*V = r*B*V
            </summary>
        </member>
        <member name="F:ILNumerics.GenEigenType.ABx_eq_lambx">
            <summary>
            A*B*V = r*V
            </summary>
        </member>
        <member name="F:ILNumerics.GenEigenType.BAx_eq_lambx">
            <summary>
            B*A*V = r*V
            </summary>
        </member>
        <member name="T:ILNumerics.NumericType">
            <summary>
            Numeric, value type names used as data array elements by ILNumerics. 
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.None">
            <summary>
            Non-numeric element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Double">
            <summary>
            Double precision (64 bit), floating point element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Single">
            <summary>
            Single precision (32 bit), floating point element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Complex">
            <summary>
            Double precision complex element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.FComplex">
            <summary>
            Single precision complex element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Byte">
            <summary>
            Unsigned, 8 bit integer type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.SByte">
            <summary>
            Signed, 8 bit integer type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Int16">
            <summary>
            Signed, 16 bit integer type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.UInt16">
            <summary>
            unsigned, 16 bit integer type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Int32">
            <summary>
            Signed, 32 bit integer type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.UInt32">
            <summary>
            Unsigned, 32 bit integer type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Int64">
            <summary>
            Signed, 64 bit integer type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.UInt64">
            <summary>
            Unsigned, 64 bit integer type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Boolean">
            <summary>
            Boolean type. Not neccessarily numeric. Often implemented as 1 byte integer type.
            </summary>
        </member>
        <member name="T:ILNumerics.ArrayStreamSerializationFlags">
            <summary>
            Defines the way Arrays are serialized to stream.
            </summary>
            <seealso cref="M:ILNumerics.BaseArray.ToStream(System.IO.Stream,System.String,ILNumerics.ArrayStreamSerializationFlags)"/>
        </member>
        <member name="F:ILNumerics.ArrayStreamSerializationFlags.Serial">
            <summary>
            Print values 'vectorized': one value after each other. The true dimension configuration 
            of the array will be lost in the result. 
            </summary>
        </member>
        <member name="F:ILNumerics.ArrayStreamSerializationFlags.Formatted">
            <summary>
            Print values 'matrixwise'. The real dimensions configuration for the array are kept 
            in the result. The array will be printed by pages, consisting out of the 1st and 2nd 
            leading dimnsion. A dimension tag will prefix each page. The format can be used as 
            fancier output version for human reading as well as human readable serialization 
            format. Array's are capable of constructing from streams containing this type of 
            output. 
            </summary>
        </member>
        <member name="F:ILNumerics.ArrayStreamSerializationFlags.Matlab">
            <summary>
            Export whole array instance to matlab 5.0 format
            </summary>
        </member>
        <member name="T:ILNumerics.MatrixProperties">
            <summary>
            Possible properties for matrices 
            </summary>
            <remarks><para>These properties may be returned by function overloads receiving a MatrixProperties 
            parameter by reference. </para>
            <para><![CDATA[This enum is a bitflag'ed enum! You may query for any combination via the bitwise operators | and &. ]]></para></remarks>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Hermitian">
            <summary>
            Hermitian matrix 
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.PositivDefinite">
            <summary>
            Positive definite
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.UpperTriangular">
            <summary>
            Upper triangular matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.LowerTriangular">
            <summary>
            Lower triangular matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Square">
            <summary>
            Square matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Diagonal">
            <summary>
            Diagonal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Singular">
            <summary>
            The matrix is singular 
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Hessenberg">
            <summary>
            Hessenberg matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Householder">
            <summary>
            Householder matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Unitary">
            <summary>
            Unitary matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Orthogonal">
            <summary>
            Orthogonal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Orthonormal">
            <summary>
            Orthonormal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.RankDeficient">
            <summary>
            The matrix has deficient rank
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.None">
            <summary>
            The matrix has no special properties
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Unknown">
            <summary>
            No specific properties known (default)
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.EMInitializationMethod">
            <summary>
            Determine method of center initialization for EM algorithm.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.EMInitializationMethod.KMeans_random">
            <summary>
            Use the kmeans algorithm, choose random samples as centers for start.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.EMInitializationMethod.KMeans_firstK">
            <summary>
            Use the kmeans algorithm, choose first k samples as centers for start.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.EMInitializationMethod.User">
            <summary>
            Provide custom centers in the 'InitCenter' argument.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.DistanceMetrics">
            <summary>
            Distance metrics. 
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.KRRTypes">
            <summary>
            Type definitions for possible kernels in kernel ridge regression.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KRRTypes.linear">
            <summary>
            Linear kernel <c>k(x,y) = x'*y</c>
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KRRTypes.polynomial">
            <summary>
            Polynominal kernel <c>k(x,y) = (x'*y + c)^d</c>
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KRRTypes.gaussian">
            <summary>
            Gaussian (exponential) kernel <c>k(x,y) = exp(-norm(x-y)/sigma)</c>
            </summary>
        </member>
        <member name="T:ILNumerics.IO.HDF5.StringEncoding">
            <summary>
            Allowed settings for string encodings of strings stored as values in HDF5 objects and object names.
            </summary>
        </member>
        <member name="F:ILNumerics.IO.HDF5.StringEncoding.ASCII">
            <summary>
            Specify ASCII encoding. 
            </summary>
        </member>
        <member name="F:ILNumerics.IO.HDF5.StringEncoding.UTF8">
            <summary>
            Specify UTF8 encoding [default]. 
            </summary>
        </member>
        <member name="T:ILNumerics.IO.HDF5.StringPadding">
            <summary>
            Allowed settings for padding fixed length string datatypes. 
            </summary>
        </member>
        <member name="F:ILNumerics.IO.HDF5.StringPadding.NULLTERM">
            <summary>
            Null terminate (as for common C strings).
            </summary>
        </member>
        <member name="F:ILNumerics.IO.HDF5.StringPadding.ZEROPAD">
            <summary>
            Pad with zeros.
            </summary>
        </member>
        <member name="F:ILNumerics.IO.HDF5.StringPadding.SPACEPAD">
            <summary>
            Pad with spaces (as for common FORTRAN strings).
            </summary>
        </member>
        <member name="F:ILNumerics.IO.HDF5.StringPadding.ERROR">
            <summary>
            This value is returned when the padding value configured is not known. 
            </summary>
        </member>
        <member name="F:ILNumerics.IO.HDF5.StringPadding.ROUNDTRIP">
            <summary>
            For reading: keep the original setting as stored in the file.
            </summary>
        </member>
        <member name="T:ILNumerics.MachineParameterSingle">
            <summary>
            Extensive numerical machine parameter infos - single precision
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.ibeta">
            <summary>
            Radix
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.it">
            <summary>
            Number of base digits(bits) in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.irnd">
            <summary>
            Rounding and underflow information.  
            </summary>
            <remarks><list type="bullet"><listheader>Rounding properties</listheader>
            <item>2,5: IEEE rounding conform </item>
            <item>1,4: not IEEE conform rounding </item>
            <item>0,3: truncating - no rounding </item></list>
            <list type="bullet"><listheader>Under-/ Overflow. numbers below xmin will be interpreted as... </listheader>
            <item>0,1,2: zero</item>
            <item>3,4,5: xmin (IEEE conform)</item></list></remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.ngrd">
            <summary>
            Number of guard digits in the product of 2 mantissas
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.machep">
            <summary>
            Exponent of the smalles number ibeta^machep &gt; 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.negep">
            <summary>
            Exponent of smallest number ibeta^negep wich may be substracted from 1.0, giving a result not equal to 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.iexp">
            <summary>
            Number of exponent bits 
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.minexp">
            <summary>
            Smallest power of ibeta without leading zeros in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.maxexp">
            <summary>
            Smallest power of ibeta where overflow occours
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.eps">
            <summary>
            Distance between the smallest number &gt; 1.0, distinguishable from 1.0 and 1.0
            </summary>
            <remarks>This number is computed by ibeta <sup>machep</sup>.</remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.epsneg">
            <summary>
            Alternative eps. ibeta <sup>negep</sup>
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.xmin">
            <summary>
            Smallest floating point number
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.xmax">
            <summary>
            Largest floating point number
            </summary>
        </member>
        <member name="T:ILNumerics.MachineParameterDouble">
            <summary>
            Extensive numerical machine parameter infos - double precision
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.ibeta">
            <summary>
            Radix
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.it">
            <summary>
            Number of base digits(bits) in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.irnd">
            <summary>
            Rounding and underflow information.  
            </summary>
            <remarks><list type="bullet"><listheader>Rounding properties</listheader>
            <item>2,5: IEEE rounding conform </item>
            <item>1,4: not IEEE conform rounding </item>
            <item>0,3: truncating - no rounding </item></list>
            <list type="bullet"><listheader>Under-/ Overflow. numbers below xmin will be interpreted as... </listheader>
            <item>0,1,2: zero</item>
            <item>3,4,5: xmin (IEEE conform)</item></list></remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.ngrd">
            <summary>
            Number of guard digits in the product of 2 mantissas
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.machep">
            <summary>
            Exponent of the smalles number ibeta^machep &gt; 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.negep">
            <summary>
            Exponent of smallest number ibeta^negep wich may be substracted from 1.0, giving a result not equal to 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.iexp">
            <summary>
            Number of exponent bits 
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.minexp">
            <summary>
            Smallest power of ibeta without leading zeros in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.maxexp">
            <summary>
            Smallest power of ibeta where overflow occours
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.eps">
            <summary>
            Distance between the smallest number &gt; 1.0, distinguishable from 1.0 and 1.0
            </summary>
            <remarks>This number is computed by ibeta <sup>machep</sup>.</remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.epsneg">
            <summary>
            Alternative eps. ibeta <sup>negep</sup>
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.xmin">
            <summary>
            Smallest floating point number
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.xmax">
            <summary>
            Largest floating point number
            </summary>
        </member>
        <member name="T:ILNumerics.MatFile">
            <summary>
            Matlab(R) .mat file class for reading from / writing to *.mat files.
            </summary>
            <remarks>This class reads and writes Matlab .mat files version 6.
            All numeric array types are supported. The reading and writing of 
            Matlab cell arrays is not supported.</remarks>
            <example><code><![CDATA[
            // MatFile should be used in an 'using' block, 
            // cleaning up its resources automatically.
            using (MatFile mat = new MatFile()) {
                mat.AddArray(counter<sbyte>(-10, 2, 4, 8, 13), "myArray");
                mat.Write("file.mat");
            }
            
            // reading back using ILMath.loadArray<T>(...)
            Array<sbyte> A = loadArray<sbyte>("file.mat", "myArray");
            Assert.IsTrue(A.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            
            // reading back using MatFile
            using (var back = new MatFile("file.mat")) {
                Array<sbyte> B = back.GetArray<sbyte>("myArray");
            
                // ... or usign cell methods: 
                Array<sbyte> C = back.Arrays.GetArray<sbyte>(0);
            
                Assert.IsTrue(B.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
                Assert.IsTrue(C.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            }
            ]]></code></example>
            <seealso cref="T:ILNumerics.Cell"/>
        </member>
        <member name="T:ILNumerics.MatFile.MatFileType">
            <summary>
            Inner types for MATLAB data elements
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miUNKNOWN">
            <summary>
            unknown 
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miINT8">
            <summary>
            Int8
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miUINT8">
            <summary>
            UInt8
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miINT16">
            <summary>
            Int16
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miUINT16">
            <summary>
            UInt16
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miINT32">
            <summary>
            int32
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miUINT32">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miSINGLE">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miDOUBLE">
            <summary>
            double
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miINT64">
            <summary>
            Int64
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miUINT64">
            <summary>
            UInt64
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miMATRIX">
            <summary>
            matrix type (general)
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miCOMPRESSED">
            <summary>
            compressed
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miUTF8">
            <summary>
            utf8 encoded
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miUTF16">
            <summary>
            utf16 encoded
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileType.miUTF32">
            <summary>
            utf32 encoded
            </summary>
        </member>
        <member name="T:ILNumerics.MatFile.MatFileArrayClass">
            <summary>
            Types for matrix chunks
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxCELL_CLASS">
            <summary>
            cell
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxSTRUCT_CLASS">
            <summary>
            struct
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxOBJECT_CLASS">
            <summary>
            object
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxCHAR_CLASS">
            <summary>
            char
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxSPARSE_CLASS">
            <summary>
            sparse
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxDOUBLE_CLASS">
            <summary>
            double
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxSINGLE_CLASS">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxINT8_CLASS">
            <summary>
            Int8
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxUINT8_CLASS">
            <summary>
            UInt8
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxINT16_CLASS">
            <summary>
            Int16
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxUINT16_CLASS">
            <summary>
            UInt16
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxINT32_CLASS">
            <summary>
            Int32
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxUINT32_CLASS">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxINT64_CLASS">
            <summary>
            Int32
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.MatFileArrayClass.mxUINT64_CLASS">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="F:ILNumerics.MatFile.ReservedKeywords">
            <summary>
            List of keywords which Matlab disallows for variable names
            </summary>
        </member>
        <member name="M:ILNumerics.MatFile.sizeOf(ILNumerics.MatFile.MatFileType)">
            <summary>
            size of single elements stored in Matlab's *.mat files
            </summary>
            <param name="type">one of Matlab's inner element types</param>
            <returns>size in bytes </returns>
        </member>
        <member name="M:ILNumerics.MatFile.read_miMATRIX(System.IO.BinaryReader,System.String@)">
            <summary>
            read ONE array (arbitrary dimensions/type) from MAT file 
            </summary>
            <param name="br">binary reader initialized and pointing to the beginning of the subarray element.</param>
            <param name="name">[Output] the array name as read from the file.</param>
            <returns>BaseArray of size and type originally stored into the mat file.</returns>
        </member>
        <member name="M:ILNumerics.MatFile.readElementGeneric(System.IO.BinaryReader,ILNumerics.MatFile.MatFileType,ILNumerics.Core.MemoryLayer.MemoryHandle@,System.Int64,System.Int32)">
            <summary>
            read array of supported matlab data types 
            </summary>
            <param name="br">binary reader, opened and correctly positioned</param>
            <param name="storageType">actual storage type</param>
            <param name="realData">output: on return, the array read</param>
            <param name="len">input: number of _bytes_ to read.</param>
            <param name="paddBytes">padding border, the stream will be read to the next border of length 'paddBytes'.</param>
        </member>
        <member name="M:ILNumerics.MatFile.createNameSubelement(System.String,System.Int32@,System.Byte[]@)">
            <summary>
            create name subelement for Matfile storage - padded to 8 byte border
            </summary>
            <param name="arrName">name property</param>
            <param name="type">will be 'miINT8' on return</param>
            <param name="data">return data array </param>
        </member>
        <member name="M:ILNumerics.MatFile.getElementClass``6(ILNumerics.Core.StorageLayer.BaseStorage{``0,``1,``2,``3,``4,``5})">
            <summary>
            get mat file array class type corresponding to this arra element type
            </summary>
            <param name="storage">arra with generic system type or complex/fcomplex</param>
            <returns>mat file array class type code (int value)</returns>
        </member>
        <member name="M:ILNumerics.MatFile.getElementLength``6(ILNumerics.Core.StorageLayer.BaseStorage{``0,``1,``2,``3,``4,``5})">
            <summary>
            Gets the length of a single elements of <typeparamref name="T"/> in bytes.
            </summary>
            <param name="storage">The storage instance.</param>
            <returns>Element length in bytes.</returns>
        </member>
        <member name="M:ILNumerics.MatFile.typeToString(ILNumerics.MatFile.MatFileType)">
            <summary>
            Convert MatFileType enumeration member to string representation
            </summary>
            <param name="type">MatFileType enumeration member</param>
            <returns>String representing the Matlab's inner element type</returns>
            <remarks>This function is obsolete. You may directly use the enumeration's functionality instead.</remarks>
        </member>
        <member name="M:ILNumerics.MatFile.AddArray``1(ILNumerics.BaseArray{``0},System.String)">
            <summary>
            Adds a new array to the collection of arrays in this MatFile container.
            </summary>
            <param name="A">Array to be added.</param>
            <param name="key">The name to be used as key for identifying <paramref name="A"/> among the 
            arrays in this MatFile.</param>
            <returns>String used to identify the array in the collection of arrays.</returns>
            <exception cref="T:System.ArgumentException">If the new name <paramref name="key"/> or the element 
            type of <paramref name="A"/> do not fullfill the restrictions defined by Matlab.</exception>
            <example><code><![CDATA[
            // MatFile should be used in an 'using' block, 
            // cleaning up its resources automatically.
            using (MatFile mat = new MatFile()) {
                mat.AddArray(counter<sbyte>(-10, 2, 4, 8, 13), "myArray");
                mat.Write("file.mat");
            }
            
            // reading back using ILMath.loadArray<T>(...)
            Array<sbyte> A = loadArray<sbyte>("file.mat", "myArray");
            Assert.IsTrue(A.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            
            // reading back using MatFile
            using (var back = new MatFile("file.mat")) {
                Array<sbyte> B = back.GetArray<sbyte>("myArray");
            
                // ... or usign cell methods: 
                Array<sbyte> C = back.Arrays.GetArray<sbyte>(0);
            
                Assert.IsTrue(B.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
                Assert.IsTrue(C.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            }
            ]]></code></example>
        </member>
        <member name="P:ILNumerics.MatFile.Filelocation">
            <summary>
            Path to mat file, if this object was created from an existing mat file.
            </summary>
            <example><code><![CDATA[
            // MatFile should be used in an 'using' block, 
            // cleaning up its resources automatically.
            using (MatFile mat = new MatFile()) {
                mat.AddArray(counter<sbyte>(-10, 2, 4, 8, 13), "myArray");
                mat.Write("file.mat");
            }
            
            // reading back using ILMath.loadArray<T>(...)
            Array<sbyte> A = loadArray<sbyte>("file.mat", "myArray");
            Assert.IsTrue(A.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            
            // reading back using MatFile
            using (var back = new MatFile("file.mat")) {
                Array<sbyte> B = back.GetArray<sbyte>("myArray");
            
                // ... or usign cell methods: 
                Array<sbyte> C = back.Arrays.GetArray<sbyte>(0);
            
                Assert.IsTrue(B.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
                Assert.IsTrue(C.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            }
            ]]></code></example>
        </member>
        <member name="P:ILNumerics.MatFile.Keys">
            <summary>
            List all key names currently stored with arrays 
            </summary>
        </member>
        <member name="P:ILNumerics.MatFile.Arrays">
            <summary>
            Retrieve a cell with all arrays stored in the mat file
            </summary>
            <remarks>The cell returned will be clone of the arrays stored in the mat file. Altering any cell 
            elements will leave the arrays in the matfile (class/memory object) untouched.
            <para>The cell returned will be of size [n,2], where n is the number of arrays contained. The 
            first row saved the arrays, the second row containes scalar string arrays with the name of 
            the array in the corresponding row.</para>
            </remarks>
            <example><code><![CDATA[
            // MatFile should be used in an 'using' block, 
            // cleaning up its resources automatically.
            using (MatFile mat = new MatFile()) {
                mat.AddArray(counter<sbyte>(-10, 2, 4, 8, 13), "myArray");
                mat.Write("file.mat");
            }
            
            // reading back using ILMath.loadArray<T>(...)
            Array<sbyte> A = loadArray<sbyte>("file.mat", "myArray");
            Assert.IsTrue(A.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            
            // reading back using MatFile
            using (var back = new MatFile("file.mat")) {
                Array<sbyte> B = back.GetArray<sbyte>("myArray");
            
                // ... or usign cell methods: 
                Array<sbyte> C = back.Arrays.GetArray<sbyte>(0);
            
                Assert.IsTrue(B.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
                Assert.IsTrue(C.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            }
            ]]></code></example>
            <seealso cref="T:ILNumerics.Cell"/>
        </member>
        <member name="P:ILNumerics.MatFile.Item(System.String)">
            <summary>
            Retrieves an array from this MatFile instance or replaces it.
            </summary>
            <param name="name">The name of the array to retrieve or replace.</param>
            <remarks><para>The 'get' accessor is provided for compatibility reasons only. It may be removed in a future version!
            Use one of the typed retrieval functions <see cref="M:ILNumerics.MatFile.GetArray``1(System.String)"/> or 
            <see cref="M:ILNumerics.MatFile.GetArray``1(System.Int32)"/> instead.</para>
            <para>For get access the name must exist as key in the container. Use the MatFile.Keys property to get a list of all names if needed</para>
            <para>For set access, the name given must not be null or empty. It cannot be one of the <see cref="F:ILNumerics.MatFile.ReservedKeywords">ReservedKeywords</see>.
            If the name allready exist in the collection as name, the array currently assigned to it will be replaced. If the value is null, the current 
            array will be removed from the list. If the name does not already exist, the new array will be added and assigned to this name.</para>
            <para>Restrictions on array names: Matlab allows variables to have names of maximum length 63. Longer names are abbreviated. Names must start 
            with a letter and contain only digits, (ASCII) letters or underscores '_'.</para></remarks>
            <exception cref="T:System.ArgumentException">If the name violates a Matlab naming rule.</exception>
        </member>
        <member name="P:ILNumerics.MatFile.Count">
            <summary>
            Number of arrays in the mat file container
            </summary>
        </member>
        <member name="M:ILNumerics.MatFile.GetArray``1(System.String)">
            <summary>
            Retrieves array by name.
            </summary>
            <typeparam name="T">Expected type of the array</typeparam>
            <param name="name">Name of the array to retrieve.</param>
            <returns>A clone of the array found or null, if no array with the given name exists.</returns>
            <example><code><![CDATA[
            // MatFile should be used in an 'using' block, 
            // cleaning up its resources automatically.
            using (MatFile mat = new MatFile()) {
                mat.AddArray(counter<sbyte>(-10, 2, 4, 8, 13), "myArray");
                mat.Write("file.mat");
            }
            
            // reading back using ILMath.loadArray<T>(...)
            Array<sbyte> A = loadArray<sbyte>("file.mat", "myArray");
            Assert.IsTrue(A.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            
            // reading back using MatFile
            using (var back = new MatFile("file.mat")) {
                Array<sbyte> B = back.GetArray<sbyte>("myArray");
            
                // ... or usign cell methods: 
                Array<sbyte> C = back.Arrays.GetArray<sbyte>(0);
            
                Assert.IsTrue(B.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
                Assert.IsTrue(C.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            }
            ]]></code></example>
        </member>
        <member name="M:ILNumerics.MatFile.GetArray``1(System.Int32)">
            <summary>
            Retrieve array by index
            </summary>
            <typeparam name="T">Expected type of the array</typeparam>
            <param name="index">Index of the array</param>
            <returns>A clone of the array found or null, if no array at the given index exists</returns>
            <example><code><![CDATA[
            // MatFile should be used in an 'using' block, 
            // cleaning up its resources automatically.
            using (MatFile mat = new MatFile()) {
                mat.AddArray(counter<sbyte>(-10, 2, 4, 8, 13), "myArray");
                mat.Write("file.mat");
            }
            
            // reading back using ILMath.loadArray<T>(...)
            Array<sbyte> A = loadArray<sbyte>("file.mat", "myArray");
            Assert.IsTrue(A.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            
            // reading back using MatFile
            using (var back = new MatFile("file.mat")) {
                Array<sbyte> B = back.GetArray<sbyte>("myArray");
            
                // ... or usign cell methods: 
                Array<sbyte> C = back.Arrays.GetArray<sbyte>(0);
            
                Assert.IsTrue(B.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
                Assert.IsTrue(C.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            }
            ]]></code></example>
        </member>
        <member name="M:ILNumerics.MatFile.Write(System.IO.Stream)">
            <summary>
            Write this mat file into a binary stream
            </summary>
            <param name="stream">Stream to receive data. This will commonly be a FileStream object.</param>
            <remarks>
            <para>This method writes the full content of the current mat file into a binary stream. The file 
            afterwards is suitable to be read again by ILNumerics.MatFile classes or by compatible *.mat file 
            readers - including Matlab, e.g.</para>
            <example><code>
            MatFile m = new MatFile(myarrays); 
            using (Stream s = new FileStream("test.mat",FileMode.Create)) {
                m.Write(s);
            }
            </code></example></remarks>
        </member>
        <member name="M:ILNumerics.MatFile.Write(System.String)">
            <summary>
            Write all arrays to *.mat file
            </summary>
            <param name="filename">Filename of the file to write the mat file to</param>
            <remarks>
            <para>The method writes the full content of the matfile to the file specified. If the filename 
            points to a file which already exists, that file will be overwritten. Otherwise a new file will
            be created. </para>
            <para>The file will be suitable for reading by ILNumerics.MatFile classes or by compatible *.mat file 
            readers - including e.g. matlab</para>
            </remarks>
            <example><code><![CDATA[
            // MatFile should be used in an 'using' block, 
            // cleaning up its resources automatically.
            using (MatFile mat = new MatFile()) {
                mat.AddArray(counter<sbyte>(-10, 2, 4, 8, 13), "myArray");
                mat.Write("file.mat");
            }
            
            // reading back using ILMath.loadArray<T>(...)
            Array<sbyte> A = loadArray<sbyte>("file.mat", "myArray");
            Assert.IsTrue(A.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            
            // reading back using MatFile
            using (var back = new MatFile("file.mat")) {
                Array<sbyte> B = back.GetArray<sbyte>("myArray");
            
                // ... or usign cell methods: 
                Array<sbyte> C = back.Arrays.GetArray<sbyte>(0);
            
                Assert.IsTrue(B.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
                Assert.IsTrue(C.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            }
            ]]></code></example>
        </member>
        <member name="M:ILNumerics.MatFile.#ctor(System.String)">
            <summary>
            Create MatFile object from existing mat file 
            </summary>
            <param name="file2open">Path to Matlab mat file to open</param>
            <remarks>Curently mat files up to Matlab version 6.5 are supported. Compressed mat file content is not supported yet.</remarks>
            <example><code><![CDATA[
            // MatFile should be used in an 'using' block, 
            // cleaning up its resources automatically.
            using (MatFile mat = new MatFile()) {
                mat.AddArray(counter<sbyte>(-10, 2, 4, 8, 13), "myArray");
                mat.Write("file.mat");
            }
            
            // reading back using ILMath.loadArray<T>(...)
            Array<sbyte> A = loadArray<sbyte>("file.mat", "myArray");
            Assert.IsTrue(A.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            
            // reading back using MatFile
            using (var back = new MatFile("file.mat")) {
                Array<sbyte> B = back.GetArray<sbyte>("myArray");
            
                // ... or usign cell methods: 
                Array<sbyte> C = back.Arrays.GetArray<sbyte>(0);
            
                Assert.IsTrue(B.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
                Assert.IsTrue(C.Equals(counter<sbyte>(-10, 2, 4, 8, 13)));
            }
            ]]></code></example>
        </member>
        <member name="M:ILNumerics.MatFile.#ctor(ILNumerics.InCell)">
            <summary>
            Create MatFile object from multiple arrays of arbitrary types. Automatically choose array names for saving.
            </summary>
            <param name="input">Cell array holding the arrays to be added to the <see cref="T:ILNumerics.MatFile"/>. The size of the cell is neglected. Elements are read in column major order.</param>
            <exception cref="T:System.ArgumentException">If <paramref name="input"/> or any element in <paramref name="input"/>
            is or points to null.</exception>
            <example><code><![CDATA[
            Array<sbyte> A = counter<sbyte>(-10, 2, 4, 8, 13);
            Array<double> B = ones<double>(199, 200);
            
            // MatFile should be used in an 'using' block, 
            // cleaning up its resources automatically.
            using (MatFile mat = new MatFile(cellv(A, B))) {
                mat.Write("file.mat");
            }
            
            // reading back using ILMath.loadArray<T>(...)
            Array<sbyte> C = loadArray<sbyte>("file.mat", "Array0"); // names are automatic
            Array<double> D = loadArray<double>("file.mat", "Array1");
            Assert.IsTrue(C.Equals(A));
            Assert.IsTrue(D.Equals(B));
            ]]></code></example>
            <exception cref="T:System.ArgumentNullException">If input array was null or one of the arrays in the input arrays was null.</exception>
            <seealso cref="P:ILNumerics.MatFile.Keys"/>
            <seealso cref="M:ILNumerics.MatFile.AddArray``1(ILNumerics.BaseArray{``0},System.String)"/>
        </member>
        <member name="M:ILNumerics.MatFile.#ctor">
            <summary>
            Create an empty MatFile object. To be used to add arrays later on.
            </summary>
            <seealso cref="M:ILNumerics.MatFile.#ctor(ILNumerics.InCell)"/>
            <seealso cref="M:ILNumerics.MatFile.AddArray``1(ILNumerics.BaseArray{``0},System.String)"/>
        </member>
        <member name="M:ILNumerics.MatFile.Dispose">
            <summary>
            Dispose all arrays of the matfile object
            </summary>
            <remarks>Calling dispose should be the last action for a matfile object. It is recommended to 
            utilize the matfile class in using blocks (C# / Visual Basic).</remarks>
        </member>
        <member name="T:ILNumerics.Result`1">
            <summary>
            Result datatype, used for storing computational results and applying them to new data within ILNumerics stateful function objects.
            </summary>
            <typeparam name="T">Datatype of underlying array elements.</typeparam>
        </member>
        <member name="P:ILNumerics.Result`1.IsDisposed">
            <summary>
            Flag to indicate if the result is disposed.
            </summary>
        </member>
        <member name="M:ILNumerics.Result`1.Apply(ILNumerics.InArray{`0},ILNumerics.InCell)">
            <summary>
            Apply the result on new datapoints
            </summary>
            <param name="X">New datapoints, same dimension as used for learning.</param>
            <param name="arguments">Optional arguments.</param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Result`1.Dispose">
            <summary>
            Disposes the object.
            </summary>
        </member>
        <member name="T:ILNumerics.Result`2">
            <summary>
            Result datatype, used for storing computational results and applying them to new data within ILNumerics stateful function objects
            </summary>
            <typeparam name="Tin">Datatype of input data</typeparam>
            <typeparam name="Tout">Datatype of output data</typeparam>
        </member>
        <member name="P:ILNumerics.Result`2.IsDisposed">
            <summary>
            Flag to indicate if the result is disposed.
            </summary>
        </member>
        <member name="M:ILNumerics.Result`2.Apply(ILNumerics.InArray{`0},ILNumerics.InCell)">
            <summary>
            Apply the result on new datapoints
            </summary>
            <param name="X">New datapoints, same dimension as used for learning.</param>
            <param name="arguments">Optional arguments.</param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Result`2.Dispose">
            <summary>
            Disposes the object.
            </summary>
        </member>
        <member name="T:ILNumerics.Scope">
            <summary>
            An artificial scope class, used by the ILNumerics memory management
            </summary>
            <remarks>A scope object serves the following purposes: 
            <para>It provides an option to be used within a <c>using</c> directive. Therefore, it implements the <see cref="T:System.IDisposable"/> interface.</para>
            <para>Internally it maintains a <see cref="F:ILNumerics.Scope.Count"/> variable which keeps track of the number of arrays currently maintained by the scope.</para>
            <para>Scopes participate in an efficient caching algorithm. One should not create a scope object manually via <c>new()</c>. Use the <see cref="!:Enter(BaseArray)"/> 
            and <see cref="!:Enter(BaseArray[])"/> functions instead!</para></remarks>
        </member>
        <member name="F:ILNumerics.Scope.ThreadingContext.CurScope">
            <summary>
            Index of the currently active scope. 0: no scope yet. 
            </summary>
        </member>
        <member name="M:ILNumerics.Scope.ThreadingContext.RegisterArray(ILNumerics.BaseArray)">
            <summary>
            Registers an ILNumerics array for disposal after the current scope was left. Increases the internal scope counter. For ILNumerics internal use.
            </summary>
            <param name="A">arbitrary ILNumerics array</param>
            <returns>True if this method was called .</returns>
            <remarks><para>This method is part of the memory managent of ILNumerics. You should not 
            call this method explicitely!</para>
            <para>This method registered an array in the current scope - no matter what! Regardless if the type of the array 
            is commonly registered or not. </para></remarks>
        </member>
        <member name="M:ILNumerics.Scope.ThreadingContext.StoreArray(ILNumerics.BaseArray)">
            <summary>
            Stores an array in the current scope. Does NOT modify the arrays internal data! (no m_scopeCounter increment!)
            </summary>
            <param name="A">Array to be registered.</param>
            <remarks>This function does not check for the existence of a current scope. 
            
            Such checks must be done before hand! </remarks>
        </member>
        <member name="M:ILNumerics.Scope.Enter(System.Nullable{ILNumerics.ArrayStyles})">
            <summary>
            Begins an artificial scope block within a local function, determine the array style.
            </summary>
            <param name="arrayStyle">The <see cref="P:ILNumerics.Settings.ArrayStyle"/> valid within the scope block. A non-null value will be used within the scope block as current array style.</param>
            <returns>The new scope object.</returns>
            <remarks><para>The <c>Scope</c> class plays an important role for the ILNumerics memory management. When writing functions in ILNumerics, 
            <c>Scope</c> is used to define blocks of artificial scopes for local function blocks. ILNumerics ensures that no memory 
            is left as garbage after the scope block is left. Furthermore, it garantees that input arrays are kept alive during 
            the execution of the block. By following these <a href="http://ilnumerics.net/$GeneralRules.html" target="Main">ILNumerics function rules</a> 
            ILNumerics is able to optimize the execution of the algorithm regarding execution speed and memory footprint.</para>
            <para>If a value other than null is given for <paramref name="arrayStyle"/> the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>
            is modified for the operations within this scope block. After the scope is left, the old setting is reliably restored. 
            If null is provided the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/> is not touched.</para>
            <para>Several overloads exist allowing to specify one or multiple arrays together with the array style setting.</para>
            </remarks>
            <example><para>The examples demonstrates a custom function in ILNumerics. It demonstrates the use of an artificial scope 
            block to temporarily change the array style for the thread.</para>
            <code><![CDATA[
            [TestMethod]
            public void ScopeWithArrayStyle() {
            
                using (Settings.Ensure(() => Settings.ArrayStyle, ArrayStyles.numpy)) {
                    // numpy style is valid here...
                    Assert.IsTrue(Settings.ArrayStyle == ArrayStyles.numpy);
            
                    using (Scope.Enter(ArrayStyles.ILNumericsV4)) {
                        // in the scope: array style is ILNumericsV4
            
                        Assert.IsTrue(Settings.ArrayStyle == ArrayStyles.ILNumericsV4);
            
                        // the style may be changed again ... 
                        Settings.ArrayStyle = ArrayStyles.numpy;
                        Assert.IsTrue(Settings.ArrayStyle == ArrayStyles.numpy);
                        Settings.ArrayStyle = ArrayStyles.ILNumericsV4;
                        Assert.IsTrue(Settings.ArrayStyle == ArrayStyles.ILNumericsV4);
                        // ...
                    }
                    // array style which was valid immediately before the scope began is restored 
                    Assert.IsTrue(Settings.ArrayStyle == ArrayStyles.numpy);
            
                }
            }]]></code>
            </example>
            <seealso cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/>
            <seealso cref="P:ILNumerics.Settings.ArrayStyle"/>
            <seealso cref="T:ILNumerics.ArrayStyles"/>
        </member>
        <member name="M:ILNumerics.Scope.Enter">
            <summary>
            Begins an artificial scope block within a local function.
            </summary>
            <returns>The new scope object.</returns>
            <remarks><para>The <c>Scope</c> class plays an important role for the ILNumerics memory management. When writing functions in ILNumerics, 
            <c>Scope</c> is used to define blocks of artificial scopes for local function blocks. ILNumerics ensures that no memory 
            is left as garbage after the scope block is left. Furthermore, it garantees that input arrays are kept alive during 
            the execution of the block. By following these <a href="http://ilnumerics.net/$GeneralRules.html" target="Main">ILNumerics function rules</a> 
            ILNumerics is able to optimize the execution of the algorithm regarding execution speed and memory footprint.</para>
            <para>Several overloads exist allowing to specify one or multiple arrays together with the array style setting.</para>
            </remarks>
            <example><para>The examples demonstrates a custom function in ILNumerics. It demonstrates the use of an artificial scope 
            block to temporarily change the array style for the thread.</para>
            <code><![CDATA[
            [TestMethod]
            public void ScopeWithArrayStyle() {
            
                using (Settings.Ensure(() => Settings.ArrayStyle, ArrayStyles.numpy)) {
                    // numpy style is valid here...
                    Assert.IsTrue(Settings.ArrayStyle == ArrayStyles.numpy);
            
                    using (Scope.Enter(ArrayStyles.ILNumericsV4)) {
                        // in the scope: array style is ILNumericsV4
            
                        Assert.IsTrue(Settings.ArrayStyle == ArrayStyles.ILNumericsV4);
            
                        // the style may be changed again ... 
                        Settings.ArrayStyle = ArrayStyles.numpy;
                        Assert.IsTrue(Settings.ArrayStyle == ArrayStyles.numpy);
                        Settings.ArrayStyle = ArrayStyles.ILNumericsV4;
                        Assert.IsTrue(Settings.ArrayStyle == ArrayStyles.ILNumericsV4);
                        // ...
                    }
                    // array style which was valid immediately before the scope began is restored 
                    Assert.IsTrue(Settings.ArrayStyle == ArrayStyles.numpy);
            
                }
            }]]></code>
            </example>
            <seealso cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/>
            <seealso cref="P:ILNumerics.Settings.ArrayStyle"/>
            <seealso cref="T:ILNumerics.ArrayStyles"/>
        </member>
        <member name="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})">
             <summary>
             Begins an artificial scope block within a local function block.
             </summary>
             <param name="A">Any <b>input</b> array, given as parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="arrayStyle">[Optional] The <see cref="P:ILNumerics.Settings.ArrayStyle"/> valid within the scope block. A non-null value will be used within the scope block as current array style. Default: (null) the current <see cref="P:ILNumerics.Settings.ArrayStyle"/>.</param>
             <returns>The new scope object.</returns>
             <remarks><para>The <c>Scope</c> class plays an important role for the ILNumerics memory management. When writing functions in ILNumerics, 
             <c>Scope</c> is used to define blocks of artificial scopes for local function blocks. ILNumerics ensures that no memory 
             is left as garbage after the scope block is left. Furthermore, it garantees that input arrays are kept alive during 
             the execution of the block. By following these <a href="http://ilnumerics.net/$GeneralRules.html" target="Main">ILNumerics function rules</a> 
             ILNumerics is able to optimize the execution of the algorithm regarding execution speed and memory footprint.</para>
             <para>If a value other than null is given for <paramref name="arrayStyle"/> the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>
             is modified for the operations within this scope block. After the scope is left, the old setting is reliably restored. 
             If null is provided (default) the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/> is not touched.</para>
             </remarks>
             <example><para>The examples demonstrates a custom function in ILNumerics. It demonstrates the use of distinct array types in the function declaration and the use of 
             artificial scopes.</para>
             <code><![CDATA[RetArray<double> FreqPeaks(InArray<double> inData, OutArray<double> freq = null, double sampFreq = 44.1) { 
            
                using (Scope.Enter(inData)) {    
                         
                    Array<double> Data = check(inData); 
                    Array<double> retLength = min(ceil(Data.Length / 2.0 + 1), 5.0);   
                    Array<double> Window = stdWindowFunc(Data.Length);  
                    Array<double> magnitudes = abs(fft(Data * Window));  
                    magnitudes = magnitudes[r(0,end / 2 + 1)];  
             
                    Array<double> indices = empty();  
                    Array<double> sorted = sort(magnitudes, indices, descending:true);  
                    if (!isnull(freq)) 
                        freq.a = (sampFreq / 2.0 / magnitudes.Length * indices)[r(0,retLength-1)];  
                    return magnitudes[r(0,retLength-1)];  
                } 
            }]]></code>
             </example>
             <seealso cref="P:ILNumerics.Settings.ArrayStyle"/>
             <seealso cref="T:ILNumerics.ArrayStyles"/>
        </member>
        <member name="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})">
             <summary>
             Begins an artificial scope block within a local function block.
             </summary>
             <param name="A">An <b>input</b> array, parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="B">A second <b>input</b> array, parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="arrayStyle">[Optional] The <see cref="P:ILNumerics.Settings.ArrayStyle"/> valid within the scope block. A non-null value will be used within the scope block as current array style. Default: (null) the current <see cref="P:ILNumerics.Settings.ArrayStyle"/>.</param>
             <returns>The new scope object.</returns>
             <remarks><para>The <c>Scope</c> class plays an important role for the ILNumerics memory management. When writing functions in ILNumerics, 
             <c>Scope</c> is used to define blocks of artificial scopes for local function blocks. ILNumerics ensures, no memory is left as garbage, once 
             such a scope block was left. Furthermore, it garantees, input arrays are kept alive during the execution of the block. By following these 
             <a href="http://ilnumerics.net/$GeneralRules.html" target="Main">simple rules</a>, ILNumerics is able to optimize the execution of the algorithm regarding 
             execution speed and memory footprint.</para>
             <para>If a value other than null is given for <paramref name="arrayStyle"/> the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>
             is modified for the operations within this scope block. After the scope is left, the old setting is reliably restored. 
             If null is provided (default) the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/> is not touched.</para>
             </remarks>
             <example><para>The examples demonstrates a custom function in ILNumerics. It demonstrates the use of distinct array types in the function declaration and the use of 
             artificial scopes.</para>
             <code><![CDATA[RetArray<double> FreqPeaks(InArray<double> inData, OutArray<double> freq = null, double sampFreq = 44.1) { 
            
                using (Scope.Enter(inData)) {    
                         
                    Array<double> Data = check(inData); 
                    Array<double> retLength = min(ceil(Data.Length / 2.0 + 1), 5.0);   
                    Array<double> Window = stdWindowFunc(Data.Length);  
                    Array<double> magnitudes = abs(fft(Data * Window));  
                    magnitudes = magnitudes[r(0,end / 2 + 1)];  
             
                    Array<double> indices = empty();  
                    Array<double> sorted = sort(magnitudes, indices, descending:true);  
                    if (!isnull(freq)) 
                        freq.a = (sampFreq / 2.0 / magnitudes.Length * indices)[r(0,retLength-1)];  
                    return magnitudes[r(0,retLength-1)];  
                } 
            }]]></code>
             </example>
        </member>
        <member name="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})">
             <summary>
             Begins an artificial scope block within a local function block.
             </summary>
             <param name="A">An <b>input</b> array, parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="B">A second <b>input</b> array, parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="C">A third <b>input</b> array, parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="arrayStyle">[Optional] The <see cref="P:ILNumerics.Settings.ArrayStyle"/> valid within the scope block. A non-null value will be used within the scope block as current array style. Default: (null) the current <see cref="P:ILNumerics.Settings.ArrayStyle"/>.</param>
             <returns>The new scope object.</returns>
             <remarks><para>The <c>Scope</c> class plays an important role for the ILNumerics memory management. When writing functions in ILNumerics, 
             <c>Scope</c> is used to define blocks of artificial scopes for local function blocks. ILNumerics ensures, no memory is left as garbage, once 
             such a scope block was left. Furthermore, it garantees, input arrays are kept alive during the execution of the block. By following these 
             <a href="http://ilnumerics.net/$GeneralRules.html" target="Main">simple rules</a>, ILNumerics is able to optimize the execution of the algorithm regarding 
             execution speed and memory footprint.</para>
             <para>If a value other than null is given for <paramref name="arrayStyle"/> the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>
             is modified for the operations within this scope block. After the scope is left, the old setting is reliably restored. 
             If null is provided (default) the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/> is not touched.</para>
             </remarks>
             <example><para>The examples demonstrates a custom function in ILNumerics. It demonstrates the use of distinct array types in the function declaration and the use of 
             artificial scopes.</para>
             <code><![CDATA[RetArray<double> FreqPeaks(InArray<double> inData, OutArray<double> freq = null, double sampFreq = 44.1) { 
            
                using (Scope.Enter(inData)) {    
                         
                    Array<double> Data = check(inData); 
                    Array<double> retLength = min(ceil(Data.Length / 2.0 + 1), 5.0);   
                    Array<double> Window = stdWindowFunc(Data.Length);  
                    Array<double> magnitudes = abs(fft(Data * Window));  
                    magnitudes = magnitudes[r(0,end / 2 + 1)];  
             
                    Array<double> indices = empty();  
                    Array<double> sorted = sort(magnitudes, indices, descending:true);  
                    if (!isnull(freq)) 
                        freq.a = (sampFreq / 2.0 / magnitudes.Length * indices)[r(0,retLength-1)];  
                    return magnitudes[r(0,retLength-1)];  
                } 
            }]]></code>
             </example>
             <returns>The new scope object.</returns>
        </member>
        <member name="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})">
             <summary>
             Begins an artificial scope block within a local function block.
             </summary>
             <param name="A">An <b>input</b> array, parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="B">A second <b>input</b> array, parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="C">A third <b>input</b> array, parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="D">A fourth <b>input</b> array, parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="arrayStyle">[Optional] The <see cref="P:ILNumerics.Settings.ArrayStyle"/> valid within the scope block. A non-null value will be used within the scope block as current array style. Default: (null) the current <see cref="P:ILNumerics.Settings.ArrayStyle"/>.</param>
             <returns>The new scope object.</returns>
             <remarks><para>The <c>Scope</c> class plays an important role for the ILNumerics memory management. When writing functions in ILNumerics, 
             <c>Scope</c> is used to define blocks of artificial scopes for local function blocks. ILNumerics ensures, no memory is left as garbage, once 
             such a scope block was left. Furthermore, it garantees, input arrays are kept alive during the execution of the block. By following these 
             <a href="http://ilnumerics.net/$GeneralRules.html" target="Main">simple rules</a>, ILNumerics is able to optimize the execution of the algorithm regarding 
             execution speed and memory footprint.</para>
             <para>If a value other than null is given for <paramref name="arrayStyle"/> the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>
             is modified for the operations within this scope block. After the scope is left, the old setting is reliably restored. 
             If null is provided (default) the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/> is not touched.</para>
             </remarks>
             <example><para>The examples demonstrates a custom function in ILNumerics. It demonstrates the use of distinct array types in the function declaration and the use of 
             artificial scopes.</para>
             <code><![CDATA[RetArray<double> FreqPeaks(InArray<double> inData, OutArray<double> freq = null, double sampFreq = 44.1) { 
            
                using (Scope.Enter(inData)) {    
                         
                    Array<double> Data = check(inData); 
                    Array<double> retLength = min(ceil(Data.Length / 2.0 + 1), 5.0);   
                    Array<double> Window = stdWindowFunc(Data.Length);  
                    Array<double> magnitudes = abs(fft(Data * Window));  
                    magnitudes = magnitudes[r(0,end / 2 + 1)];  
             
                    Array<double> indices = empty();  
                    Array<double> sorted = sort(magnitudes, indices, descending:true);  
                    if (!isnull(freq)) 
                        freq.a = (sampFreq / 2.0 / magnitudes.Length * indices)[r(0,retLength-1)];  
                    return magnitudes[r(0,retLength-1)];  
                } 
            }]]></code>
             </example>
        </member>
        <member name="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})">
             <summary>
             Begins an artificial scope block within a local function block.
             </summary>
             <param name="A">An <b>input</b> array, parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="B">A second <b>input</b> array, parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="C">A third <b>input</b> array, parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="D">A fourth <b>input</b> array, parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="E">A fifth <b>input</b> array, parameter for the current function. Input arrays are: <see cref="T:ILNumerics.InArray`1"/>, <see cref="T:ILNumerics.InCell"/>, and <see cref="T:ILNumerics.InLogical"/>.</param>
             <param name="arrayStyle">[Optional] The <see cref="P:ILNumerics.Settings.ArrayStyle"/> valid within the scope block. A non-null value will be used within the scope block as current array style. Default: (null) the current <see cref="P:ILNumerics.Settings.ArrayStyle"/>.</param>
             <returns>The new scope object.</returns>
             <remarks><para>The <c>Scope</c> class plays an important role for the ILNumerics memory management. When writing functions in ILNumerics, 
             <c>Scope</c> is used to define blocks of artificial scopes for local function blocks. ILNumerics ensures, no memory is left as garbage, once 
             such a scope block was left. Furthermore, it garantees, input arrays are kept alive during the execution of the block. By following these 
             <a href="http://ilnumerics.net/$GeneralRules.html" target="Main">simple rules</a>, ILNumerics is able to optimize the execution of the algorithm regarding 
             execution speed and memory footprint.</para>
             <para>If a value other than null is given for <paramref name="arrayStyle"/> the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/>
             is modified for the operations within this scope block. After the scope is left, the old setting is reliably restored. 
             If null is provided (default) the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle"/> is not touched.</para>
             </remarks>
             <example><para>The examples demonstrates a custom function in ILNumerics. It demonstrates the use of distinct array types in the function declaration and the use of 
             artificial scopes.</para>
             <code><![CDATA[RetArray<double> FreqPeaks(InArray<double> inData, OutArray<double> freq = null, double sampFreq = 44.1) { 
            
                using (Scope.Enter(inData)) {    
                         
                    Array<double> Data = check(inData); 
                    Array<double> retLength = min(ceil(Data.Length / 2.0 + 1), 5.0);   
                    Array<double> Window = stdWindowFunc(Data.Length);  
                    Array<double> magnitudes = abs(fft(Data * Window));  
                    magnitudes = magnitudes[r(0,end / 2 + 1)];  
             
                    Array<double> indices = empty();  
                    Array<double> sorted = sort(magnitudes, indices, descending:true);  
                    if (!isnull(freq)) 
                        freq.a = (sampFreq / 2.0 / magnitudes.Length * indices)[r(0,retLength-1)];  
                    return magnitudes[r(0,retLength-1)];  
                } 
            }]]></code>
             </example>
        </member>
        <member name="P:ILNumerics.Scope.Context">
            <summary>
            The threading context - individual for each thread
            </summary>
        </member>
        <member name="P:ILNumerics.Scope.ArrayStyle">
            <summary>
            Determines the array style to be used within the scope. This 
            must be called once during <see cref="M:ILNumerics.Scope.Enter(ILNumerics.BaseArray,System.Nullable{ILNumerics.ArrayStyles})"/> or in related overloads.
            </summary>
        </member>
        <member name="M:ILNumerics.Scope.#ctor">
            <summary>
            Creates an empty scope. 
            </summary>
        </member>
        <member name="M:ILNumerics.Scope.Dispose">
            <summary>
            Release all arrays in this scope.
            </summary>
        </member>
        <member name="T:ILNumerics.Settings">
            <summary>
            The class provides static setting properties to control the behaviour of ILNumerics, see <a href="http://ilnumerics.net/$Configuration.html">Configuration</a> in the online documentation
            </summary>
        </member>
        <member name="F:ILNumerics.Settings.KnownIDENames">
            <summary>
            List of known IDE executable names used for detecting design mode and disabling OpenGL renderers for unsupported IDE.
            </summary>
            <remarks><para>Currently the known IDEs span the following exe names: "devenv", "vbexpress", "vcsexpress", "vwdexpress", and "monodevelop".</para></remarks>
        </member>
        <member name="P:ILNumerics.Settings.ArrayStyle">
            <summary>
            Controls the way nd-arrays work. Affects the shape of arrays, the default storage order and the handling of subarray / indexing expressions. Thread static. Default: <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>.
            </summary>
            <remarks><para>This settings controls the way arrays work. Valid options are <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> and <see cref="F:ILNumerics.ArrayStyles.numpy"/>.</para>
            <para>This affects the number and shape of vectors and scalars, of arrays returned from subarray expressions / indexing, 
            the handling of unspecified trailing dimensions in indexing expressions, the default storage order and others. </para>
            <para>The default value is <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>. It corresponds to the ILNumerics version 4, Matlab(R), octave and Julia systems. 
            The setting of <see cref="F:ILNumerics.ArrayStyles.numpy"/> corresponds to numpys ndarrays. See <see href="/array-styles_v5.html"/> 
            for a comprehensive list of aspects affected by this setting.</para>
            <para>Other settings which directly derive their value from the value of <see cref="P:ILNumerics.Settings.ArrayStyle"/> are: 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> and <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>This setting is controlled on a thread level! Modifications affect the current thread only
            and do not change the behavior in other threads! This enables one to safely switch between individual  
            styles in multithreaded algorithms.</para>
            <para>New threads are initialized with a value for <see cref="P:ILNumerics.Settings.ArrayStyle"/> according to <see cref="P:ILNumerics.Settings.DefaultArrayStyle"/>.</para>
            <para>In order to set <see cref="P:ILNumerics.Settings.ArrayStyle"/> to <see cref="F:ILNumerics.ArrayStyles.numpy"/> a valid license for the ILNumerics.numpy module is required.</para>
            </remarks>
            <see cref="M:ILNumerics.Settings.Ensure``1(System.Linq.Expressions.Expression{System.Func{``0}},``0)"/>
            <see cref="T:ILNumerics.ArrayStyles"/>
            <seealso href="/array-styles_v5.html"/>
        </member>
        <member name="P:ILNumerics.Settings.DefaultArrayStyle">
            <summary>
            Default array style for initializing the property in new threads. Default: <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>.
            </summary>
            <remarks>The value of this property is used as the <see cref="P:ILNumerics.Settings.ArrayStyle"/> of new computational threads.
            </remarks>
            <see cref="M:ILNumerics.Settings.Ensure``1(System.Linq.Expressions.Expression{System.Func{``0}},``0)"/>
            <see cref="T:ILNumerics.ArrayStyles"/>
        </member>
        <member name="P:ILNumerics.Settings.DefaultStorageOrder">
            <summary>
             The default storage order for new storages. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>. Readonly (controlled by ArrayStyle). 
            </summary>
            <remarks>
            <para>This setting is controlled by the <see cref="P:ILNumerics.Settings.ArrayStyle"/> configuration setting. It returns <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> 
            for <see cref="P:ILNumerics.Settings.ArrayStyle"/> = <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>, and <see cref="F:ILNumerics.StorageOrders.RowMajor"/> for <see cref="P:ILNumerics.Settings.ArrayStyle"/> = <see cref="F:ILNumerics.ArrayStyles.numpy"/>.</para>
            <para>Valid values are:<see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> and <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</para></remarks>
            <seealso cref="T:ILNumerics.ArrayStyles"/>
            <seealso cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="P:ILNumerics.Settings.MinNumberOfArrayDimensions">
            <summary>
            Minimum number of array dimensions. Default: 2 (Matlab, Octave, ILNumerics v4 compatibility). Readonly, controlled by <see cref="P:ILNumerics.Settings.ArrayStyle"/>.
            </summary>
            <remarks><para>This configuration value affects the number of dimensions of newly created arrays. By 
            default ILNumerics maintains compatibility with Matlab / Octave bahavior, where all arrays are considered 
            matrices and carry two dimensions or more. Scalars and 1-dim arrays (vectors) are represented by matrices of 
            [1 x 1], [n x 1] or [1 x n] shapes.</para>
            <para>Attempts to create an array with a number of dimensions of less than 2 will transparently create 
            a corresponding matrix (2 dimensions) with trailing singleton dimensions of length 1.</para>
            <para>This behavior can be changed by configuring the library for <see cref="P:ILNumerics.Settings.ArrayStyle"/> = <see cref="F:ILNumerics.ArrayStyles.numpy"/>.  
            which will also allow true vectors (1 dimension) and 'numpy array scalars' with 0 dimensions.</para>
            </remarks>
            <seealso cref="T:ILNumerics.ArrayStyles"/>
            <seealso cref="P:ILNumerics.Settings.ArrayStyle"/>
        </member>
        <member name="P:ILNumerics.Settings.WMIInfo">
            <summary>
            WMI info object with detailed information about the current hardware, namely processor info. 
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.HDF5DefaultStringEncoding">
            <summary>
            Gets or sets the default string encoding for newly created HDF5 objects. Default: UTF8. 
            </summary>
            <remarks><para>Currently, strings in HDF5 support two encodings: UTF8 and ASCII. While in HDF5 ASCII encoding is the default
            ILNumerics uses UTF8 as default(!)</para> 
            <para>This settings affects object names like datasets, attributes and link names only at creation time. For existing objects the 
            encoding is stored with the object and automatically retrieved by ILNumerics. Once an object was created the encoding for its 
            name cannot be changed anymore.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Settings.DefaultRenderer">
            <summary>
            Configures or defines the default renderer used for interactive drawing controls like ILPanel, default: null (auto) 
            </summary>
            <remarks><para>By default, ILNumerics selects the optimal renderer for interactive panels (<see cref="N:ILNumerics.Drawing"></see>) automatically. For situations where 
            this does not work efficiently, the user is able to define the default renderer manually by setting this flag, either via app.config or programmatically.</para>
            <para>The setting will be considered for all panels created with ILNumerics at a later point.</para>
            <para>When setting this property via app.config, use the key 'ILNDefaultRenderer' and provide it one of the values of the RendererTypes enum. Valid values are any available interactive renderer: 
            <list type="bullet">
            <item>GDI</item>
            <item>OpenGL</item>
            <item>DirectX</item>
            </list></para>
            <para>Using no setting signals ILNumerics to determine the optimal renderer automatically. This will cause OpenGL to be used. In a later version, on Windows it will default to DirectX.</para>
            <para>Keep in mind, the actual type of the renderer used at runtime may differs from that setting, since ILNumerics prevents from known situations where certain renderers are not working properly.</para>
            <para>ILNuerics provides the following options to determine the actual renderer used for ILPanel. Settings are applied in the following order. Subsequent settings may override values which were set earlier.</para>
            <list type="bullet">
            <item>ILNumerics.Settings, applied via app.config value 'ILNDefaultRenderer'</item>
            <item>ILNumerics.Settings, applied programmatically: <code>Settings.DefaultRenderer = ... </code></item>
            <item>Individual driver configuration for each <code>ILPanel</code>: <code>ILPanel.Driver = ... RendererTypes.OpenGL /  ...</code></item>
            </list></remarks>
        </member>
        <member name="P:ILNumerics.Settings.ShowMessageBoxOnGDIFallback">
            <summary>
            Gets or sets a flag indicating if a message box is shown to the user, once the rendering driver falls back to GDI; default: true
            </summary>
            <remarks><para>If at runtime unrecoverable errors prevent the driver from rendering successfully, a message box will inform the user 
            about the issue before the driver falls backt to GDI rendering. Setting this flag to false prevents the message box from showing.</para>
            <para>Potential problems with accelerated drivers commonly include: 
            <list type="bullet">
            <item>Outdated drivers: for OpenGL GPU rendering, currently OpenGL version 3.1 or higher is required.</item>
            <item>Buggy drivers: especially 'first day support' drivers often show bugs with newer OpenGL functionality</item>
            <item>Deactivated drivers: mobile devices sometimes deactivate GPU rendering for energy savings</item>
            <item>Virtual machines and remote desktop connections do often provide limited access to graphics hardware only. This may leads to OpenGL contexts of 
            lower versions than neccessary and/or to the use of software implementations for OpenGL which may cause common problems with ILNumerics drawing controls. </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Settings.OpenGL31_FIX_GL_CLIPVERTEX">
            <summary>
            Work around OpenGL driver issues regarding GL_ClipDistance; set to true on problems on older GL 3.1 hardware (like GT 3XXM series); default: auto
            </summary>
            <remarks>On GL version 3.1 contexts, if the linking of affected shaders fails, the switch is automatically set to true.</remarks>
        </member>
        <member name="P:ILNumerics.Settings.LogVerbosityLevel">
            <summary>
            Gets the level of verbosity for information sent to application trace logs during run, or sets it. 
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.NativeDependenciesAbsolutePath">
            <summary>
            The absolute directory where ILNumerics should look for native dependencies (LAPACK, HDF5 etc.); default: empty string 
            </summary>
            <remarks><para>By default (i.e.: empty string) ILNumerics will automatically determine the include path for native dependencies on startup. 
            In order to do so, the bitrate (Environment.Is64BitProcess) is examined and depending on its value one of 'bin32' or 'bin64' is 
            added to the beginning of the current PATH environment variable.</para>
            <para>In order to overwrite this behavior, one may set the absolut path to be included here. Note, this will prevent the 
            automatic (bitrate dependend) behaviour! When configuring the NativeDependenciesAbsolutePath the user must keep the 
            current bitrate into account and is responsible for placing the right binary distribution files into that folder. </para></remarks>
        </member>
        <member name="P:ILNumerics.Settings.ManagedMultiplyBlockSize">
            <summary>
            Block size used for blocked managed matrix multiply, default: 150
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MinimumQuicksortLength">
            <summary>
            Determine the minimum length for arrays to be sorted via Quicksort algorithm, smaller arrays are sorted via insertion sort
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MaxNumberThreads">
            <summary>
            Maximum number of threads for parallel execution of internal functions in ILNumerics.
            </summary>
            <remarks>
            <para>In order to maximize execution speed of numerical algorithms, the value of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/> should be equal to the number 
            of <b>real</b> processor cores on the system. For processors utilizing <a href="http://en.wikipedia.org/wiki/Hyper-threading">Hyper-threading</a> the number on virtual cores 
            may be higher. However, since those virtual cores share certain ressources for execution they would not be of great help for many computational functions. Hence, 
            the number of 'cores' appearing e.g. in the windows task manager is misleading and the true number of independent cores should be considered for <see cref="P:ILNumerics.Settings.MaxNumberThreads"/> 
            instead. Consult your proccessor vendor in order to find out, how many independant cores your system utilizes.</para>
            <para>If, on the other hand, your algorithm mainly performs search and replace style data processing where the numerical coprocessor is rarely needed it 
            may pay of to utilize more threads in parallel. In this case you may try higher values here. The default value is the number of main processor cores, though.</para>
            <para>If your algorithm uses a custom parallel execution models, it may 
            be necessary to set this value to '1'. ILNumerics will run single threaded then - leaving you the option to configure 
            the execution on parallel threads on your own.</para>
            <para>The setting of this value also effects the corresponding value of any unmanaged optimized support library (e.g. MKL), which is internally used by ILNumerics.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Settings.MaxNumberThreadsConfigured">
            <summary>
            Determines, whether the current setting of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/> is the result of a custom configuration (true) or automatic system inspection (false).
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MinParallelElement1Count">
            <summary>
            Threshold used to determine, if computations of O(n) built-in-functions are done in parallel on multicore machines; default: 1000.
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MinElementLength4SystemArrayCopy">
            <summary>
            Threshold used to determine the minimum number of elements for system array copy. default: 10.
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth">
            <summary>
            Maximum recursion depth the quicksort algorithm can go. Default: 100 (for array length up to 2^100).
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.ToStringMaxNumberElementsPerDimension">
            <summary>
            Upper limit on the number of elements per dimension printed for an array in textual representations. Default: 101.
            </summary>
            <remarks><para>This setting limits the number of elements shown along any dimension when arrays are converted to strings. 
            This value affects the result of calling <see cref="M:System.Object.ToString"/> on ILNumerics arrays. It does also 
            affect the ouput when displaying arrays contents in the Visual Studio 'Immediate Window' and the information displayed in data tips during a 
            Visual Studio debug session.</para>
            </remarks>
            <seealso cref="P:ILNumerics.Settings.ToStringMaxNumberElements"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.ToString"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.ToString(System.UInt32,System.UInt32,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean,System.Nullable{System.Int32})"/>
            <seealso cref="M:ILNumerics.Settings.LoadDefaults"></seealso>
        </member>
        <member name="P:ILNumerics.Settings.ToStringMaxNumberElements">
            <summary>
            Upper limit on the overall number of elements printed for an array in textual representations. Default: 10000.
            </summary>
            <remarks><para>This setting limits the overall number of elements shown when arrays are converted to strings.</para>
            <para>In difference to the value of <see cref="P:ILNumerics.Settings.ToStringMaxNumberElementsPerDimension"/>, which controls the number
            of elements shown along any dimension - 
            <see cref="P:ILNumerics.Settings.ToStringMaxNumberElements"/> limits the number of elements shown for the whole array. </para>
            <para>This value affects the result of calling <see cref="M:System.Object.ToString"/> on ILNumerics arrays. It does also 
            affect the ouput when displaying arrays contents in Visual Studio tool windows, like the 'Immediate Window' and the 
            information displayed in data tips during a Visual Studio debug session.</para>
            </remarks>
            <seealso cref="P:ILNumerics.Settings.ToStringMaxNumberElementsPerDimension"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.ToString"/>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.ToString(System.UInt32,System.UInt32,System.Nullable{ILNumerics.StorageOrders},System.Boolean,System.Boolean,System.Nullable{System.Int32})"/>
            <seealso cref="M:ILNumerics.Settings.LoadDefaults"></seealso>
        </member>
        <member name="M:ILNumerics.Settings.LoadDefaults">
            <summary>
            (Re)load settings from the application configuration file or reset to default values.
            </summary>
        </member>
        <member name="M:ILNumerics.Settings.Ensure``1(System.String,``0)">
            <summary>
            Ensure the value for a specific (static) setting with robust rollback. This should be used in a 'using' directive. 
            </summary>
            <typeparam name="T">Type of the settings value.</typeparam>
            <param name="Name">The name of the setting to modify.</param>
            <param name="Value">The value for the setting.</param>
            <returns>Disposable object which resets the setting property to its original value when <see cref="M:System.IDisposable.Dispose"/> is called.</returns>
            <remarks>This method is useful when a temporary modification to a global setting is needed. It is applied as follows: 
            <list type="bullet">
            <item>Enclose the instructions where a certain value for one of the ILNumerics settings is needed into an 'using' block.</item>
            <item>In the head of the 'using' the <see cref="M:ILNumerics.Settings.Ensure``1(System.String,``0)"/> method is called with the name of the setting to control and the new value for it.</item>
            <item>During the execution of the instructions in the body of the 'using' block the setting <paramref name="Name"/> will have the value provided by <paramref name="Value"/>.</item>
            <item>Once the body of the 'using' block is left the value of the setting <paramref name="Name"/> will be reset to its original value automatically.</item>
            </list>
            <para>It is advisable to use the C# keyword 'nameof()' in order to provide the name of the setting.</para>
            </remarks>
            <example><![CDATA[ <code>using (Settings.Ensure(nameof(Settings.MaxNumberThreads), 1)) {
                //this part runs in single threaded mode
                //
                // ... 
            }
            //here we continue with Settings.MaxNumberThreads set to the original value, before we modified it. 
            </code>]]></example>
        </member>
        <member name="M:ILNumerics.Settings.Ensure``1(System.Linq.Expressions.Expression{System.Func{``0}},``0)">
            <summary>
            Ensure the value for a specific (static) setting with robust rollback. This should be used in a 'using' directive. 
            </summary>
            <typeparam name="T">Type of the settings value.</typeparam>
            <param name="p">Lambda expression _reading_ the target property.</param>
            <param name="v">The value to be ensured for settings.</param>
            <returns><see cref="T:System.IDisposable"/> which resets the setting property to its original value when <see cref="M:System.IDisposable.Dispose"/> is called.</returns>
            <remarks> Here is how this function is to be used: <list type="bullet">
            <item>Enclose the instructions where a certain value for one of the ILNumerics settings is needed into an 'using' block.</item>
            <item>In the head of the 'using' the <see cref="M:ILNumerics.Settings.Ensure``1(System.Linq.Expressions.Expression{System.Func{``0}},``0)"/> method is called with a 
            lambda function wrapping the setting to control and the new value for it.</item>
            <item>During the execution of the instructions in the body of the 'using' block the property 
            will have the value provided by <paramref name="v"/>.</item>
            <item>Once the body of the 'using' block is left the value of the <see cref="T:ILNumerics.Settings"/> property will be 
            reset to its original value automatically.</item>
            </list>
            </remarks>
            <example><![CDATA[ <code>using (Settings.Ensure(() => Settings.MaxNumberThreads, 1u)) {
                //this part runs in single threaded mode
                //
                // ... 
            }
            // here we continue with Settings.MaxNumberThreads set to the original value, before we had modified it. 
            </code>]]></example>
        </member>
        <member name="T:ILNumerics.SpecialData">
            <summary>
            A helper class that can be used to generate various simple but non-trivial test data sets.
            </summary>
        </member>
        <member name="P:ILNumerics.SpecialData.terrain">
            <summary>
            Get example terrain data, 401 x 401 short matrix with heights in meters
            </summary>
        </member>
        <member name="M:ILNumerics.SpecialData.sinc(System.Int32,System.Int32,System.Single)">
            <summary>
            Generate sinc function in 2D, useful for plotting examples
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <param name="periods">Influences the number of periods to be drawn in both directions. 1 will result in 4 zero crossings, higher values result in more, lower values in less zero crossings.</param>
            <returns>Matrix with sinc data in 2 dimensions</returns>
        </member>
        <member name="M:ILNumerics.SpecialData.sinc(System.Int32,System.Int32)">
            <summary>
            Generate sinc function in 2D, useful for plotting examples
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <returns>Matrix with sinc data in 2 dimensions</returns>
            <remarks>The function generates 4 zero crossings in each direction</remarks>
        </member>
        <member name="M:ILNumerics.SpecialData.sincf(System.Int32,System.Int32)">
            <summary>
            Generate sinc function in 2D, single precision, useful for plotting examples
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <returns>Matrix with sinc data in 2 dimensions</returns>
            <remarks>The function generates 4 zero crossings in each direction</remarks>
        </member>
        <member name="M:ILNumerics.SpecialData.sincf(System.Int32,System.Int32,System.Single)">
            <summary>
            Generate sinc function in 2D, useful for plotting examples
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <param name="periods">Influences the number of periods to be drawn in both directions. 1 will result in 4 zero crossings, higher values result in more, lower values in less zero crossings.</param>
            <returns>Matrix with sinc data in 2 dimensions</returns>
        </member>
        <member name="M:ILNumerics.SpecialData.sincos1D(System.Int32,System.Double)">
            <summary>
            Create specified periods of sine and cosine data
            </summary>
            <param name="numSamples">Number of samples</param>
            <param name="periods">Number of (full) periods to be generated, must be &gt; 0</param>
            <returns>Matrix with sine data in first column, cosine data in second column</returns>
        </member>
        <member name="M:ILNumerics.SpecialData.sincos1Df(System.Int32,System.Double)">
            <summary>
            Create specified periods of sine and cosine data, single precision
            </summary>
            <param name="numSamples">Number of samples</param>
            <param name="periods">Number of (full) periods to be generated, must be &gt; 0</param>
            <returns>Matrix with sine data in first column, cosine data in second column</returns>
        </member>
        <member name="M:ILNumerics.SpecialData.waterfall(System.Int32,System.Int32)">
            <summary>
            Create demo data for surface plots looking like a waterfall
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <returns>Matrix with data showing a waterfall terrain. </returns>
        </member>
        <member name="M:ILNumerics.SpecialData.waterfallf(System.Int32,System.Int32)">
            <summary>
            Create demo data for surface plots looking like a waterfall
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <returns>Matrix with data showing a waterfall terrain. </returns>
        </member>
        <member name="M:ILNumerics.SpecialData.sphere(System.Int32,ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})">
            <summary>
            Create surface data of a sphere
            </summary>
            <param name="n">Number of facettes per angle</param>
            <param name="X">[Output] X coords</param>
            <param name="Y">[Output] Y coords</param>
            <param name="Z">[Output] Z coords</param>
        </member>
        <member name="M:ILNumerics.SpecialData.moebius(System.Int32,System.Double,System.Double,ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})">
            <summary>
            Create surface data for a Mbius strip 
            </summary>
            <param name="n">Granularity (number of facettes)</param>
            <param name="w">Width</param>
            <param name="R">Radius</param>
            <param name="X">[Output] X coords</param>
            <param name="Y">[Output] Y coords</param>
            <param name="Z">[Output] Z coords</param>
            <remarks>Mbius strip is a surfcae, crated by cutting a regular strip, twisting one end by 180 deg and glueing 
            both ends together again.</remarks>
        </member>
        <member name="M:ILNumerics.SpecialData.torus(System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Create torus cartesian coordinates, to be used for surface plotting
            </summary>
            <param name="outerRadius">[optional] the outer radius of the torus ring, default: 0.75</param>
            <param name="innerRadius">[optional] the inner radius of the torus ring, default: 0.25</param>
            <param name="stepsPoloidal">[optional] number of grid points in poloidal direction, default: 100</param>
            <param name="stepsToroidal">[optional] number of grid points in toroidal direction, default: 100</param>
            <returns>Data array with cartesian coordinates of the torus gris points. </returns>
            <remarks></remarks>
        </member>
        <member name="T:ILNumerics.VisibilityAttribute">
            <summary>
            This attribute is used to control the public API visibility of ILNumerics functions.
            </summary>
        </member>
        <member name="T:ILNumerics.Size">
            <summary>
            Size - dimensions for array objects. This object is immutable.
            </summary>
            <remarks><para>The class manages /stores all dimensions information of ILNumerics arrays. </para>
            <para>Up from version 5.0 every storage holds a permanent instance of one single Size object. 
            Size objects get pooled with the array, reused with the array's storage and become modified 
            when the storage is reassigned a new data array to. </para>
            <para>Size uses the full Buffer Size Descriptor format as is used in the 
            Accelerator API. Since version 5.0 arrays in ILNumerics CE can have any 
            storage format! Elements can be storage in column major, row major or any other order which is 
            representable with <i>positive strides</i>. Commonly, array elements address a continous area 
            of elements stored in the host array.</para>
            <para>The base offset - the starting index in the host array of the first element - is stored 
            in the BSD long[2] element.</para></remarks>
        </member>
        <member name="F:ILNumerics.Size.s_maxBSDLength">
            <summary>
            Number of elements for a BSD utilizing the maximum number of dimensions supported: 17. 
            </summary>
        </member>
        <member name="F:ILNumerics.Size.CONT_FLAG">
            <summary>
            The value / bit No# 32 storing the property: continous storage layout in the <see cref="F:ILNumerics.Size.m_flags"/> variable. 
            </summary>
        </member>
        <member name="F:ILNumerics.Size.m_descriptor">
            <summary>
            Internal buffer size descriptor (BSD).
            </summary>
            <remarks>This size implementation relies on the format of Buffer Size Descriptors (BSD)
            of the ILNumerics Accelerator project. It wraps the BSD storage (an long[] array) for 
            the common, (mostly) row major storages of Array &amp; Co. This attribute represents the
            actual BSD storage array.</remarks>
        </member>
        <member name="F:ILNumerics.Size.m_flags">
            <summary>
            Flag indicating storage order, continuous storage property, ... ? of this storage. For lazy evaluation. 
            </summary>
        </member>
        <member name="F:ILNumerics.Size.MaxNumberOfDimensions">
            <summary>
            The maximum number of dimensions a size descriptor is able to handle. Currently, from version 5.2: 32. 
            </summary>
        </member>
        <member name="F:ILNumerics.Size.BSDLength">
            <summary>
            The maximum number of entries for a size descriptor. 
            </summary>
        </member>
        <member name="P:ILNumerics.Size.Flags">
            <summary>
            Gets the current value of the flags describing this size. This may or may not be up to-date! 
            </summary>
        </member>
        <member name="P:ILNumerics.Size.NumberOfDimensions">
            <summary>
            Gets the number of dimensions referenced by this size descriptor.
            </summary>
        </member>
        <member name="P:ILNumerics.Size.NumberOfElements">
            <summary>
            Gets the overall number of elements managed by this size descriptor. 
            </summary>
        </member>
        <member name="P:ILNumerics.Size.BaseOffset">
            <summary>
            Gets the element index of the first element addressed relative to the  
            beginning of the underlying buffer storage.
            </summary>
        </member>
        <member name="P:ILNumerics.Size.Longest">
            <summary>
            Length of the longest dimension.
            </summary>
        </member>
        <member name="P:ILNumerics.Size.NonSingletonDimensions">
            <summary>
            Number of non singleton dimensions of this size.
            </summary>
            <remarks><para>Non singleton dimensions are dimensions which length is larger than 1.</para> 
            <para>Since version 4.13 empty dimensions (length = 0) are also considered as being non-singleton dimensions.</para></remarks>
        </member>
        <member name="P:ILNumerics.Size.StorageOrder">
            <summary>
            The storage order this size descriptor represents. This is lazily evaluated once for any unchanged descriptor.
            </summary>
        </member>
        <member name="P:ILNumerics.Size.IsContinuous">
            <summary>
            Determines if elements stored according to this size descriptor are layed-out continously in memory.
            </summary>
            <value><c>True</c> if the elements are continously layed out in memory, <c>false</c> otherwise.</value>
            <remarks><para>Arrays with continously layed-out elements offer the potential of speedy copies and iteration. Many 
            functions in ILNumerics make use of this property.</para>
            <para>Typical cases of continous layout are <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> and <see cref="F:ILNumerics.StorageOrders.RowMajor"/>. 
            However, other storage schemes exist for higher dimensional arrays which do also store elements in memory 'without holes'.
            Therefore, <see cref="P:ILNumerics.Size.IsContinuous"/> will always be <see langword="true"/> on storages with a layout of 
            <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/></para>. But there is no guarantee that 
            the storage is stored in either one of these layouts (row / column major) when <see cref="P:ILNumerics.Size.IsContinuous"/> returns <see langword="true"/>. 
            </remarks>
        </member>
        <member name="M:ILNumerics.Size.ToString">
            <summary>
            Pretty print dimensions in the format "[a,b,c]".
            </summary>
            <returns>Dimensions as String.</returns>
        </member>
        <member name="M:ILNumerics.Size.ToIntArray">
            <summary>
            Gets the lengths of the dimensions of the array associated with this size object. 
            </summary>
            <returns>The length of dimensions as elements of a vector of length [NumberOfDimensions].</returns>
            <remarks>Note that numpy scalar arrays (0 dimensions, 1 element) return an empty vector of length 0.</remarks>
        </member>
        <member name="P:ILNumerics.Size.Item(System.Int64)">
            <summary>
            Get length of dimension at index <paramref name="idx"/>.
            </summary>
            <param name="idx">The index of the dimension to retrieve the length for.</param>
            <returns>Length of dimension specified by idx.</returns>
            <remarks><para>For <paramref name="idx"/> corresponding to an existing dimension 
            the length of that dimension is returned. If <paramref name="idx"/> is equal to or larger than 
            the number of dimensions 1 is returned.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Size.GetStride(System.UInt32)"/>
        </member>
        <member name="M:ILNumerics.Size.#ctor">
            <summary>
            Create a new, empty size descriptor.
            </summary>
        </member>
        <member name="M:ILNumerics.Size.RemoveDimension(System.UInt32)">
            <summary>
            Removes the specified dimension from this size descriptor. Does not change the number of elements / striding / base offset.
            </summary>
            <param name="dim">Index of the dimension to be removed.</param>
            <remarks><paramref name="dim"/> must point to an existing, _singleton_ dimension.
            <para>The current value of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> is respected.</para></remarks>
        </member>
        <member name="M:ILNumerics.Size.SetAll(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
            <summary>
            [EXPERT INTERFACE] This function is left for ILNumerics expert users. Don't use unless you really know what you are doing!
            </summary>
            <param name="size">New size</param>
            <param name="order">New order</param>
        </member>
        <member name="M:ILNumerics.Size.SetAll(ILNumerics.Size,System.Nullable{System.Int64})">
            <summary>
            This copies the full dimension specification from <paramref name="size"/>, incl. base offfset and stride to this size descriptor, overwriting the BSD of the local object instance. 
            </summary>
            <param name="size">Source dimension description (BSD).</param>
            <remarks><para>All BSD information are copied from the source <paramref name="size"/>, including the 
            number of dimensions, the lengths of the dimensions, the strides and the base offset.</para></remarks>
        </member>
        <member name="M:ILNumerics.Size.SetAll(ILNumerics.Size,System.Int64,ILNumerics.StorageOrders)">
            <summary>
            This copies the full dimension specification from <paramref name="size"/> to this size descriptor, overwriting the BSD of the local object instance. 
            </summary>
            <param name="size">Source dimension description (BSD).</param>
            <param name="baseOffset">New base offset for the resulting size descriptor.</param>
            <param name="storageOrder">The target storage order of this size descriptor. Allowed values: <see cref="F:ILNumerics.StorageOrders.RowMajor"/>, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</param>
            <remarks><para>All BSD information are copied from the source <paramref name="size"/>, including the 
            number of dimensions, the lengths of the dimensions. The strides and the base offset are 
            set according to <paramref name="baseOffset"/> and <paramref name="storageOrder"/>.</para></remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="storageOrder"/> is neither of <see cref="F:ILNumerics.StorageOrders.RowMajor"/> or <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>.</exception>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Sets all dimensions and strides of this size descriptor, continoues storage.
            </summary>
            <param name="dim0"></param>
            <param name="order"></param>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Sets all dimensions and strides of this size descriptor, continous storage.
            </summary>
            <param name="dim0"></param>
            <param name="dim1"></param>
            <param name="order"></param>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Sets all dimensions and strides of this size descriptor, continoues storage.
            </summary>
            <param name="dim0"></param>
            <param name="dim1"></param>
            <param name="dim2"></param>
            <param name="order"></param>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Sets all dimensions and strides of this size descriptor, continoues storage.
            </summary>
            <param name="dim0"></param>
            <param name="dim1"></param>
            <param name="dim2"></param>
            <param name="dim3"></param>
            <param name="order"></param>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Sets all dimensions and strides of this size descriptor, continoues storage.
            </summary>
            <param name="dim0"></param>
            <param name="dim1"></param>
            <param name="dim2"></param>
            <param name="dim3"></param>
            <param name="dim4"></param>
            <param name="order"></param>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Sets all dimensions and strides of this size descriptor, continoues storage.
            </summary>
            <param name="dim0"></param>
            <param name="dim1"></param>
            <param name="dim2"></param>
            <param name="dim3"></param>
            <param name="dim4"></param>
            <param name="dim5"></param>
            <param name="order"></param>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            Sets all dimensions and strides of this size descriptor, continoues storage.
            </summary>
            <param name="dim0"></param>
            <param name="dim1"></param>
            <param name="dim2"></param>
            <param name="dim3"></param>
            <param name="dim4"></param>
            <param name="dim5"></param>
            <param name="dim6"></param>
            <param name="order"></param>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.Int64*,System.UInt32)">
            <summary>
            Set all values of this size descriptor. 
            </summary>
            <param name="bsd"></param>
            <param name="flags"></param>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.Int64*,System.Int64,System.UInt32)">
            <summary>
            Set all values of this size descriptor. 
            </summary>
            <param name="bsd"></param>
            <param name="baseOffset">destination base offset</param>
            <param name="flags"></param>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.UInt32,System.UInt32)">
            <summary>
            Set dimensions and strides of this size descriptor explicitly, 1 dimension. 
            </summary>
            <param name="len0">Length of dim #0.</param>
            <param name="stride0">Stride of dim #0.</param>
            <remarks><para>This creates a vector array size descriptor with one dimension of length <paramref name="len0"/>.
            </para>
            <para>The actual size / number of dimensions is affected by the setting of the global configuration value <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. 
            By default this setting has a value of 2 (Matlab / Octave compatibility) which leads to the creation of 
            arrays with at least 2 dimensions (all arrays are matrices or higher-dimensional). In order to create truely 1-dimensional 
            arrays one must configure the <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> with a value of 1 or 0.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Set dimensions and strides of this size descriptor explicitly, 2 dimensions. 
            </summary>
            <param name="len0">BSD data #0 (length dim 0).</param>
            <param name="len1">BSD data #1.</param>
            <param name="stride0">BSD data #2.</param>
            <param name="stride1">BSD data #3.</param>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Set dimensions and strides of this size descriptor explicitly, 3 dimensions. 
            </summary>
            <param name="len0">BSD data #0 (length dim 0).</param>
            <param name="len1">BSD data #1.</param>
            <param name="len2">BSD data #2.</param>
            <param name="stride0">BSD data #3.</param>
            <param name="stride1">BSD data #4.</param>
            <param name="stride2">BSD data #5.</param>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Set dimensions and strides of this size descriptor explicitly, 4 dimensions. 
            </summary>
            <param name="len0">BSD data #0 (length dim 0).</param>
            <param name="len1">BSD data #1.</param>
            <param name="len2">BSD data #2.</param>
            <param name="len3">BSD data #3.</param>
            <param name="stride0">BSD data #4.</param>
            <param name="stride1">BSD data #5.</param>
            <param name="stride2">BSD data.</param>
            <param name="stride3">BSD data.</param>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Set dimensions and strides of this size descriptor explicitly, 5 dimensions. 
            </summary>
            <param name="len0">BSD data #0 (length dim 0).</param>
            <param name="len1">BSD data #1.</param>
            <param name="len2">BSD data #2.</param>
            <param name="len3">BSD data #3.</param>
            <param name="len4">BSD data.</param>
            <param name="stride0">BSD data.</param>
            <param name="stride1">BSD data.</param>
            <param name="stride2">BSD data.</param>
            <param name="stride3">BSD data.</param>
            <param name="stride4">BSD data.</param>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Set dimensions and strides of this size descriptor explicitly, 6 dimensions. 
            </summary>
            <param name="len0">BSD data #0 (length dim 0).</param>
            <param name="len1">BSD data #1.</param>
            <param name="len2">BSD data #2.</param>
            <param name="len3">BSD data #3.</param>
            <param name="len4">BSD data.</param>
            <param name="len5">BSD data.</param>
            <param name="stride0">BSD data.</param>
            <param name="stride1">BSD data.</param>
            <param name="stride2">BSD data.</param>
            <param name="stride3">BSD data.</param>
            <param name="stride4">BSD data.</param>
            <param name="stride5">BSD data.</param>
        </member>
        <member name="M:ILNumerics.Size.MergeNextToEnd(System.UInt32,System.Int64@)">
            <summary>
            Merges dimensions l to k of a continguous storage for iteration over all those dims with a single stride. 
            </summary>
            <param name="d"> starting / ending dimension.</param>
            <param name="stride">[output] receives the single stride for iteration over all specified dims.</param>
            <returns>The number of elements for iteration.</returns>
            <remarks><para>This function works on continous storages only. The behavior is different for both valid cases:</para>
            <para>ColumnMajor: l = d + 1, k = <see cref="P:ILNumerics.Size.NumberOfDimensions"/>-1. </para>
            <para>RowMajor: l = 0, k = d-1. </para>
            <para>Thus, column major storages merge the trailing dimension, above <paramref name="d"/>, while row 
            major storages merge the leading dimensions below <paramref name="d"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Size.IsSameSize(ILNumerics.IIndexIterator[],System.UInt32)">
            <summary>
            Determins whether this size descriptor has the exact same shape as the range addressed by <paramref name="iterators"/>.
            </summary>
            <param name="iterators">Predefined index iterators. </param>
            <param name="ndims">Number of index iterators provided in <paramref name="iterators"/>.</param>
            <returns>True if both, the range and this <see cref="T:ILNumerics.Size"/> have the same size.</returns>
        </member>
        <member name="M:ILNumerics.Size.SetAll(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Set dimensions and strides of this size descriptor explicitly, 7 dimensions. 
            </summary>
            <param name="len0">BSD data #0 (length dim 0).</param>
            <param name="len1">BSD data #1.</param>
            <param name="len2">BSD data #2.</param>
            <param name="len3">BSD data #3.</param>
            <param name="len4">BSD data.</param>
            <param name="len5">BSD data.</param>
            <param name="len6">BSD data.</param>
            <param name="stride0">BSD data.</param>
            <param name="stride1">BSD data.</param>
            <param name="stride2">BSD data.</param>
            <param name="stride3">BSD data.</param>
            <param name="stride4">BSD data.</param>
            <param name="stride5">BSD data.</param>
            <param name="stride6">BSD data.</param>
        </member>
        <member name="M:ILNumerics.Size.SetDimensionLengths(ILNumerics.Size)">
            <summary>
            This copies the dimension number and lengths from <paramref name="size"/> to this size descriptor, 
            overwriting the BSD of the local object instance and creating a column-major storage ordered 
            size descriptor with 0 base offset. 
            </summary>
            <param name="size">Source dimension description (BSD).</param>
            <remarks><para>The resulting dimension specification will have strides 
            according to a column major storage layout.</para></remarks>
        </member>
        <member name="M:ILNumerics.Size.SetDimensionLengths(System.Int64*,ILNumerics.StorageOrders)">
            <summary>
            Copies the dimension lengths from the BSD and completes stride info according to <paramref name="order"/>.
            </summary>
            <param name="bsd">(potentially incomplete) other BSD.</param>
            <param name="order">Array style, determins the strides for this size.</param>
            <remarks><paramref name="bsd"/> is expected to have ndims (bsd[0]), nelem (bsd[1]) and dims (bsd[2 + [1 ... ndims]]) configured. 
            this function takes all this info and completes base offset (0) and strides to completely configure this size.</remarks>
        </member>
        <member name="M:ILNumerics.Size.GetHashCode">
            <summary>
            Gets a hash code representing this size descriptors current content. 
            </summary>
            <returns>Hash code.</returns>
        </member>
        <member name="M:ILNumerics.Size.IsSameSize(ILNumerics.Size)">
            <summary>
            Compares this size to another size, ignoring leading and trailing singleton dimensions. 
            </summary>
            <param name="dim2">size descriptor to compare this to.</param>
            <returns>Returns true if the sizes are the same, else returns false. 
            The comparison is made by ignoring singleton dimensions. Therefore 
            only non singleton dimensions are compared in the order of their 
            appearance. </returns>
            <remarks>The function returns true, if the <i>squeezed</i> dimensions of 
            both size descriptors match. The sizes of empty arrays are not required to match 
            exactly in order to be considered equal.</remarks>
            <seealso cref="M:ILNumerics.Size.IsSameShape(ILNumerics.Size)"/>
        </member>
        <member name="M:ILNumerics.Size.IsSameShape(ILNumerics.Size)">
            <summary>
            Compares the exact shape of this size to another size. Considering all dimensions.
            </summary>
            <param name="dim2">size descriptor to compare this to.</param>
            <returns>Returns true if the shapes are the same, else returns false. </returns>
            <remarks>This function is more strict than <see cref="M:ILNumerics.Size.IsSameSize(ILNumerics.Size)"/>. In order 
            for two size descriptors to have the same shape, ALL dimensions must match - 
            including singleton dimensions.</remarks>
            <seealso cref="M:ILNumerics.Size.IsSameSize(ILNumerics.Size)"/>
        </member>
        <member name="M:ILNumerics.Size.IsSameShape(ILNumerics.InArray{System.Int64})">
            <summary>
            Compares the exact shape of this size to another size. Considering all dimensions.
            </summary>
            <param name="dim2">Array with dimension lengths to compare this <see cref="T:ILNumerics.Size"/> to.</param>
            <returns>Returns true if the shapes are the same, else returns false. </returns>
            <remarks>This function is more strict than <see cref="M:ILNumerics.Size.IsSameSize(ILNumerics.Size)"/>. In order 
            for two size descriptors to have the same shape, ALL dimensions must match - 
            including singleton dimensions and number of dimensions.</remarks>
            <seealso cref="M:ILNumerics.Size.IsSameSize(ILNumerics.Size)"/>
        </member>
        <member name="M:ILNumerics.Size.IsSame(System.Int64*,System.Int64*)">
            <summary>
            Compares the exact shape of this size to another size. Considering all dimensions.
            </summary>
            <param name="shape">Pointer to memory with dimension lengths to compare this to. Must be at least of length <see cref="P:ILNumerics.Size.NumberOfDimensions"/>.</param>
            <param name="strides">Pointer to memory with strides to compare this to. Must be at least of length <see cref="P:ILNumerics.Size.NumberOfDimensions"/>.</param>
            <returns>Returns true if the shapes and the strides are the same, else returns false. </returns>
            <remarks>This function is more strict than <see cref="M:ILNumerics.Size.IsSameSize(ILNumerics.Size)"/>. In order 
            for two size descriptors to be the same ALL dimensions and strides must match - 
            including number and position of singleton dimensions.</remarks>
            <seealso cref="M:ILNumerics.Size.IsSameSize(ILNumerics.Size)"/>
        </member>
        <member name="M:ILNumerics.Size.IsSame(System.Int32*,System.Int32*)">
            <summary>
            Compares the exact shape of this size to another size. Considering all dimensions.
            </summary>
            <param name="shape">Pointer to memory with dimension lengths to compare this to. Must be at least of length <see cref="P:ILNumerics.Size.NumberOfDimensions"/>.</param>
            <param name="strides">Pointer to memory with strides to compare this to. Must be at least of length <see cref="P:ILNumerics.Size.NumberOfDimensions"/>.</param>
            <returns>Returns true if the shapes and the strides are the same, else returns false. </returns>
            <remarks>This function is more strict than <see cref="M:ILNumerics.Size.IsSameSize(ILNumerics.Size)"/>. In order 
            for two size descriptors to be the same ALL dimensions and strides must match - 
            including number and position of singleton dimensions.</remarks>
            <seealso cref="M:ILNumerics.Size.IsSameSize(ILNumerics.Size)"/>
        </member>
        <member name="M:ILNumerics.Size.GetStrides(System.Int64*,System.UInt32)">
            <summary>
            Copy the strides of this size descriptor into the array of length <paramref name="len"/> pointed to by <paramref name="seqd"/>.
            </summary>
            <param name="seqd">Preallocated array of length <paramref name="len"/>. All elements will be filled with 
            the strides of the corresponding dimension.</param>
            <param name="len">Length of array <paramref name="seqd"/>.</param>
            <remarks>If <paramref name="len"/> is larger than <see cref="P:ILNumerics.Size.NumberOfDimensions"/> trailing elements will 
            be filled with the value of <see cref="P:ILNumerics.Size.NumberOfElements"/> to maintain consistency..</remarks>
        </member>
        <member name="M:ILNumerics.Size.GetBSD(System.Boolean)">
            <summary>
            [EXPERT INTERFACE!] Gets a reference to the internal BSD array describing the sizes / strides of this size object. Use with care!
            </summary>
            <param name="write">[Optional] Flag indicating the intended use of the BSD array returned. 
            True: callee will alter the array. False: the array returned will <b>not</b> be altered (default).</param>
            <returns>Reference to the internal BSD array.</returns>
        </member>
        <member name="M:ILNumerics.Size.GetBSD(System.UInt32)">
            <summary>
            Gets a <i>copy</i> of the BSD array of this size descriptor with arbitrary number of dimensions. 
            </summary>
            <param name="ndims">Number of dimensions for the new BSD.</param>
            <returns>BSD addressing the same number of elements as this size, with arbitrary number of dimensions.</returns>
            <remarks><para>If <paramref name="ndims"/> is not equal to <see cref="P:ILNumerics.Size.NumberOfDimensions"/> trailing 
            singleton dimensions are added or missing dimensions at the end are merged to the last 
            dimension respectively.</para>
            <para>The merging of subsequent, unspecified dimensions is only possible if the storage 
            layout of this size is suitable. Column major order storage is suitable for merging. If this 
            size is non-column major merging is not possible and an exception will be generated.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException"> if the number of dimensions is larger than <paramref name="ndims"/>
            but the storage layout of this size does not allow to merge subsequent dimensions into the last dimension requested. 
            In this case the array should be consolidated before attempting such operation.</exception>
        </member>
        <member name="M:ILNumerics.Size.WorkingDimension">
            <summary>
            Find working dimension to work on. Array style dependent. 
            </summary>
            <returns>Index of the last (numpy array style) or the first (ILNumericsV4 array style) non singleton dimension or 0.</returns>
        </member>
        <member name="M:ILNumerics.Size.GetShifted(System.Int32,System.Int64*)">
            <summary>
            Create a new BSD with a rotated version of the dimensions of this size descriptor.
            </summary>
            <param name="shift">Number of dimensions to shift (rotate) this size's dimensions. 
            Rotation is done to the left.</param>
            <param name="outBSD">[Output] Reference to a bsd array used to store the shifted version of this BSD. <paramref name="outBSD"/> may point to the same instance as the BSD stored within this <see cref="T:ILNumerics.Size"/>, in which case this size will be altered!.</param>
            <returns>Buffer Size Descriptor with rotated dimension order and the same dimension 
            lengths as this size's descriptor.</returns>
            <remarks>The functions returns a BSD using the provided <paramref name="outBSD"/> array, 
            having the same dimensions than this size descriptor. The order of dimensions of the returned BSD 
            is rotated to the left by <paramref name="shift"/>. 
            <para>This function is prepared to work on arbitrarily strided size descriptors and on the _same instance_ (inplace) hold by this size, <see cref="M:ILNumerics.Size.GetBSD(System.Boolean)"/>.</para>
            <para>The provided array <paramref name="outBSD"/> must be of the same length than the 
            size descriptor stored in this <see cref="T:ILNumerics.Size"/>.</para>
            <para><see cref="M:ILNumerics.Size.GetShifted(System.Int32,System.Int64*)"/> does nothing on scalars and 1-dimensional vectors (NOP).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Size.GetPermuted(System.Int64*,System.UInt32*,System.UInt32)">
            <summary>
            Permutes the dimension of an existing BSD.
            </summary>
            <param name="outBSD">Predefined BSD.</param>
            <param name="order">Array with new dimension indices order. Each index must be contained exactly once.</param>
            <param name="orderLen">Number of entries in <paramref name="order"/>. This must be equal to <see cref="P:ILNumerics.Size.NumberOfDimensions"/>.</param>
            <exception cref="T:System.ArgumentException"> if <paramref name="orderLen"/> is not the same as <see cref="P:ILNumerics.Size.NumberOfDimensions"/>, 
            if any existing dimension index of this <see cref="T:ILNumerics.Size"/> is missing or multiple times defined in <paramref name="order"/>, 
            or if any provided pointer is NULL or if <paramref name="outBSD"/> points to the same memory as this Size' BSD.</exception>
        </member>
        <member name="M:ILNumerics.Size.SwapDimensions">
            <summary>
            Swaps (reverses) the dimensions of this size descriptor inplace. Must be internal to retain API immutability.
            </summary>
        </member>
        <member name="M:ILNumerics.Size.GetElementSpan">
            <summary>
            Gets the element index of the last element addressed by this size descriptor. 
            </summary>
            <returns>Element span.</returns>
            <remarks><para>The value computed indicates the size of memory region required to store all elements of 
            an array according to this size descriptor. Basically, the value indicates the element position where the 
            last (highest address) element is stored in the 1-dimensional array / memory region. Since no negative 
            indices are allowed, the 'last' element is the one with index tupels corresponding to the value of "dimension length - 1"
            for each dimension. The value returned will simply be the sum of such tuple items.</para>
            <para>This value is useful to 1) provide sufficiently large <see cref="T:System.Array"/> for exporting and copying 
            of elements in arbitray storage layouts, and 2) to determine whether a certain storage layout stores the elements 
            continously in memory (for cache performant iteration).</para>
            <para>The storage layout is continous, if and only if the value returned is equal to <see cref="P:ILNumerics.Size.NumberOfElements"/> minus 1.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Size.IsBroadcastableTo(System.Int64*)">
            <summary>
            Unidirectional broadcasting check. 
            </summary>
            <param name="bsd"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Size.CheckIsBroadcastableTo_np(System.Int64*,System.UInt32)">
            <summary>
            Checks if this array shape is broadcastable to the other array shape, aligning the last dimensions (numpy style). 
            </summary>
            <param name="theirDims"></param>
            <param name="ndims"></param>
            <exception cref="T:System.ArgumentException">if this size is not broadcastable to the given size.</exception>
        </member>
        <member name="M:ILNumerics.Size.IsBroadcastableTo(ILNumerics.IIndexIterator[],System.UInt32)">
            <summary>
            Determines if this size if broadcastable to the range specified by <paramref name="iterators"/>. Not the other way around!
            </summary>
            <param name="iterators"></param>
            <param name="nIterDims"></param>
            <returns></returns>
            <remarks>This is used by SetRangeML.</remarks>
        </member>
        <member name="M:ILNumerics.Size.GetElementSpan(System.Int64*)">
            <summary>
            Gets the element index of the last element addressed by a size descriptor. 
            </summary>
            <returns>Element span.</returns>
            <remarks><para>The value computed indicates the size of memory region required to store all elements of 
            an array according to the size descriptor <paramref name="bsd"/>. Basically, the value indicates the element position where the 
            last (highest address) element is stored in the 1-dimensional array / memory region. Since no negative 
            indices are allowed, the 'last' element is the one with index tupels corresponding to the value of "dimension length - 1"
            for each dimension. The value returned will simply be the sum of such tuple items factored with the corresponding strides.</para>
            <para>This value is useful to 1) provide sufficiently large <see cref="T:System.Array"/> for exporting and copying 
            of elements in arbitray storage layouts, and 2) to determine whether a certain storage layout stores the elements 
            continously in memory (for cache performant iteration).</para>
            <para>The storage layout is continous, if and only if the value returned is equal to <see cref="P:ILNumerics.Size.NumberOfElements"/> minus 1.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.Int32[])">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor 
            based on the provided index array <paramref name="d"/>. 
            </summary>
            <param name="d">System.Array with indices into the dimensions of this array.</param>
            <returns>Sequential index into the array when stored as 1D array of storage order according to this size descriptor.</returns>
            <remarks>
            <para>If the array addressed by this size has less dimensions than addressed by <paramref name="d"/>, trailing 
            indices (i.e.: such indices dealing with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' or singleton dimensions. Those indices must address the 0-th element of the 
            virtual dimension. Hence its value must be 0.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by <paramref name="d"/>
            the value of the last index from <paramref name="d"/> may exceed the length of the corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and folding 
            the superflous modulus of the value of 'd[{last}]' to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of 'd[{last}]' 
            reaches 0.</para>
            <para>This function recognizes arbitrarily strided size objects.</para>
            <para>This function was marked deprecated in version 5. Calls to this function forward to the new uint indexing function <see cref="M:ILNumerics.Size.GetSeqIndex(System.UInt32[])"/>. 
            Consider using the 'uint[]' overload directly in order to make your code more stable and faster!</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if any of the indices in <paramref name="d"/> (except the 
            last index stored, see above) is equal or greater than the length of its corresponding dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> the resulting index points to a non-existing element.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> if any of the indices in <paramref name="d"/> are negative.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetStride(System.UInt32)">
            <summary>
            Get the spacing between elements in the dimension <paramref name="dim"/>.
            </summary>
            <param name="dim">0 based index of the dimension.</param>
            <returns>The stride for the dimension addressed by <paramref name="dim"/>.</returns>
            <remarks><para>Strides in ILNumerics arrays are always positive.</para>
            <para>For <paramref name="dim"/> larger or equal to <see cref="P:ILNumerics.Size.NumberOfDimensions"/> the 
            function returns <see cref="P:ILNumerics.Size.NumberOfElements"/> which is the correct value for <i>column-major storage</i>. 
            For non-column major storages the strides of dimensions outside the range of the 
            number of dimensions of this size descriptor are not defined.</para>
            </remarks>
            <seealso cref="P:ILNumerics.Size.NumberOfDimensions"/>
            <seealso cref="T:ILNumerics.StorageOrders"/>
            <seealso cref="P:ILNumerics.Size.StorageOrder"/>
        </member>
        <member name="M:ILNumerics.Size.GetStride4MLlastDimExpansion(System.UInt32)">
            <summary>
            Gives strides of next non-singleton dimension. Optimized for ML, column-maj. subarray operations.
            </summary>
            <param name="dim"></param>
            <returns>next stored non-singular stride or 0. </returns>
            <remarks></remarks>
        </member>
        <member name="M:ILNumerics.Size.op_Inequality(ILNumerics.Size,ILNumerics.Size)">
            <summary>
            'Not equal' operator on two instances of <see cref="T:ILNumerics.Size"/>
            </summary>
            <param name="s1">The first size object.</param>
            <param name="s2">The second size object.</param>
            <returns>True, if both instances do not have the same <b>shape</b>.</returns>
            <remarks>The operator is an alias for <code>!s1.Equals(s2)</code>
            <para>If either one of <paramref name="s1"/> or <paramref name="s2"/> is null, the operator returns false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Size.op_Equality(ILNumerics.Size,ILNumerics.Size)">
            <summary>
            'Equal' operator on two instances of <see cref="T:ILNumerics.Size"/>
            </summary>
            <param name="s1">The first size object.</param>
            <param name="s2">The second size object.</param>
            <returns>True, if both instances have the same <b>shape</b>.</returns>
            <remarks>The operator is an alias for <code>s1.Equals(s2)</code>.
            <para>If either one of <paramref name="s1"/> or <paramref name="s2"/> is null, the operator returns false.</para></remarks>
        </member>
        <member name="M:ILNumerics.Size.op_Inequality(ILNumerics.Size,ILNumerics.InArray{System.Int64})">
            <summary>
            'Not equal' operator, compares this size with a shape vector.
            </summary>
            <param name="s1">The first size object.</param>
            <param name="s2">The shape vector.</param>
            <returns>True, if both sizes do not have the same <b>shape</b>.</returns>
            <remarks>The operator is an alias for <code>!s1.IsSameShape(s2)</code>
            <para>If either one of <paramref name="s1"/> or <paramref name="s2"/> is null, the operator returns false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Size.op_Equality(ILNumerics.Size,ILNumerics.InArray{System.Int64})">
            <summary>
            'Equal' operator, compares this size with a shape vector.
            </summary>
            <param name="s1">The size object.</param>
            <param name="s2">The shape vector.</param>
            <returns>True, if both sizes have the same <b>shape</b>.</returns>
            <remarks>The operator is an alias for <code>s1.IsSameShape(s2)</code>.
            <para>If either one of <paramref name="s1"/> or <paramref name="s2"/> is null, the operator returns false.</para></remarks>
        </member>
        <member name="M:ILNumerics.Size.Equals(System.Object)">
            <summary>
            Exact equal, compares number, lengths and strides of all dimensions, base offset. 
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Size.CheckFlags(System.Int64*,System.UInt32@)">
            <summary>
            Tests the BSD for column-/ row-major addressing storage format and continous storage.
            </summary>
            <param name="bsd">The size descriptor.</param>
            <param name="flags">Integer used to store the storage format and continous property in a bit pattern.</param>
        </member>
        <member name="M:ILNumerics.Size.lrot(System.Int64*,System.Int32,System.Int32,System.Int32)">
            <summary>
            Left rotate array inplace. O(N) computational effort. O(1) memory required. 
            </summary>
            <param name="arr">The array</param>
            <param name="offs">The index of the starting element.</param>
            <param name="n">The number of consequtive elements to rotate, starting with <paramref name="offs"/>.</param>
            <param name="d">Rotation distance.</param>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.Int64)">
            <summary>
            Retrieves the storage element index into an array stored according to this size descriptor object
            based on the provided sequential index <paramref name="d0"/>. Allows negative indices. 
            </summary>
            <param name="d0">Index into the first dimension / sequential index.</param>
            <returns>Storage element index addressing the element in memory.</returns>
            <remarks><para>For arrays of column vector shape <paramref name="d0"/> references the index of the row of the 
            storage element to return.</para>
            <para>More general, for <see cref="P:ILNumerics.Size.NumberOfDimensions">n-dimensional</see> arrays the first index corresponds 
            to the position in the first (index 0) dimension.</para>
            <para>If the array refered to by this size stores more dimensions than addressable by this function
            <paramref name="d0"/> can exceed the limits of the first dimension. In this 
            case the storage element index to be returned is computed by subsequently merging trailing dimensions and applying 
            the superflous modulos of the value of <paramref name="d0"/> to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the superflous indices reach the value of 0.</para>
            <para><paramref name="d0"/> may be negative, in which case the resulting index is computed by adding the 
            number of elements in the array to the parameters value. Hence, a value of -1 addresses the last element in the array.</para>
            <para>This function recognizes arbitrary strides. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.Int64.MaxValue"/>. Consider using one of the overloads with 
            <see cref="T:System.UInt32"/> parameters if you are not dealing with very big arrays and don't require negative indexing.
            This may bring better performance in tight loops.</para>
            <para>Performance hint: this function (and all corresponding overloads) are optimized for the case
            where the number of index parameters provided corresponds to the number of dimensions in the array and all 
            provided index parameters are within the range of their corresponding dimension. The functions, however, handle 
            arbitrary cases, including addressing, merging and ommitting trailing dimensions. Any of those extended features
            may introduce a performance penalty, though.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the leading dimension specifier <paramref name="d0"/> is equal to
            or greater than the <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.Int64,System.Int64)">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object 
            based on the provided indices <paramref name="d0"/> ... <paramref name="d1"/>.  Allows negative indices. 
            </summary>
            <param name="d0">Index into the first dimension.</param>
            <param name="d1">Index into the second dimension.</param>
            <returns>Storage element index addressing the element in memory.</returns>
            <remarks><para>For arrays of matrix shape <paramref name="d0"/> references the index of the row and 
            <paramref name="d1"/> references the index of the column of the sequential index to return.</para>
            <para>More general, for <see cref="P:ILNumerics.Size.NumberOfDimensions">n-dimensional</see> arrays the first index corresponds 
            to the position in the first (index: 0) dimension and the second index to the position of the element in the 
            second dimension (index: 1).</para>
            <para>If the array refered to by this size stores more dimensions than addressed by this function
            the last index parameter <paramref name="d1"/> can exceed the limits of its corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and applying 
            the superflous modulos of the value of <paramref name="d1"/> to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of <paramref name="d1"/> 
            reaches 0.</para>
            <para>Any index parameter may be negative, in which case the resulting index is computed by adding the 
            corresponding dimension length to the parameters value. Hence, a value of -1 addresses the last element in the dimension. 
            Note, that for the last specified dimension a value of -1 references the last element in the _virtual_ dimension,
            merged with any non specified trailing dimensions.</para>
            <para>This function recognizes arbitrary strides. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.Int64.MaxValue"/>. Consider using one of the overloads with 
            <see cref="T:System.UInt32"/> parameters if you are not dealing with very big arrays and don't require negative indexing.
            This may bring better performance in tight loops.</para>
            <para>Performance hint: this function (and all corresponding overloads) are optimized for the case
            where the number of index parameters provided corresponds to the number of dimensions in the array and all 
            provided index parameters are within the range of their corresponding dimension. The functions, however, handle 
            arbitrary cases, including addressing, merging and ommitting trailing dimensions. Any of those extended features
            may introduce a performance penalty, though.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the leading dimension specifier <paramref name="d0"/> is equal to
            or greater than the length of the first dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="d1"/> is equal or greater than the length of 
            the second dimension and the resulting index points to a non-existing element.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object based 
            on the provided indices <paramref name="d0"/> ... <paramref name="d2"/>. Allows negative indices. 
            </summary>
            <param name="d0">Index into the first dimension.</param>
            <param name="d1">Index into the second dimension.</param>
            <param name="d2">Index into the third dimension.</param>
            <returns>Sequential index into the array when stored as 1D array of arbitrary storage order.</returns>
            <remarks><para>For arrays of matrix shape <paramref name="d0"/> references the index of the row and 
            <paramref name="d1"/> references the index of the column of the sequential index to return.</para>
            <para>More general, for <see cref="P:ILNumerics.Size.NumberOfDimensions">n-dimensional</see> arrays the first index corresponds 
            to the position in the first (index: 0) dimension, the second index to the position of the element in the 
            second dimension (index: 1), a.s.o.</para>
            <para>If the array addressed by this size has less dimensions than addressed by this function, trailing indices 
            (i.e.: such indices which deal with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' or singleton dimensions. Those indices must address the 0-th element of the 
            virtual dimension. Hence its value must be 0.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by this function
            the last index parameter <paramref name="d2"/> may exceeds the limit of its corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and applying 
            the superflous modulus of the value of <paramref name="d2"/> to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of <paramref name="d2"/> 
            reaches 0.</para>
            <para>Any index parameter may be negative, in which case the resulting index is computed by adding the 
            corresponding dimension length to the parameters value. Hence, a value of -1 addresses the last element in the dimension. 
            Note, that for the last specified dimension a value of -1 references the last element in the _virtual_ dimension,
            merged with any non specified trailing dimensions.</para>
            <para>This function recognizes arbitrarily strided size objects. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.Int64.MaxValue"/>. Consider using one of the overloads with 
            <see cref="T:System.UInt32"/> parameters if you are not dealing with very big arrays and don't require negative indexing.
            This may bring better performance in tight loops.</para>
            <para>Performance hint: this function (and all corresponding overloads) are optimized for the case
            where the number of index parameters provided corresponds to the number of dimensions in the array and all 
            provided index parameters are within the range of their corresponding dimension. The functions, however, handle 
            arbitrary cases, including addressing, merging and ommitting trailing dimensions. Any of those extended features
            may introduce a performance penalty, though.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the leading dimension specifier <paramref name="d0"/> is equal 
            or greater than the length of the first dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> if the leading dimension specifier <paramref name="d1"/> is equal 
            or greater than the length of the second dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="d2"/> is equal or greater than the length of the 
            third dimension and the resulting index points to an non-existing element.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object 
            based on the provided indices <paramref name="d0"/> ... <paramref name="d3"/>. Allows negative indices.  
            </summary>
            <param name="d0">Index into the first dimension.</param>
            <param name="d1">Index into the second dimension.</param>
            <param name="d2">Index into the third dimension.</param>
            <param name="d3">Index into the fourth dimension.</param>
            <returns>Sequential index into the array when stored as 1D array of arbitrary storage order.</returns>
            <remarks><para>For arrays of matrix shape <paramref name="d0"/> references the index of the row and 
            <paramref name="d1"/> references the index of the column of the sequential index to return.</para>
            <para>More general, for <see cref="P:ILNumerics.Size.NumberOfDimensions">n-dimensional</see> arrays the first index corresponds 
            to the position in the first (index: 0) dimension, the second index to the position of the element in the 
            second dimension (index: 1) and so forth ...</para>
            <para>If the array addressed by this size has less dimensions than addressed by this function, trailing indices 
            (i.e.: such indices which deal with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' or singleton dimensions. Those indices must address the 0-th element of the 
            virtual dimension. Hence its value must be 0.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by this function
            the last index parameter <paramref name="d3"/> may exceeds the limit of its corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and applying 
            the superflous modulus of the value of <paramref name="d3"/> to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of <paramref name="d3"/> 
            reaches 0.</para>
            <para>Any index parameter may be negative, in which case the resulting index is computed by adding the 
            corresponding dimension length to the parameters value. Hence, a value of -1 addresses the last element in the dimension. 
            Note, that for the last specified dimension a value of -1 references the last element in the _virtual_ dimension,
            merged with any non specified trailing dimensions.</para>
            <para>This function recognizes arbitrarily strided size objects. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.Int64.MaxValue"/>. Consider using one of the overloads with 
            <see cref="T:System.UInt32"/> parameters if you are not dealing with very big arrays and don't require negative indexing.
            This may bring better performance in tight loops.</para>
            <para>Performance hint: this function (and all corresponding overloads) are optimized for the case
            where the number of index parameters provided corresponds to the number of dimensions in the array and all 
            provided index parameters are within the range of their corresponding dimension. The functions, however, handle 
            arbitrary cases, including addressing, merging and ommitting trailing dimensions. Any of those extended features
            may introduce a performance penalty, though.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if any of the leading dimension specifiers <paramref name="d0"/> ... 
            <paramref name="d2"/> is equal or greater than the length of its corresponding dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="d3"/> is equal or greater than the length 
            of the fourth dimension and the resulting index after merging trailing dimensions points to a non-existing element.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object 
            based on the provided indices <paramref name="d0"/> ... <paramref name="d4"/>. Allows negative indices.  
            </summary>
            <param name="d0">Index into the first dimension.</param>
            <param name="d1">Index into the second dimension.</param>
            <param name="d2">Index into the third dimension.</param>
            <param name="d3">Index into the fourth dimension.</param>
            <param name="d4">Index into the fives dimension.</param>
            <returns>Sequential index into the array when stored as 1D array of arbitrary storage order.</returns>
            <remarks><para>For arrays of matrix shape <paramref name="d0"/> references the index of the row and 
            <paramref name="d1"/> references the index of the column of the sequential index to return.</para>
            <para>More general, for <see cref="P:ILNumerics.Size.NumberOfDimensions">n-dimensional</see> arrays the first index corresponds 
            to the position in the first (index: 0) dimension, the second index to the position of the element in the 
            second dimension (index: 1) and so forth ...</para>
            <para>If the array addressed by this size has less dimensions than addressed by this function, trailing indices 
            (i.e.: such indices which deal with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' or singleton dimensions. Those indices must address the 0-th element of the 
            virtual dimension. Hence its value must be 0.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by this function
            the last index parameter <paramref name="d4"/> may exceeds the limit of its corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and applying 
            the superflous modulus of the value of <paramref name="d4"/> to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of <paramref name="d4"/> 
            reaches 0.</para>
            <para>Any index parameter may be negative, in which case the resulting index is computed by adding the 
            corresponding dimension length to the parameters value. Hence, a value of -1 addresses the last element in the dimension. 
            Note, that for the last specified dimension a value of -1 references the last element in the _virtual_ dimension,
            merged with any non specified trailing dimensions.</para>
            <para>This function recognizes arbitrarily strided size objects. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.Int64.MaxValue"/>. Consider using one of the overloads with 
            <see cref="T:System.UInt32"/> parameters if you are not dealing with very big arrays and don't require negative indexing.
            This may bring better performance in tight loops.</para>
            <para>Performance hint: this function (and all corresponding overloads) are optimized for the case
            where the number of index parameters provided corresponds to the number of dimensions in the array and all 
            provided index parameters are within the range of their corresponding dimension. The functions, however, handle 
            arbitrary cases, including addressing, merging and ommitting trailing dimensions. Any of those extended features
            may introduce a performance penalty, though.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if any of the leading dimension specifiers <paramref name="d0"/> ... 
            <paramref name="d3"/> is equal or greater than the length of its corresponding dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="d4"/> is equal or greater than the length 
            of the fives dimension and the resulting index after merging trailing dimensions points to a non-existing element.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object 
            based on the provided indices <paramref name="d0"/> ... <paramref name="d5"/>. Allows negative indices.  
            </summary>
            <param name="d0">Index into the first dimension.</param>
            <param name="d1">Index into the second dimension.</param>
            <param name="d2">Index into the third dimension.</param>
            <param name="d3">Index into the fourth dimension.</param>
            <param name="d4">Index into the fives dimension.</param>
            <param name="d5">Index into the sixth dimension.</param>
            <returns>Sequential index into the array when stored as 1D array of arbitrary storage order.</returns>
            <remarks><para>For arrays of matrix shape <paramref name="d0"/> references the index of the row and 
            <paramref name="d1"/> references the index of the column of the sequential index to return.</para>
            <para>More general, for <see cref="P:ILNumerics.Size.NumberOfDimensions">n-dimensional</see> arrays the first index corresponds 
            to the position in the first (index: 0) dimension, the second index to the position of the element in the 
            second dimension (index: 1) and so forth ...</para>
            <para>If the array addressed by this size has less dimensions than addressed by this function, trailing indices 
            (i.e.: such indices which deal with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' or singleton dimensions. Those indices must address the 0-th element of the 
            virtual dimension. Hence its value must be 0.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by this function
            the last index parameter <paramref name="d5"/> may exceeds the limit of its corresponding dimension. In this 
            case the sequential index returned is computed by subsequently merging trailing dimensions and folding 
            the superflous modulus of the value of <paramref name="d5"/> to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of <paramref name="d5"/> 
            reaches 0.</para>
            <para>Any index parameter may be negative, in which case the resulting index is computed by adding the 
            corresponding dimension length to the parameters value. Hence, a value of -1 addresses the last element in the dimension. 
            Note, that for the last specified dimension a value of -1 references the last element in the _virtual_ dimension,
            merged with any non specified trailing dimensions.</para>
            <para>This function recognizes arbitrarily strided size objects. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.Int64.MaxValue"/>. Consider using one of the overloads with 
            <see cref="T:System.UInt32"/> parameters if you are not dealing with very big arrays and don't require negative indexing.
            This may bring better performance in tight loops.</para>
            <para>Performance hint: this function (and all corresponding overloads) are optimized for the case
            where the number of index parameters provided corresponds to the number of dimensions in the array and all 
            provided index parameters are within the range of their corresponding dimension. The functions, however, handle 
            arbitrary cases, including addressing, merging and ommitting trailing dimensions. Any of those extended features
            may introduce a performance penalty, though.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if any of the leading dimension specifiers <paramref name="d0"/> ... 
            <paramref name="d4"/> is equal or greater than the length of its corresponding dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="d5"/> is equal or greater than the length 
            of the last dimension and the resulting index after merging trailing dimensions points to a non-existing element.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object 
            based on the provided indices <paramref name="d0"/> ... <paramref name="d6"/>. Allows negative indices.  
            </summary>
            <param name="d0">Index into the first dimension.</param>
            <param name="d1">Index into the second dimension.</param>
            <param name="d2">Index into the third dimension.</param>
            <param name="d3">Index into the fourth dimension.</param>
            <param name="d4">Index into the fives dimension.</param>
            <param name="d5">Index into the sixth dimension.</param>
            <param name="d6">Index into the seventh dimension.</param>
            <returns>Sequential index into the array when stored as 1D array of arbitrary storage order.</returns>
            <remarks><para>For arrays of matrix shape <paramref name="d0"/> references the index of the row and 
            <paramref name="d1"/> references the index of the column of the sequential index to return.</para>
            <para>More general, for <see cref="P:ILNumerics.Size.NumberOfDimensions">n-dimensional</see> arrays the first index corresponds 
            to the position in the first (index: 0) dimension, the second index to the position of the element in the 
            second dimension (index: 1) and so forth ...</para>
            <para>If the array addressed by this size has less dimensions than addressed by this function, trailing indices 
            (i.e.: such indices which deal with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' or singleton dimensions. Those indices must address the 0-th element of the 
            virtual dimension. Hence its value must be 0.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by this function
            the last index parameter may exceeds the limit of its corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and folding 
            the superflous modulus of the value of the last parameter provided into the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the remaining index value reaches 0.</para>
            <para>Any index parameter may be negative, in which case the resulting index is computed by adding the 
            corresponding dimension length to the parameters value. Hence, a value of -1 addresses the last element in the dimension. 
            Note, that for the last specified dimension a value of -1 references the last element in the _virtual_ dimension,
            merged with any non specified trailing dimensions.</para>
            <para>This function recognizes arbitrarily strided objects. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.Int64.MaxValue"/>. Consider using one of the overloads with 
            <see cref="T:System.UInt32"/> parameters if you are not dealing with very big arrays and don't require negative indexing.
            This may bring better performance in tight loops.</para>
            <para>Performance hint: this function (and all corresponding overloads) are optimized for the case
            where the number of index parameters provided corresponds to the number of dimensions in the array and all 
            provided index parameters are within the range of their corresponding dimension. The functions, however, handle 
            arbitrary cases, including addressing, merging and ommitting trailing dimensions. Any of those extended features
            may introduce a performance penalty, though.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if any of the dimension specifiers <paramref name="d0"/> ... 
            <paramref name="d6"/> is equal or greater than the length of its corresponding dimension.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(ILNumerics.InArray{System.Int64})">
            <summary>
            Retrieves the element index of an element located at <paramref name="indices"/> stored in an array according to this size descriptor. 
            </summary>
            <param name="indices">Indices into each dimension of the element to retrieve.</param>
            <returns>The element index of the addressed item.</returns>
            <remarks><para>The value returned corresponds to the number of elements to add to the beginning of the underlying storage array in order 
            to find the requested element. Note that this offset has a unit of 'element'. If the element type is a reference type the array stores 
            its element in 1 dimensional managed arrays and the value returned by <see cref="M:ILNumerics.Size.GetSeqIndex(ILNumerics.InArray{System.Int64})"/> can directly be used for 
            indexing into this 1d array.</para> 
            <para>For value typed elements which are stored into unmanaged heaps and where access is done via pointers the address of the element 
            as addressed by <paramref name="indices"/> is computed by p = p0 + GetSeqIndex(indices) * sizeof(T). Here, p0 is the base address 
            (<see cref="T:System.IntPtr"/>, void* or byte*) of the arrays memory as acquired from <see cref="!:Array&lt;T&gt;.GetHostPointerForWrite()"/>.</para>
            <para><paramref name="indices"/> may contain negative dimension indices in which case the location of the element is considered at the 
            absolute value </para></remarks>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.Int64[])">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object 
            based on the provided index array <paramref name="d"/>. Allows negative indices.  
            </summary>
            <param name="d">System.Array with indices into the dimensions of this array.</param>
            <returns>Sequential index into the array when stored as 1D array of arbitrary storage order.</returns>
            <remarks>
            <para>If the array addressed by this size has less dimensions than addressed by <paramref name="d"/>, trailing 
            indices (i.e.: such indices dealing with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' dimensions. Virtual dimensions are always singleton dimensions, hence indices must 
            address the 0-th element of the virtual dimension.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by <paramref name="d"/>
            the value of the last index from <paramref name="d"/> may exceed the length of the corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and folding 
            the superflous modulus of the value of 'd[{last}]' to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of 'd[{last}]' 
            reaches 0.</para>
            <para>Any index parameter may be negative, in which case the resulting index is computed by adding the 
            corresponding dimension length to the parameters value. Hence, a value of -1 addresses the last element in the dimension. 
            Note, that for the last specified dimension a value of -1 references the last element in the _last_ dimension, i.e.: 
            unspecified trailing dimensions are (virtually) merged into a single dimension, having a length of the product of the 
            lengths of the existing unspecified, trailing dimensions.</para>
            <para>This function recognizes arbitrarily strided size objects. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.Int64.MaxValue"/>. Consider using one of the overloads with 
            <see cref="T:System.UInt32"/> parameters if you are not dealing with very big arrays and don't require negative indexing.
            This may bring better performance in tight loops.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if any of the indices in <paramref name="d"/> (except the 
            last index stored, see above) is equal or greater than the length of its corresponding dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> the resulting index points to a non-existing element.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex_NP(System.Int64)">
            <summary>
            Computes the memory element offset into an array stored according to this BSD to retrieve the element identified by the _row major_ sequential element index <paramref name="d0"/>.
            </summary>
            <param name="d0">Sequential element index, in range [-NumberOfElements]...NumberOfElements-1.</param>
            <returns>Memory element index to retrieve the element from the underlying 1D storage array.</returns>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="d0"/> is outside the range of existing elements.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.Int64*,System.Int64)">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object 
            based on the provided index array <paramref name="d"/>. Allows negative indices.  
            </summary>
            <param name="d">System.Array with indices into the dimensions of this array. Negative indices count from the end of a dimension.</param>
            <param name="len">Length of <paramref name="d"/>.</param>
            <returns>Sequential index into the array when stored as 1D array of arbitrary storage order.</returns>
            <remarks>
            <para>If the array addressed by this size has less dimensions than addressed by <paramref name="d"/>, trailing 
            indices (i.e.: such indices dealing with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' or singleton dimensions. Those indices must address the 0-th element of the 
            virtual dimension. Hence its value must be 0.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by <paramref name="d"/>
            the value of the last index from <paramref name="d"/> may exceeds the length of the corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and folding 
            the superflous modulus of the value of 'd[{last}]' to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of 'd[{last}]' 
            reaches 0.</para>
            <para>This function recognizes arbitrarily strided size objects. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.Int64.MaxValue"/>. Consider using one of the overloads with 
            <see cref="T:System.UInt32"/> parameters if you are not dealing with very big arrays.
            This may bring better performance in tight loops.</para>
            <para>Any index in <paramref name="d"/> which is negative is translated into the corresponding index found by 
            counting from the end (numpy negative index translation). Note that negative indices are allowed for any dimension 
            except the last dimension given by <paramref name="d"/> and when <paramref name="len"/> &lt; <see cref="P:ILNumerics.Size.NumberOfDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if any of the indices in <paramref name="d"/> (except the 
            last index stored, see above) is equal or greater than the length of its corresponding dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> the resulting index points to a non-existing element.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.UInt32)">
            <summary>
            Retrieves the storage element index into an array stored according to this size descriptor object
            based on the provided sequential index <paramref name="d0"/>.  
            </summary>
            <param name="d0">Index into the first dimension / sequential index.</param>
            <returns>Storage element index addressing the element in memory.</returns>
            <remarks><para>For arrays of column vector shape <paramref name="d0"/> references the index of the row of the 
            storage element to return.</para>
            <para>More general, for <see cref="P:ILNumerics.Size.NumberOfDimensions">n-dimensional</see> arrays the first index corresponds 
            to the position in the first (index 0) dimension.</para>
            <para>If the array refered to by this size stores more dimensions than addressable by this function
            <paramref name="d0"/> can exceed the limits of the first dimension. In this 
            case the storage element index to be returned is computed by subsequently merging trailing dimensions and applying 
            the superflous modulos of the value of <paramref name="d0"/> to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the superflous indices reach the value of 0.</para>
            <para>This function recognizes arbitrary strides. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.UInt32.MaxValue"/>. Use one of the overloads with 
            <see cref="T:System.Int64"/> parameters if you are dealing with very big arrays or negative indices.</para>
            <para>Performance hint: this function (and all corresponding overloads) are optimized for the case
            where the number of index parameters provided corresponds to the number of dimensions in the array and all 
            provided index parameters are within the range of their corresponding dimension. The functions, however, handle 
            arbitrary cases, including addressing, merging and ommitting trailing dimensions. Any of those extended features
            may introduce a performance penalty, though.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the leading dimension specifier <paramref name="d0"/> is equal to
            or greater than the <see cref="P:ILNumerics.Size.NumberOfElements"/>.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.UInt32,System.UInt32)">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object 
            based on the provided indices <paramref name="d0"/> and <paramref name="d1"/>.   
            </summary>
            <param name="d0">Index into the first dimension.</param>
            <param name="d1">Index into the second dimension.</param>
            <returns>Storage element index addressing the element in memory.</returns>
            <remarks><para>For arrays of matrix shape <paramref name="d0"/> references the index of the row and 
            <paramref name="d1"/> references the index of the column of the sequential index to return.</para>
            <para>More general, for <see cref="P:ILNumerics.Size.NumberOfDimensions">n-dimensional</see> arrays the first index corresponds 
            to the position in the first (index: 0) dimension and the second index to the position of the element in the 
            second dimension (index: 1).</para>
            <para>If the array refered to by this size stores more dimensions than addressed by this function
            the last index parameter <paramref name="d1"/> can exceed the limits of its corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and applying 
            the superflous modulos of the value of <paramref name="d1"/> to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of <paramref name="d1"/> 
            reaches 0.</para>
            <para>This function recognizes arbitrary strides. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.UInt32.MaxValue"/>. Use one of the overloads with 
            <see cref="T:System.Int64"/> parameters if you are dealing with very big arrays or negative indices.</para>
            <para>Performance hint: this function (and all corresponding overloads) are optimized for the case
            where the number of index parameters provided corresponds to the number of dimensions in the array and all 
            provided index parameters are within the range of their corresponding dimension. The functions, however, handle 
            arbitrary cases, including addressing, merging and ommitting trailing dimensions. Any of those extended features
            may introduce a performance penalty, though.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the leading dimension specifier <paramref name="d0"/> is equal to
            or greater than the length of the first dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="d1"/> is equal or greater than the length of 
            the second dimension and the resulting index points to a non-existing element.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object based 
            on the provided indices <paramref name="d0"/> ... <paramref name="d2"/>.  
            </summary>
            <param name="d0">Index into the first dimension.</param>
            <param name="d1">Index into the second dimension.</param>
            <param name="d2">Index into the third dimension.</param>
            <returns>Sequential index into the array when stored as 1D array of arbitrary storage order.</returns>
            <remarks><para>For arrays of matrix shape <paramref name="d0"/> references the index of the row and 
            <paramref name="d1"/> references the index of the column of the sequential index to return.</para>
            <para>More general, for <see cref="P:ILNumerics.Size.NumberOfDimensions">n-dimensional</see> arrays the first index corresponds 
            to the position in the first (index: 0) dimension, the second index to the position of the element in the 
            second dimension (index: 1), a.s.o.</para>
            <para>If the array addressed by this size has less dimensions than addressed by this function, trailing indices 
            (i.e.: such indices which deal with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' or singleton dimensions. Those indices must address the 0-th element of the 
            virtual dimension. Hence its value must be 0.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by this function
            the last index parameter <paramref name="d2"/> may exceeds the limit of its corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and applying 
            the superflous modulus of the value of <paramref name="d2"/> to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of <paramref name="d2"/> 
            reaches 0.</para>
            <para>This function recognizes arbitrarily strided size objects. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.UInt32.MaxValue"/>. Use one of the overloads with 
            <see cref="T:System.Int64"/> parameters if you are dealing with very big arrays or negative indices.</para>
            <para>Performance hint: this function (and all corresponding overloads) are optimized for the case
            where the number of index parameters provided corresponds to the number of dimensions in the array and all 
            provided index parameters are within the range of their corresponding dimension. The functions, however, handle 
            arbitrary cases, including addressing, merging and ommitting trailing dimensions. Any of those extended features
            may introduce a performance penalty, though.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if the leading dimension specifier <paramref name="d0"/> is equal 
            or greater than the length of the first dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> if the leading dimension specifier <paramref name="d1"/> is equal 
            or greater than the length of the second dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="d2"/> is equal or greater than the length of the 
            third dimension and the resulting index points to an non-existing element.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object 
            based on the provided indices <paramref name="d0"/> ... <paramref name="d3"/>.   
            </summary>
            <param name="d0">Index into the first dimension.</param>
            <param name="d1">Index into the second dimension.</param>
            <param name="d2">Index into the third dimension.</param>
            <param name="d3">Index into the fourth dimension.</param>
            <returns>Sequential index into the array when stored as 1D array of arbitrary storage order.</returns>
            <remarks><para>For arrays of matrix shape <paramref name="d0"/> references the index of the row and 
            <paramref name="d1"/> references the index of the column of the sequential index to return.</para>
            <para>More general, for <see cref="P:ILNumerics.Size.NumberOfDimensions">n-dimensional</see> arrays the first index corresponds 
            to the position in the first (index: 0) dimension, the second index to the position of the element in the 
            second dimension (index: 1) and so forth ...</para>
            <para>If the array addressed by this size has less dimensions than addressed by this function, trailing indices 
            (i.e.: such indices which deal with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' or singleton dimensions. Those indices must address the 0-th element of the 
            virtual dimension. Hence its value must be 0.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by this function
            the last index parameter <paramref name="d3"/> may exceeds the limit of its corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and applying 
            the superflous modulus of the value of <paramref name="d3"/> to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of <paramref name="d3"/> 
            reaches 0.</para>
            <para>This function recognizes arbitrarily strided size objects. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.UInt32.MaxValue"/>. Use one of the overloads with 
            <see cref="T:System.Int64"/> parameters if you are dealing with very big arrays or negative indices.</para>
            <para>Performance hint: this function (and all corresponding overloads) are optimized for the case
            where the number of index parameters provided corresponds to the number of dimensions in the array and all 
            provided index parameters are within the range of their corresponding dimension. The functions, however, handle 
            arbitrary cases, including addressing, merging and ommitting trailing dimensions. Any of those extended features
            may introduce a performance penalty, though.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if any of the leading dimension specifiers <paramref name="d0"/> ... 
            <paramref name="d2"/> is equal or greater than the length of its corresponding dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="d3"/> is equal or greater than the length 
            of the fourth dimension and the resulting index after merging trailing dimensions points to a non-existing element.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object 
            based on the provided indices <paramref name="d0"/> ... <paramref name="d4"/>.   
            </summary>
            <param name="d0">Index into the first dimension.</param>
            <param name="d1">Index into the second dimension.</param>
            <param name="d2">Index into the third dimension.</param>
            <param name="d3">Index into the fourth dimension.</param>
            <param name="d4">Index into the fives dimension.</param>
            <returns>Sequential index into the array when stored as 1D array of arbitrary storage order.</returns>
            <remarks><para>For arrays of matrix shape <paramref name="d0"/> references the index of the row and 
            <paramref name="d1"/> references the index of the column of the sequential index to return.</para>
            <para>More general, for <see cref="P:ILNumerics.Size.NumberOfDimensions">n-dimensional</see> arrays the first index corresponds 
            to the position in the first (index: 0) dimension, the second index to the position of the element in the 
            second dimension (index: 1) and so forth ...</para>
            <para>If the array addressed by this size has less dimensions than addressed by this function, trailing indices 
            (i.e.: such indices which deal with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' or singleton dimensions. Those indices must address the 0-th element of the 
            virtual dimension. Hence its value must be 0.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by this function
            the last index parameter <paramref name="d4"/> may exceeds the limit of its corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and applying 
            the superflous modulus of the value of <paramref name="d4"/> to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of <paramref name="d4"/> 
            reaches 0.</para>
            <para>This function recognizes arbitrarily strided size objects. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.UInt32.MaxValue"/>. Use one of the overloads with 
            <see cref="T:System.Int64"/> parameters if you are dealing with very big arrays or negative indices.</para>
            <para>Performance hint: this function (and all corresponding overloads) are optimized for the case
            where the number of index parameters provided corresponds to the number of dimensions in the array and all 
            provided index parameters are within the range of their corresponding dimension. The functions, however, handle 
            arbitrary cases, including addressing, merging and ommitting trailing dimensions. Any of those extended features
            may introduce a performance penalty, though.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if any of the leading dimension specifiers <paramref name="d0"/> ... 
            <paramref name="d3"/> is equal or greater than the length of its corresponding dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="d4"/> is equal or greater than the length 
            of the fives dimension and the resulting index after merging trailing dimensions points to a non-existing element.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object 
            based on the provided indices <paramref name="d0"/> ... <paramref name="d5"/>.   
            </summary>
            <param name="d0">Index into the first dimension.</param>
            <param name="d1">Index into the second dimension.</param>
            <param name="d2">Index into the third dimension.</param>
            <param name="d3">Index into the fourth dimension.</param>
            <param name="d4">Index into the fives dimension.</param>
            <param name="d5">Index into the sixth dimension.</param>
            <returns>Sequential index into the array when stored as 1D array of arbitrary storage order.</returns>
            <remarks><para>For arrays of matrix shape <paramref name="d0"/> references the index of the row and 
            <paramref name="d1"/> references the index of the column of the sequential index to return.</para>
            <para>More general, for <see cref="P:ILNumerics.Size.NumberOfDimensions">n-dimensional</see> arrays the first index corresponds 
            to the position in the first (index: 0) dimension, the second index to the position of the element in the 
            second dimension (index: 1) and so forth ...</para>
            <para>If the array addressed by this size has less dimensions than addressed by this function, trailing indices 
            (i.e.: such indices which deal with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' or singleton dimensions. Those indices must address the 0-th element of the 
            virtual dimension. Hence its value must be 0.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by this function
            the last index parameter <paramref name="d5"/> may exceeds the limit of its corresponding dimension. In this 
            case the sequential index returned is computed by subsequently merging trailing dimensions and folding 
            the superflous modulus of the value of <paramref name="d5"/> to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of <paramref name="d5"/> 
            reaches 0.</para>
            <para>This function recognizes arbitrarily strided size objects. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.UInt32.MaxValue"/>. Use one of the overloads with 
            <see cref="T:System.Int64"/> parameters if you are dealing with very big arrays or negative indices.</para>
            <para>Performance hint: this function (and all corresponding overloads) are optimized for the case
            where the number of index parameters provided corresponds to the number of dimensions in the array and all 
            provided index parameters are within the range of their corresponding dimension. The functions, however, handle 
            arbitrary cases, including addressing, merging and ommitting trailing dimensions. Any of those extended features
            may introduce a performance penalty, though.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if any of the leading dimension specifiers <paramref name="d0"/> ... 
            <paramref name="d4"/> is equal or greater than the length of its corresponding dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="d5"/> is equal or greater than the length 
            of the last dimension and the resulting index after merging trailing dimensions points to a non-existing element.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object 
            based on the provided indices <paramref name="d0"/> ... <paramref name="d6"/>.   
            </summary>
            <param name="d0">Index into the first dimension.</param>
            <param name="d1">Index into the second dimension.</param>
            <param name="d2">Index into the third dimension.</param>
            <param name="d3">Index into the fourth dimension.</param>
            <param name="d4">Index into the fives dimension.</param>
            <param name="d5">Index into the sixth dimension.</param>
            <param name="d6">Index into the seventh dimension.</param>
            <returns>Sequential index into the array when stored as 1D array of arbitrary storage order.</returns>
            <remarks><para>For arrays of matrix shape <paramref name="d0"/> references the index of the row and 
            <paramref name="d1"/> references the index of the column of the sequential index to return.</para>
            <para>More general, for <see cref="P:ILNumerics.Size.NumberOfDimensions">n-dimensional</see> arrays the first index corresponds 
            to the position in the first (index: 0) dimension, the second index to the position of the element in the 
            second dimension (index: 1) and so forth ...</para>
            <para>If the array addressed by this size has less dimensions than addressed by this function, trailing indices 
            (i.e.: such indices which deal with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' or singleton dimensions. Those indices must address the 0-th element of the 
            virtual dimension. Hence its value must be 0.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by this function
            the last index parameter may exceeds the limit of its corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and folding 
            the superflous modulus of the value of the last parameter provided into the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the remaining index value reaches 0.</para>
            <para>This function recognizes arbitrarily strided objects. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.UInt32.MaxValue"/>. Use one of the overloads with 
            <see cref="T:System.Int64"/> parameters if you are dealing with very big arrays or negative indices.</para>
            <para>Performance hint: this function (and all corresponding overloads) are optimized for the case
            where the number of index parameters provided corresponds to the number of dimensions in the array and all 
            provided index parameters are within the range of their corresponding dimension. The functions, however, handle 
            arbitrary cases, including addressing, merging and ommitting trailing dimensions. Any of those extended features
            may introduce a performance penalty, though.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if any of the dimension specifiers <paramref name="d0"/> ... 
            <paramref name="d6"/> is equal or greater than the length of its corresponding dimension.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.UInt32[])">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object 
            based on the provided index array <paramref name="d"/>. 
            </summary>
            <param name="d">System.Array with indices into the dimensions of this array.</param>
            <returns>Sequential index into the array when stored as 1D array of arbitrary storage order.</returns>
            <remarks>
            <para>If the array addressed by this size has less dimensions than addressed by <paramref name="d"/>, trailing 
            indices (i.e.: such indices dealing with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' or singleton dimensions. Those indices must address the 0-th element of the 
            virtual dimension. Hence its value must be 0.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by <paramref name="d"/>
            the value of the last index from <paramref name="d"/> may exceed the length of the corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and folding 
            the superflous modulus of the value of 'd[{last}]' to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of 'd[{last}]' 
            reaches 0.</para>
            <para>This function recognizes arbitrarily strided size objects. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.UInt32.MaxValue"/>. Use one of the overloads with 
            <see cref="T:System.Int64"/> parameters if you are dealing with very big arrays or negative indices.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if any of the indices in <paramref name="d"/> (except the 
            last index stored, see above) is equal or greater than the length of its corresponding dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> the resulting index points to a non-existing element.</exception>
        </member>
        <member name="M:ILNumerics.Size.GetSeqIndex(System.UInt32*,System.UInt32)">
            <summary>
            Retrieves the sequential index into an array stored according to this size descriptor object 
            based on the provided index array <paramref name="d"/>. 
            </summary>
            <param name="d">System.Array with indices into the dimensions of this array.</param>
            <param name="len">Length of <paramref name="d"/>.</param>
            <returns>Sequential index into the array when stored as 1D array of arbitrary storage order.</returns>
            <remarks>
            <para>If the array addressed by this size has less dimensions than addressed by <paramref name="d"/>, trailing 
            indices (i.e.: such indices dealing with a dimension whose index is higher than existing in the array)
            correspond to 'virtual' or singleton dimensions. Those indices must address the 0-th element of the 
            virtual dimension. Hence its value must be 0.</para>
            <para>Conversely, if the array addressed by this size stores more dimensions than addressed by <paramref name="d"/>
            the value of the last index from <paramref name="d"/> may exceed the length of the corresponding dimension. In this 
            case the sequential index to be returned is computed by subsequently merging trailing dimensions and folding 
            the superflous modulus of the value of 'd[{last}]' to the next dimension, correspondingly. This process 
            is repeated until either the number of dimensions is reached or the modified new value of 'd[{last}]' 
            reaches 0.</para>
            <para>This function recognizes arbitrarily strided size objects. It expects all sizes (dimension lengths, strides, the base offset 
            and the number of elements) to fit into <see cref="F:System.UInt32.MaxValue"/>. Use one of the overloads with 
            <see cref="T:System.Int64"/> parameters if you are dealing with very big arrays or negative indices.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if any of the indices in <paramref name="d"/> (except the 
            last index stored, see above) is equal or greater than the length of its corresponding dimension.</exception>
            <exception cref="T:System.IndexOutOfRangeException"> the resulting index points to a non-existing element.</exception>
        </member>
        <member name="T:ILNumerics.DimSpec">
            <summary>
            Class representing a one-dimensional slice / range or single index along a dimension. Used for subarray indexing.
            </summary>
        </member>
        <member name="M:ILNumerics.DimSpec.Create">
            <summary>
            Create uninitialized dimension specifier.
            </summary>
            <returns>Uninitialized dimension specifier.</returns>
        </member>
        <member name="P:ILNumerics.DimSpec.Length">
            <summary>
            Number of elements referenced by this dimension specifier.
            </summary>
        </member>
        <member name="M:ILNumerics.DimSpec.op_Implicit(System.UInt32)~ILNumerics.DimSpec">
            <summary>
            Implicit cast from single index to dimension specifier. 
            </summary>
            <param name="a">Single index.</param>
        </member>
        <member name="M:ILNumerics.DimSpec.op_Implicit(System.Int64)~ILNumerics.DimSpec">
            <summary>
            Implicit cast from single index to dimension specifier. 
            </summary>
            <param name="a">Single index.</param>
        </member>
        <member name="M:ILNumerics.DimSpec.GetStepSize">
            <summary>
            Gives the stepsize configured for this dimension specifier.
            </summary>
            <returns>step size.</returns>
        </member>
        <member name="M:ILNumerics.DimSpec.GetEnumerator">
            <summary>
            Gives an <see cref="T:System.Collections.Generic.IEnumerator`1"/> capable of iterating over the index range specified by this object.
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:ILNumerics.DimSpec.MoveNext">
            <summary>
            Increments the internal position counter to the next index.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.DimSpec.Reset">
            <summary>
            Places the internal position counter back before the first element.
            </summary>
        </member>
        <member name="T:ILNumerics.EllipsisSpec">
            <summary>
            This class supports the <see cref="F:ILNumerics.Globals.ellipsis"/> keyword in indexing operations. 
            </summary>
        </member>
        <member name="M:ILNumerics.EllipsisSpec.Dispose">
            <summary>
            Disposes this dim spec object. After disposing don't use the object anymore!
            </summary>
        </member>
        <member name="T:ILNumerics.EndExpression">
            <summary>
            Static class defining useful constants, shortcuts, aliases and functions for working with ILNumerics arrays. 
            </summary>
        </member>
        <member name="T:ILNumerics.ExpressionDimSpec">
            <summary>
            This class supports ranges / dimension specifiers defined with 'end' expressions. 
            </summary>
        </member>
        <member name="M:ILNumerics.ExpressionDimSpec.Create">
            <summary>
            Create uninitialized dimension specifier.
            </summary>
            <returns>Uninitialized dimension specifier.</returns>
        </member>
        <member name="M:ILNumerics.ExpressionDimSpec.Dispose">
            <summary>
            Disposes this dim spec object. After disposing don't use the object anymore!
            </summary>
        </member>
        <member name="T:ILNumerics.FullDimSpec">
            <summary>
            This class supports the <see cref="P:ILNumerics.Globals.full"/> specifier in indexing expressions.
            </summary>
        </member>
        <member name="M:ILNumerics.FullDimSpec.#ctor">
            <summary>
            Creates a new full dimension specifier.
            </summary>
        </member>
        <member name="M:ILNumerics.FullDimSpec.Create">
            <summary>
            Create uninitialized dimension specifier.
            </summary>
            <returns>Uninitialized dimension specifier.</returns>
        </member>
        <member name="M:ILNumerics.FullDimSpec.Dispose">
            <summary>
            Disposes this dim spec object. After disposing don't use the object anymore!
            </summary>
        </member>
        <member name="T:ILNumerics.IIndexIterator">
            <summary>
            Interface for objects usable as index iterators in subarray expressions.
            </summary>
            <remarks>Index iterators provide a safe and (reasonable) fast way of iterating the indices addressed by 
            subarray expressions for each dimension. All checks are performed at the creation time of the iterator. 
            This includes the checks for all indices being inside the valid range of an array.</remarks>
        </member>
        <member name="M:ILNumerics.IIndexIterator.GetLength">
            <summary>
             Gives the number of elements addressed by this object.
            </summary>
            <returns>Number of elements.</returns>
        </member>
        <member name="M:ILNumerics.IIndexIterator.GetMaximum">
            <summary>
            Gives the maximum index addressed by this iterator, if such value exists.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.IIndexIterator.GetMinimum">
            <summary>
            Gives the minimum index addressed by this iterator, if such value exists.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.IIndexIterator.GetLastDimensionIndex">
            <summary>
            Gets the index of the last element of the dimension this iterator is working along. 
            This must be provided by such iterators, capable of storing negative indices only.
            </summary>
            <returns></returns>
            <remarks>This value is specified at the time the iterator was initialized and used 
            for evaluating 'end' placeholders in some situations. For numpy array style this 
            equals the length of the corresponding dimension minus 1. For <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/>
            this corresponds to the last element index in this <b>and trailing, merged</b> dimensions.</remarks>
        </member>
        <member name="M:ILNumerics.IIndexIterator.GetStepSize">
            <summary>
            Gives the step size of the range, in case that this iterator object represents a simple (un-/stepped) range. Otherwise: null. 
            </summary>
        </member>
        <member name="T:ILNumerics.NewaxisSpec">
            <summary>
            This class supports the <see cref="F:ILNumerics.Globals.newaxis"/> keywords in numpy index expressions.
            </summary>
        </member>
    </members>
</doc>
